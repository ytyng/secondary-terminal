<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; style-src {{CSP_SOURCE}} 'unsafe-inline'; script-src {{CSP_SOURCE}} 'unsafe-inline';">
    <title>Secondary Terminal</title>
    <link rel="stylesheet" href="{{XTERM_CSS_URI}}" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }

        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-editor-foreground);
            font-family: "RobotoMono Nerd Font Mono", "Roboto Mono", Consolas, "Courier New", monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-container {
            flex: 1;
            width: 100%;
            min-height: 0;
            /* 重要：flexboxで子要素が縮むのを許可 */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: var(--vscode-sideBar-background);
        }

        #terminal {
            flex: 1;
            width: 100%;
            padding: 0 0 0 5px;
            min-height: 0;
            /* 重要：flexboxで縮むのを許可 */
            overflow: hidden;
            /* はみ出し防止 */
        }

        .terminal.xterm {
            padding: 0;

            /* xterm.js のコンテナを透明に */
            .xterm-viewport {
                background-color: transparent !important;
            }

            .xterm-screen {
                background-color: transparent !important;
            }

            .xterm-helper-textarea {
                background-color: transparent !important;
            }

            /* スクロール時に選択ハイライトが残る問題を修正 */
            .xterm-selection {
                overflow: hidden;
            }
        }

        /* コントロールパネル */
        .control-panel {
            flex-shrink: 0;
            /* 重要：縮まないように固定 */
            background-color: var(--vscode-panel-background, #252526);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            padding: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: start;
            box-sizing: border-box;
        }

        .control-panel-left-controls {
            display: flex;
            align-items: center;
            justify-content: start;
            flex-grow: 1;
            gap: 0.5em;
        }

        .control-panel-right-controls {
            display: flex;
            align-items: center;
            justify-content: end;
            padding: 0.5em;
            gap: 0.5em;
        }

        .control-button {
            background-color: var(--vscode-button-secondaryBackground, #3c3c3c);
            color: var(--vscode-button-secondaryForeground, #cccccc);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: background-color 0.2s;

            &:hover {
                background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
            }
        }

        .copy-button {
            background-color: var(--vscode-button-secondaryBackground, #3c3c3c);
            color: var(--vscode-button-secondaryForeground, #cccccc);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: background-color 0.2s;
            position: relative;

            &:hover {
                background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
            }

            &.done {
                color: transparent;
            }

            &.done::after {
                content: '✓';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: var(--vscode-button-secondaryForeground, #cccccc);
            }
        }


        /* CLI エージェントアクティブ表示 */
        .cli-agent-indicator {
            color: #888;
            font-family: inherit;
            font-size: 12px;
            transition: opacity 0.3s ease;
            opacity: 0;

            &.active {
                opacity: 1;
            }
        }


        /* ACE エディタコンテナ */
        .editor-container {
            flex-shrink: 0;
            background-color: var(--vscode-editor-background);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            border-bottom: 1px solid var(--vscode-panel-border, #3c3c3c);
            height: 200px;
            overflow: hidden;
        }

        #ace-editor {
            width: 100%;
            height: 100%;
        }

        /* カスタム ACE テーマ - VSCode ダーク風 */
        .ace-vscode-dark {
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);

            .ace_gutter {
                background-color: var(--vscode-editorGutter-background);
                color: var(--vscode-editorLineNumber-foreground);
                border-right: 1px solid var(--vscode-panel-border, #3c3c3c);
            }

            .ace_print-margin {
                width: 1px;
                background: var(--vscode-editorRuler-foreground);
            }

            .ace_cursor {
                color: var(--vscode-editorCursor-foreground);
            }

            .ace_marker-layer {
                .ace_selection {
                    background: var(--vscode-editor-selectionBackground);
                }

                .ace_step {
                    background: var(--vscode-debugTokenExpression-number);
                }

                .ace_bracket {
                    margin: -1px 0 0 -1px;
                    border: 1px solid var(--vscode-editorBracketMatch-border);
                    background: var(--vscode-editorBracketMatch-background);
                }

                .ace_active-line {
                    background: var(--vscode-editor-lineHighlightBackground);
                }

                .ace_selected-word {
                    border: 1px solid var(--vscode-editor-selectionHighlightBorder);
                    background: var(--vscode-editor-selectionHighlightBackground);
                }
            }

            &.ace_multiselect .ace_selection.ace_start {
                box-shadow: 0 0 3px 0px var(--vscode-editor-background);
                border-radius: 2px;
            }

            .ace_gutter-active-line {
                background-color: var(--vscode-editor-lineHighlightBackground);
            }

            .ace_invisible {
                color: var(--vscode-editorWhitespace-foreground, #404040);
            }

            .ace_keyword,
            .ace_meta,
            .ace_storage,
            .ace_storage.ace_type,
            .ace_support.ace_type {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_keyword.ace_operator {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_constant.ace_character,
            .ace_constant.ace_language,
            .ace_constant.ace_numeric,
            .ace_keyword.ace_other.ace_unit,
            .ace_support.ace_constant,
            .ace_variable.ace_parameter {
                color: var(--vscode-debugTokenExpression-number);
            }

            .ace_constant.ace_other {
                color: var(--vscode-debugTokenExpression-number);
            }

            .ace_invalid {
                color: var(--vscode-editorError-foreground);
                background-color: var(--vscode-editorError-background);

                &.ace_deprecated {
                    color: var(--vscode-editorWarning-foreground);
                    background-color: var(--vscode-editorWarning-background);
                }
            }

            .ace_fold {
                background-color: var(--vscode-debugTokenExpression-name);
                border-color: var(--vscode-debugTokenExpression-name);
            }

            .ace_entity.ace_name.ace_function,
            .ace_support.ace_function,
            .ace_variable {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_support.ace_class,
            .ace_support.ace_type {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_heading,
            .ace_markup.ace_heading {
                color: var(--vscode-debugTokenExpression-name);
                font-weight: bold;
            }

            .ace_list,
            .ace_markup.ace_list {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_list.ace_markup {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_punctuation.ace_definition.ace_list_begin {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_entity.ace_name.ace_tag,
            .ace_entity.ace_other.ace_attribute-name,
            .ace_meta.ace_tag,
            .ace_string.ace_regexp,
            .ace_variable {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_comment {
                color: var(--vscode-debugConsole-infoForeground);
                font-style: italic;
            }

            .ace_string {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_entity.ace_other.ace_attribute-name {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_indent-guide {
                background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChAGGzJY5NwAAAABJRU5ErkJggg==") right repeat-y;
            }
        }
    </style>
</head>

<body>
    <div class="terminal-container" id="terminal-container">

        <div id="terminal"></div>

        <!-- ACE エディタペイン -->
        <div class="editor-container">
            <div id="ace-editor"></div>
        </div>

        <!-- 下部コントロールパネル -->
        <div class="control-panel">
            <div class="control-panel-left-controls">
                <button class="control-button" id="btn-send-selection"
                    title="Send editor selection to terminal (Cmd+L)">
                    @Selection
                </button>
                <button class="copy-button" id="btn-copy-selection" title="Copy editor selection context to clipboard">
                    Copy
                </button>
                <button class="control-button" id="btn-extract-to-todos" title="Extract editor content to TODOS.md">
                    Extract
                </button>
                <button class="control-button" id="btn-open-history" title="Open prompt history file">
                    History
                </button>
                <button class="control-button" id="btn-scroll-to-bottom" title="Scroll to bottom of terminal">
                    ↓
                </button>
            </div>
            <div class="control-panel-right-controls">
                <!-- CLI エージェントインジケーター -->
                <div class="cli-agent-indicator" id="cli-agent-indicator"
                    title="CLI Agent is active - Shift+Enter inputs a newline">CLI Agent</div>
            </div>
        </div>
    </div>

    <script src="{{XTERM_JS_URI}}"></script>
    <script src="{{XTERM_UNICODE11_JS_URI}}"></script>
    <script src="{{XTERM_WEBGL_JS_URI}}"></script>

    <!-- ACE Editor Scripts -->
    <script src="{{ACE_JS_URI}}"></script>
    <script src="{{ACE_MODE_JAVASCRIPT_URI}}"></script>
    <script src="{{ACE_MODE_MARKDOWN_URI}}"></script>
    <script src="{{ACE_KEYBINDING_VSCODE_URI}}"></script>
    <script>
        const MAX_BUFFER_LINES = parseInt('{{SCROLLBACK_MAX}}'); // 設定された最大行数
        const vscode = acquireVsCodeApi();

        // グローバル変数とオブジェクトの管理オブジェクト
        const terminalState = {
            term: null,
            resizeObserver: null,
            timers: {
                sizeCheckInterval: null,
                backgroundColorInterval: null,
                writeBuffer: null
            },
            eventListeners: [],
            isInitialized: false,
            writeBufferData: '',
            writeBufferPending: false,
            currentContainerBackgroundColor: null,
            // アダプティブレンダリング用状態
            lastWriteTime: 0,
            recentWriteCount: 0,
            adaptiveDelayMs: 16,
        };

        // ACE エディタ用の状態管理
        const editorState = {
            editor: null,
            isInitialized: false
        };



        /**
         * ログメッセージを送信する
         */
        function log(...args) {
            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');
            vscode.postMessage({
                type: 'log',
                message: `[terminal.html] ${message}`
            })
        }

        /**
         * 画面消去系エスケープシーケンスを検知する
         * vim, less 等のTUIアプリの全画面再描画パターンを判定
         * 注: \x1b[H (カーソルホーム) はプロンプト表示でも使われるため除外
         */
        function hasScreenClearSequence(data) {
            return data.includes('\x1b[2J') ||    // 画面クリア
                   data.includes('\x1b[?1049');   // 代替バッファ切り替え
        }

        // ACE エディタ初期化関数
        function initializeAceEditor() {
            try {
                if (editorState.isInitialized) {
                    log('[ACE] Editor is already initialized');
                    return;
                }

                if (typeof ace === 'undefined') {
                    throw new Error('ACE is not defined. ace-builds may not have loaded.');
                }

                log('[ACE] Starting editor initialization');

                // VSCode ダークテーマを ACE に登録
                if (ace.define) {
                    ace.define('ace/theme/vscode-dark', ['require', 'exports', 'module'], function(require, exports, module) {
                        exports.isDark = true;
                        exports.cssClass = "ace-vscode-dark";
                        exports.cssText = ""; // CSS は HTML のスタイルで定義済み
                    });
                }

                // エディタを初期化
                editorState.editor = ace.edit("ace-editor");

                // 設定を適用
                editorState.editor.setTheme("ace/theme/vscode-dark");
                editorState.editor.session.setMode("ace/mode/markdown");
                editorState.editor.setKeyboardHandler("ace/keyboard/vscode");

                // エディタオプション
                editorState.editor.setOptions({
                    fontSize: 13,
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    showPrintMargin: false,
                    wrap: true,
                    showInvisibles: true,
                    enableBasicAutocompletion: true,
                    enableLiveAutocompletion: true,
                    enableSnippets: true
                });

                // 初期値を設定（永続化された値があれば復元）
                const savedContent = vscode.getState()?.editorContent || '';
                editorState.editor.setValue(savedContent, -1); // -1 でカーソルを先頭に

                // Command+Enter キーバインドを追加
                editorState.editor.commands.addCommand({
                    name: 'sendToTerminal',
                    bindKey: { win: 'Ctrl-Enter', mac: 'Cmd-Enter' },
                    exec: function(editor) {
                        log('[ACE] Command+Enter pressed');
                        const content = editor.getValue();
                        log('[ACE] Editor content:', content);

                        if (content.trim()) {
                            log('[ACE] Processing content for terminal...');

                            // 1. 末尾のホワイトスペース（改行含む）を除去
                            const trimmedContent = content.trimEnd();
                            log('[ACE] Trimmed content:', trimmedContent);

                            // 2. コンテンツをターミナルに送信
                            log('[ACE] Sending content to terminal');
                            vscode.postMessage({
                                type: 'editorSendContent',
                                data: trimmedContent
                            });
                            log('[ACE] Content sent to terminal');

                            // 3. 200ms 待機後に Enter を送信
                            setTimeout(() => {
                                log('[ACE] Sending Enter after 200ms');
                                vscode.postMessage({
                                    type: 'terminalInput',
                                    data: '\r'
                                });
                                log('[ACE] Enter sent to terminal');

                                // 4. エディタの内容をクリア
                                editor.setValue('', -1);
                                log('[ACE] Editor content cleared');
                            }, 200);
                        } else {
                            log('[ACE] Editor content is empty, not sending');
                        }
                    }
                });

                // エディタの内容が変更された時の処理
                editorState.editor.on('change', function() {
                    const content = editorState.editor.getValue();
                    // 内容を永続化
                    vscode.setState({
                        ...vscode.getState(),
                        editorContent: content
                    });
                });

                // DOM レベルでのキーイベント処理を追加（ACE のキーバインディングより優先度高）
                const aceContainer = document.getElementById('ace-editor');
                if (aceContainer) {
                    aceContainer.addEventListener('keydown', function(event) {
                        // Command+Enter (Mac) または Ctrl+Enter (Windows) をキャッチ
                        if (event.key === 'Enter' && (event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey) {
                            log('[ACE DOM] Command+Enter detected');
                            event.preventDefault(); // デフォルトの動作を阻止
                            event.stopPropagation(); // イベントの伝播を停止

                            const content = editorState.editor.getValue();
                            log('[ACE DOM] Editor content:', content);

                            if (content.trim()) {
                                log('[ACE DOM] Processing content for terminal...');

                                // 1. 末尾のホワイトスペース（改行含む）を除去
                                const trimmedContent = content.trimEnd();
                                log('[ACE DOM] Trimmed content:', trimmedContent);

                                // 2. コンテンツをターミナルに送信
                                log('[ACE DOM] Sending content to terminal');
                                vscode.postMessage({
                                    type: 'editorSendContent',
                                    data: trimmedContent
                                });
                                log('[ACE DOM] Content sent to terminal');

                                // 3. 200ms 待機後に Enter を送信
                                setTimeout(() => {
                                    log('[ACE DOM] Sending Enter after 200ms');
                                    vscode.postMessage({
                                        type: 'terminalInput',
                                        data: '\r'
                                    });
                                    log('[ACE DOM] Enter sent to terminal');

                                    // 4. エディタの内容をクリア
                                    editorState.editor.setValue('', -1);
                                    log('[ACE DOM] Editor content cleared');
                                }, 200);
                            } else {
                                log('[ACE DOM] Editor content is empty, not sending');
                            }

                            return false; // イベント処理終了
                        }
                    }, true); // useCapture = true で早期にキャプチャ
                    log('[ACE] DOM keydown listener added');
                }

                editorState.isInitialized = true;
                log('[ACE] Editor initialization completed');

            } catch (error) {
                log('[ACE] Error initializing editor:', error);
            }
        }

        // リソース完全リセット関数
        function resetTerminalResources() {
            log('[LEAK CHECK] Starting resource reset');

            // xterm のリスナーを先に dispose
            if (terminalState.xtermListeners && terminalState.xtermListeners.length > 0) {
                log('[LEAK CHECK] Disposing ' + terminalState.xtermListeners.length + ' xterm listeners');
                terminalState.xtermListeners.forEach(listener => {
                    try {
                        if (listener && listener.dispose) {
                            listener.dispose();
                        }
                    } catch (error) {
                        log('[LEAK CHECK] Error disposing xterm listener:', error);
                    }
                });
                terminalState.xtermListeners = [];
            }

            // アドオンを dispose
            if (terminalState.addons && terminalState.addons.length > 0) {
                log('[LEAK CHECK] Disposing ' + terminalState.addons.length + ' addons');
                terminalState.addons.forEach(addon => {
                    try {
                        if (addon && addon.dispose) {
                            addon.dispose();
                        }
                    } catch (error) {
                        log('[LEAK CHECK] Error disposing addon:', error);
                    }
                });
                terminalState.addons = [];
            }

            // 既存のターミナルを破棄
            if (terminalState.term) {
                try {
                    log('[LEAK CHECK] Disposing terminal instance');
                    terminalState.term.dispose();
                } catch (error) {
                    log('Error disposing terminal:', error);
                }
                terminalState.term = null;
            }

            // ResizeObserver を停止
            if (terminalState.resizeObserver) {
                try {
                    terminalState.resizeObserver.disconnect();
                } catch (error) {
                    log('Error disconnecting ResizeObserver:', error);
                }
                terminalState.resizeObserver = null;
            }

            // すべてのタイマーをクリア
            Object.keys(terminalState.timers).forEach(timerKey => {
                if (terminalState.timers[timerKey]) {
                    try {
                        clearTimeout(terminalState.timers[timerKey]);
                        clearInterval(terminalState.timers[timerKey]);
                        cancelAnimationFrame(terminalState.timers[timerKey]);
                    } catch (error) {
                        log(`Error clearing timer ${timerKey}:`, error);
                    }
                    terminalState.timers[timerKey] = null;
                }
            });

            // バッファもクリア
            terminalState.writeBufferData = '';
            terminalState.writeBufferPending = false;

            // イベントリスナーをすべて削除
            terminalState.eventListeners.forEach(({ element, event, handler }) => {
                try {
                    element.removeEventListener(event, handler);
                } catch (error) {
                    log('Error removing event listener:', error);
                }
            });
            terminalState.eventListeners = [];

            // 初期化フラグをリセット
            terminalState.isInitialized = false;
        }

        // イベントリスナー登録ヘルパー（管理対象に追加）
        function addManagedEventListener(element, event, handler) {
            element.addEventListener(event, handler);
            terminalState.eventListeners.push({ element, event, handler });
        }

        // 大量ペーストのチャンク送信機能
        function sendBytesInChunks(bytes, meta) {
            const CHUNK_SIZE = 32 * 1024; // 32KB チャンクサイズ
            const id = Math.random().toString(36).slice(2); // ランダム ID
            let offset = 0;

            // ACK 待ち用のイベントリスナー
            const onAck = (event) => {
                const message = event.data;
                if (!message || message.type !== 'terminalInputAck' || message.id !== id) {
                    return;
                }

                if (message.done) {
                    // 送信完了
                    window.removeEventListener('message', onAck);
                    log('[PASTE CHUNKS] All chunks sent successfully');
                    return;
                }

                // 次のチャンクを送信
                sendNextChunk();
            };

            window.addEventListener('message', onAck);

            // 送信開始通知
            log('[PASTE CHUNKS] Starting chunked paste, total bytes:', bytes.length);
            vscode.postMessage({
                type: 'terminalInputBegin',
                id: id,
                totalBytes: bytes.length,
                ...meta
            });

            function sendNextChunk() {
                if (offset >= bytes.length) {
                    // 送信終了通知
                    vscode.postMessage({ type: 'terminalInputEnd', id: id });
                    return;
                }

                const chunkEnd = Math.min(offset + CHUNK_SIZE, bytes.length);
                const slice = bytes.subarray(offset, chunkEnd);

                // base64 エンコーディングで安全に転送
                const b64 = btoa(String.fromCharCode.apply(null, slice));

                log('[PASTE CHUNKS] Sending chunk', offset, 'to', chunkEnd, 'of', bytes.length);
                vscode.postMessage({
                    type: 'terminalInputChunk',
                    id: id,
                    b64: b64,
                    offset: offset,
                    size: slice.length
                });

                offset = chunkEnd;
            }

            // 最初のチャンクを送信
            sendNextChunk();
        }

        // 定期的なバッファクリア機能
        function setupPeriodicBufferCleanup() {
            // 設定可能な値
            const BUFFER_CHECK_INTERVAL = 30000; // 30秒間隔でチェック
            const CLEANUP_THRESHOLD = Math.floor(MAX_BUFFER_LINES * 0.8); // 80%で警告
            const CLEANUP_TARGET = Math.floor(MAX_BUFFER_LINES * 0.6); // 60%まで削減

            log('[BUFFER CLEANUP] Setting up periodic buffer cleanup', {
                checkInterval: BUFFER_CHECK_INTERVAL,
                maxLines: MAX_BUFFER_LINES,
                cleanupThreshold: CLEANUP_THRESHOLD,
                cleanupTarget: CLEANUP_TARGET
            });

            const bufferCleanupTimer = setInterval(() => {
                if (!terminalState.term) {
                    return;
                }

                try {
                    const buffer = terminalState.term.buffer;
                    if (!buffer || !buffer.active) {
                        return;
                    }

                    const totalLines = buffer.active.length;
                    const scrollbackLines = totalLines - terminalState.term.rows;

                    log('[BUFFER CLEANUP] Buffer check', {
                        totalLines,
                        scrollbackLines,
                        threshold: CLEANUP_THRESHOLD,
                        terminalRows: terminalState.term.rows
                    });

                    // スクロールバック行数が閾値を超えた場合、クリアを実行
                    if (scrollbackLines > CLEANUP_THRESHOLD) {
                        log('[BUFFER CLEANUP] Buffer cleanup triggered', {
                            currentLines: scrollbackLines,
                            targetLines: CLEANUP_TARGET
                        });

                        // 現在のスクロール位置を保存
                        const currentScrollY = terminalState.term.buffer.active.viewportY;
                        const isAtBottom = currentScrollY >= (totalLines - terminalState.term.rows);

                        log('[BUFFER CLEANUP] Current scroll position', {
                            currentScrollY,
                            totalLines,
                            terminalRows: terminalState.term.rows,
                            isAtBottom
                        });

                        // 少し待ってからクリアを実行
                        setTimeout(() => {
                            try {
                                // VSCode 側にバッファクリア要求を送信
                                vscode.postMessage({
                                    type: 'bufferCleanupRequest',
                                    currentLines: scrollbackLines,
                                    threshold: CLEANUP_THRESHOLD,
                                    preserveScrollPosition: !isAtBottom // 最下部にいない場合はスクロール位置を保持
                                });

                                // 最下部にいない場合はスクロール位置を変更しない
                                // 最下部にいる場合、または問題がある場合のみ scrollToBottom() を実行
                                if (isAtBottom) {
                                    log('[BUFFER CLEANUP] User was at bottom, scrolling to bottom');
                                    terminalState.term.scrollToBottom();
                                } else {
                                    log('[BUFFER CLEANUP] User was not at bottom, preserving scroll position');
                                }

                                log('[BUFFER CLEANUP] Buffer cleanup completed');

                            } catch (error) {
                                log('[BUFFER CLEANUP] Error during buffer cleanup:', error);
                                // エラーが発生した場合のみ強制的にスクロール
                                terminalState.term.scrollToBottom();
                            }
                        }, 100);
                    }
                } catch (error) {
                    log('[BUFFER CLEANUP] Error checking buffer:', error);
                }
            }, BUFFER_CHECK_INTERVAL);

            // タイマーを管理対象に追加
            terminalState.timers.bufferCleanup = bufferCleanupTimer;
            log('[BUFFER CLEANUP] Periodic buffer cleanup timer set');
        }

        // ターミナル初期化関数
        function initializeTerminal() {
            try {
                // 重複初期化を厳密にチェック
                if (terminalState.isInitialized) {
                    log('[INIT] Terminal is already initialized, skipping duplicate initialization');

                    // 既に初期化済みの場合は、サイズ調整とフォーカスのみ実行
                    if (terminalState.term) {
                        setTimeout(() => {
                            setTerminalSize();
                            terminalState.term.focus();
                        }, 50);
                    }
                    return;
                }

                // CSS変数をデバッグ
                log(`[INIT] CSS Variables: vscode-sideBar-background:${document.documentElement.style.getPropertyValue('--vscode-sideBar-background')}, vscode-terminal-foreground:${document.documentElement.style.getPropertyValue('--vscode-terminal-foreground')}, vscode-terminal-background:${document.documentElement.style.getPropertyValue('--vscode-terminal-background')}`);

                // 二重初期化を防ぐため、最初にフラグを立てる
                terminalState.isInitialized = true;

                log('[INIT] Starting terminal initialization');

                if (typeof Terminal === 'undefined') {
                    throw new Error('Terminal is not defined. xterm.js may not have loaded.');
                }

                terminalState.term = new Terminal({
                    theme: {
                        // ↓ おそらく、ターミナル内で上書きされる
                        // background: 'var(--vscode-sideBar-background)',
                        background: document.documentElement.style.getPropertyValue('--vscode-sideBar-background') || '#111111',
                        foreground: document.documentElement.style.getPropertyValue('--vscode-terminal-foreground') || '#ffffff',
                        cursor: document.documentElement.style.getPropertyValue('--vscode-terminal-cursor-foreground') || '#ffffff',
                        selection: document.documentElement.style.getPropertyValue('--vscode-terminal-selection-background') || '#ffffff'
                    },
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    fontSize: 13,
                    letterSpacing: 0,
                    lineHeight: 1.2,
                    cursorBlink: false,
                    smoothScrollDuration: 0,  // スムーズスクロールを無効化（パフォーマンス向上）
                    convertEol: true,
                    allowProposedApi: true,
                    allowTransparency: false,
                    minimumContrastRatio: 1,
                    // ペーストをアプリに「まとまり」として伝える
                    bracketedPasteMode: true,
                    // スクロールバック上限を設定（大きな履歴での write/render 負荷を軽減）
                    scrollback: MAX_BUFFER_LINES
                });

                const terminalElement = document.getElementById('terminal');
                terminalState.term.open(terminalElement);

                // 2秒ごとにスクロール位置をチェックし、最上部なら最下部にスクロール
                const scrollCheckInterval = setInterval(() => {
                    if (!terminalState.term || !terminalState.term.buffer || !terminalState.term.buffer.active) {
                        return;
                    }
                    const buffer = terminalState.term.buffer.active;
                    // スクロール位置が厳密に0(最上部)の時のみ
                    if (buffer.viewportY === 0) {
                        terminalState.term.scrollToBottom();
                    }
                }, 2000);

                // タイマーを管理対象に追加
                terminalState.timers.scrollCheck = scrollCheckInterval;
                log('[LEAK CHECK] Added scroll position check interval (2000ms)');

                // Unicode 11 アドオンをロード
                if (typeof Unicode11Addon !== 'undefined') {
                    try {
                        const unicode11 = new Unicode11Addon.Unicode11Addon();
                        terminalState.term.loadAddon(unicode11);
                        unicode11.activate(terminalState.term);
                        log('[LEAK CHECK] Unicode11 addon loaded');

                        // アドオンを管理対象に追加
                        if (!terminalState.addons) {
                            terminalState.addons = [];
                        }
                        terminalState.addons.push(unicode11);
                    } catch (error) {
                        log('Failed to load Unicode 11 addon:', error);
                    }
                }

                // WebGL アドオンをロード
                if (typeof WebglAddon !== 'undefined') {
                    try {
                        const webgl = new WebglAddon.WebglAddon();

                        // WebGL context loss のハンドリング
                        webgl.onContextLoss(() => {
                            log('[RENDERER] WebGL context lost!');
                            webgl.dispose();
                        });

                        terminalState.term.loadAddon(webgl);
                        log('[RENDERER] WebGL addon loaded successfully');

                        // アドオンを管理対象に追加
                        if (!terminalState.addons) {
                            terminalState.addons = [];
                        }
                        terminalState.addons.push(webgl);
                    } catch (error) {
                        log('[RENDERER] Failed to load WebGL addon:', error);
                        throw error;
                    }
                } else {
                    throw new Error('WebglAddon is not defined');
                }

                // ターミナル要素のサイズが確定するまで待機
                function waitForSize() {
                    return new Promise((resolve) => {
                        const checkSize = () => {
                            const rect = terminalElement.getBoundingClientRect();
                            if (rect.width > 0 && rect.height > 0) {

                                resolve();
                            } else {
                                setTimeout(checkSize, 10);
                            }
                        };
                        checkSize();
                    });
                }

                // サイズ確定後に初期設定
                waitForSize().then(() => {
                    // 初期サイズ設定
                    setTerminalSize();

                });

                // ターミナルサイズを動的に設定（元の手動計算方式）
                function setTerminalSize() {
                    const container = document.querySelector('.terminal-container');
                    const terminal = document.getElementById('terminal');

                    if (!container || !terminal) {
                        log('Terminal container not found');
                        return;
                    }

                    // コンテナの実際のサイズを取得
                    const terminalRect = terminal.getBoundingClientRect();
                    const availableWidth = terminalRect.width - 20; // パディング考慮
                    const availableHeight = terminalRect.height - 5;

                    // フォント情報から文字サイズを正確に計算
                    const fontSize = 13;
                    const targetLineHeight = 1.2; // Terminal設定と同じ行間

                    // 一時的な測定用エレメントを作成して文字幅を正確に測定
                    const measurer = document.createElement('div');
                    measurer.style.position = 'absolute';
                    measurer.style.visibility = 'hidden';
                    measurer.style.fontFamily = '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace';
                    measurer.style.fontSize = fontSize + 'px';
                    measurer.style.lineHeight = targetLineHeight; // 数値で指定
                    measurer.style.whiteSpace = 'pre';
                    measurer.textContent = 'M'.repeat(10); // 等幅フォントのM文字で測定

                    document.body.appendChild(measurer);
                    const rawCharWidth = measurer.getBoundingClientRect().width / 10;
                    const rawLineHeight = measurer.getBoundingClientRect().height;
                    document.body.removeChild(measurer);

                    // サイズ調整係数（微調整用）
                    // 大きくするほど表示サイズは小さくなる。はみ出したら大きくする。
                    const widthAdjustment = 0.88; // 横幅を少し詰める（右余白を減らす）
                    const heightAdjustment = 1.34; // 縦幅を少し詰める（はみ出し防止）

                    const adjustedCharWidth = rawCharWidth * widthAdjustment;
                    const adjustedLineHeight = rawLineHeight * heightAdjustment;

                    // 列数と行数を計算
                    const cols = Math.floor(availableWidth / adjustedCharWidth);
                    const rows = Math.floor(availableHeight / adjustedLineHeight);

                    // 最小サイズを保証
                    const finalCols = Math.max(cols, 20);
                    const finalRows = Math.max(rows, 5);

                    // ターミナルサイズを設定
                    if (terminalState.term && (terminalState.term.cols !== finalCols || terminalState.term.rows !== finalRows)) {
                        terminalState.term.resize(finalCols, finalRows);

                        // サイズ変更を VSCode に通知
                        vscode.postMessage({
                            type: 'resize',
                            cols: finalCols,
                            rows: finalRows
                        });


                    }
                }

                // ウィンドウリサイズ時の処理
                const windowResizeHandler = () => {
                    setTimeout(setTerminalSize, 50);
                };
                addManagedEventListener(window, 'resize', windowResizeHandler);

                // ResizeObserver でコンテナサイズ変更を監視
                let lastResizeTime = 0;
                let resizeCount = 0;

                // 既存の ResizeObserver があれば警告
                if (terminalState.resizeObserver) {
                    log('[LEAK CHECK] ResizeObserver already exists! This might be a duplicate.');
                }

                terminalState.resizeObserver = new ResizeObserver((entries) => {
                    const now = Date.now();
                    resizeCount++;

                    // デバウンス処理：連続する resize を制限
                    if (now - lastResizeTime < 100) {

                        return;
                    }

                    for (const entry of entries) {

                        lastResizeTime = now;

                        // 遅延を短縮してレスポンシブ性を向上
                        setTimeout(setTerminalSize, 30);
                    }
                });

                // terminal-container を監視
                const container = document.querySelector('.terminal-container');
                if (container) {
                    terminalState.resizeObserver.observe(container);
                }

                // 定期的なサイズチェック（VSCode の制約対応）
                setTimeout(() => {
                    setTerminalSize();
                }, 2000);

                let cliAgentState = { active: false, agent_type: null }; // CLI エージェントの状態

                // CLI エージェントインジケーターの表示更新
                function updateCliAgentIndicator() {
                    const indicator = document.getElementById('cli-agent-indicator');
                    if (indicator) {
                        if (cliAgentState.active) {
                            indicator.classList.add('active');
                            // エージェント種別に応じたラベル表示
                            if (cliAgentState.agent_type === 'claude') {
                                indicator.textContent = 'Claude';
                                indicator.title = 'Claude is active - Shift+Enter inputs a newline';
                            } else if (cliAgentState.agent_type === 'gemini') {
                                indicator.textContent = 'Gemini';
                                indicator.title = 'Gemini is active - Shift+Enter inputs a newline';
                            } else if (cliAgentState.agent_type === 'codex') {
                                indicator.textContent = 'Codex';
                                indicator.title = 'Codex is active - Shift+Enter sends Ctrl+J';
                            } else {
                                indicator.textContent = 'CLI Agent';
                                indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                            }
                        } else {
                            indicator.classList.remove('active');
                            indicator.textContent = 'CLI Agent';
                            indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                        }
                    }
                }

                // ステータスメッセージの処理
                function handleStatusMessage(data) {

                    try {
                        // CSI シーケンス ]777; で始まるメッセージを処理（実際のESC文字を検索）
                        if (data.includes('\x1b]777;')) {
                            // 複数のエスケープシーケンスに対応するため matchAll を使用
                            const matches = data.matchAll(/\x1b\]777;(.+?)\x07/g);
                            const matchesArray = [...matches];

                            for (const match of matchesArray) {
                                try {
                                    const messageJson = match[1];
                                    const message = JSON.parse(messageJson);

                                    if (message.type === 'cli_agent_status') {
                                        cliAgentState = message.data;
                                        updateCliAgentIndicator(); // インジケーター表示を更新
                                    }

                                    if (message.type === 'log') {
                                        // Python からのログメッセージを VSCode 側に転送
                                        vscode.postMessage({
                                            type: 'log',
                                            message: `[pty-shell.py] ${message.data}`
                                        });
                                    }
                                } catch (parseError) {
                                    // 個別メッセージのパースエラーは無視
                                    log('Individual message parse error:', parseError);
                                }
                            }
                        }
                    } catch (error) {
                        // JSON パースエラーは無視
                        log('Status message parse error:', error);
                    }
                }

                // Shift + Enter を Alt + Enter に変換するキーハンドラー
                try {
                    if (typeof terminalState.term.attachCustomKeyEventHandler === 'function') {


                        terminalState.term.attachCustomKeyEventHandler(function (event) {
                            // ESC キーの処理（vim など対応）
                            if (event.type === 'keydown' && event.key === 'Escape') {
                                // ブラウザのデフォルト動作を完全に停止
                                event.preventDefault();
                                event.stopPropagation();

                                // 正しいエスケープシーケンスを送信
                                vscode.postMessage({
                                    type: 'terminalInput',
                                    data: '\x1b'  // ESC文字（ASCII 27）を確実に送信
                                });

                                // false を返してデフォルト処理を完全に停止
                                return false;
                            }

                            // Shift + Enter の場合（CLI エージェントが動作中のときのみ）
                            if (event.type === 'keydown' &&
                                event.key === 'Enter' &&
                                event.shiftKey &&
                                !event.ctrlKey &&
                                !event.altKey &&
                                !event.metaKey) {

                                // CLI エージェント（Claude/Gemini）がアクティブの場合のみ Alt+Enter に変換
                                if (cliAgentState.active) {
                                    const agentType = cliAgentState.agent_type || 'CLI Agent';
                                    // ブラウザのデフォルト動作を完全に停止
                                    event.preventDefault();
                                    event.stopPropagation();

                                    if (agentType === 'codex') {
                                        // Codex モード: Ctrl+J をエミュレーション (LF)
                                        const ctrlJ = '\n';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            data: ctrlJ
                                        });
                                    } else {
                                        // 既存エージェント(Claude/Gemini): Alt+Enter を送信 (ESC + CR)
                                        const altEnterSequence = '\x1b\r';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            data: altEnterSequence
                                        });
                                    }

                                    // false を返してデフォルト処理を完全に停止
                                    return false;
                                } else {
                                    // CLI エージェントがアクティブでない場合は通常の Enter として処理

                                    return true;
                                }
                            }

                            // その他のキーはデフォルト処理を継続
                            return true;
                        });


                    } else {
                        log('attachCustomKeyEventHandler is not available');
                    }
                } catch (error) {
                    log('Failed to attach custom key handler:', error);
                }

                // onData のリスナーを保存して後で dispose できるようにする
                const dataListener = terminalState.term.onData((data) => {
                    vscode.postMessage({
                        type: 'terminalInput',
                        data: data
                    });
                });

                // dataListener を管理対象に追加（dispose 時にクリーンアップするため）
                if (!terminalState.xtermListeners) {
                    terminalState.xtermListeners = [];
                }
                terminalState.xtermListeners.push(dataListener);
                log('[LEAK CHECK] Added onData listener, total listeners: ' + terminalState.xtermListeners.length);

                // ペーストイベントハンドラー（DOM イベントを使用）
                const pasteHandler = (event) => {
                    // デフォルトのペースト処理を阻止
                    event.preventDefault();

                    // クリップボードからデータを取得
                    const clipboardData = event.clipboardData || window.clipboardData;
                    if (clipboardData && clipboardData.getData) {
                        const pastedText = clipboardData.getData('text');
                        if (pastedText) {
                            log('[PASTE] Intercepted paste event, length:', pastedText.length);
                            // 大量ペースト時はチャンク送信でフロー制御
                            sendBytesInChunks(new TextEncoder().encode(pastedText), { kind: 'paste' });
                        }
                    }
                };

                // ターミナル要素にペーストリスナーを追加
                addManagedEventListener(terminalElement, 'paste', pasteHandler);
                log('[LEAK CHECK] Added DOM paste listener');

                const messageHandler = (event) => {
                    const message = event.data;
                    switch (message.type) {
                        case 'output':
                            // ステータスメッセージをチェック
                            handleStatusMessage(message.data);

                            // アダプティブレンダリング: 画面消去検知と更新頻度追跡
                            const payload = message.data;
                            const hasScreenClear = hasScreenClearSequence(payload);

                            // 更新頻度を追跡（50ms以内の連続更新をカウント）
                            // 減少は -2 ずつ行い、急激な遅延切り替えを避ける
                            // 例: 高頻度(6回)→中頻度(4回)→低頻度(2回)→通常(0回) と段階的に復帰
                            const now = Date.now();
                            if (now - terminalState.lastWriteTime < 50) {
                                terminalState.recentWriteCount = Math.min(terminalState.recentWriteCount + 1, 10);
                            } else {
                                terminalState.recentWriteCount = Math.max(0, terminalState.recentWriteCount - 2);
                            }
                            terminalState.lastWriteTime = now;

                            // 動的に遅延を調整
                            if (hasScreenClear || terminalState.recentWriteCount > 5) {
                                terminalState.adaptiveDelayMs = 50;  // 20fps（TUI アプリ向け）
                            } else if (terminalState.recentWriteCount > 2) {
                                terminalState.adaptiveDelayMs = 33;  // 30fps
                            } else {
                                terminalState.adaptiveDelayMs = 16;  // 60fps（通常出力）
                            }

                            // バッチ処理: データをバッファに追加
                            terminalState.writeBufferData += payload;

                            // まだタイマーがセットされていない場合のみ
                            if (!terminalState.writeBufferPending && terminalState.term) {
                                terminalState.writeBufferPending = true;

                                // setTimeout で動的遅延を適用
                                terminalState.timers.writeBuffer = setTimeout(() => {
                                    if (terminalState.term && terminalState.writeBufferData) {
                                        terminalState.term.write(terminalState.writeBufferData);
                                        terminalState.writeBufferData = '';
                                    }
                                    terminalState.writeBufferPending = false;
                                    terminalState.timers.writeBuffer = null;
                                }, terminalState.adaptiveDelayMs);
                            }
                            break;
                        case 'clear':
                            if (terminalState.term) {
                                terminalState.term.clear();
                            }

                            break;
                        case 'reset':
                            // VSCode 側のリセット完了に合わせて、フロント側も完全再初期化
                            // これによりキーハンドラ、フォーカス、ResizeObserver、タイマーを健全な状態に戻す
                            resetTerminalResources();
                            setTimeout(() => {
                                initializeTerminal();
                            }, 10);
                            break;
                        case 'visibility_restored':
                            // WebView の可視状態が復元された時の処理
                            log('[LEAK CHECK] visibility_restored event received');
                            if (terminalState.term) {
                                // ターミナルが存在する場合は、サイズを再調整
                                setTimeout(() => {
                                    log('[LEAK CHECK] Calling setTerminalSize from visibility_restored');
                                    setTerminalSize();
                                    // フォーカスを復元
                                    terminalState.term.focus();

                                    // CLI Agent状態を強制的に再チェック要求
                                    vscode.postMessage({
                                        type: 'refreshCliAgentStatus',
                                        timestamp: Date.now()
                                    });
                                }, 50);
                            } else if (terminalState.isInitialized) {
                                // ターミナルが破棄されているが初期化済みの場合は、状態をリセット
                                log('Terminal was disposed unexpectedly, resetting state');
                                resetTerminalResources();
                                // ページを再読み込みして完全に復元
                                window.location.reload();
                            }
                            break;
                        case 'bufferCleanupCompleted':
                            log('[BUFFER CLEANUP] Received cleanup completion notification', {
                                success: message.success,
                                timestamp: message.timestamp,
                                error: message.error
                            });
                            if (!message.success) {
                                log('[BUFFER CLEANUP] Backend cleanup failed:', message.error);
                            }
                            break;
                        case 'sendTextToEditor':
                            // テキストを ACE エディタに入力
                            if (editorState.editor && message.text) {
                                editorState.editor.insert(message.text);
                                editorState.editor.focus();
                            }
                            break;
                        case 'extractToTodosResult':
                            // TODOS.md への書き出し結果を受け取り、エディタを更新
                            if (message.success && editorState.editor) {
                                const reference = `See [@${message.filePath}]`;
                                editorState.editor.setValue(reference, -1);
                                log('[EXTRACT] Editor content replaced with reference:', reference);
                            } else if (!message.success) {
                                log('[EXTRACT] Failed to write TODOS.md:', message.error);
                            }
                            break;
                    }
                };
                addManagedEventListener(window, 'message', messageHandler);

                // ボタンイベントの設定
                const sendSelectionHandler = () => {
                    vscode.postMessage({ type: 'buttonSendSelection' });
                    // ボタンクリック後にターミナルにフォーカスを移動
                    if (terminalState.term) {
                        terminalState.term.focus();
                    }
                };
                addManagedEventListener(document.getElementById('btn-send-selection'), 'click', sendSelectionHandler);

                // コピーボタンのイベント設定
                const copySelectionHandler = () => {
                    const button = document.getElementById('btn-copy-selection');

                    vscode.postMessage({ type: 'buttonCopySelection' });

                    // ボタンに .done クラスを追加してチェックマーク表示
                    button.classList.add('done');
                    setTimeout(() => {
                        button.classList.remove('done');
                    }, 2000);

                    // ボタンクリック後にターミナルにフォーカスを移動
                    if (terminalState.term) {
                        terminalState.term.focus();
                    }
                };
                addManagedEventListener(document.getElementById('btn-copy-selection'), 'click', copySelectionHandler);

                // スクロールボタンのイベント設定
                const scrollToBottomHandler = () => {
                    // ターミナルを一番下までスクロール
                    if (terminalState.term) {
                        terminalState.term.scrollToBottom();
                        terminalState.term.focus();
                    }
                };
                addManagedEventListener(document.getElementById('btn-scroll-to-bottom'), 'click', scrollToBottomHandler);

                // Extract ボタンのイベント設定
                const extractToTodosHandler = () => {
                    if (!editorState.editor) {
                        log('[EXTRACT] Editor not initialized');
                        return;
                    }
                    const content = editorState.editor.getValue();
                    if (!content.trim()) {
                        log('[EXTRACT] Editor content is empty');
                        return;
                    }
                    // 1行以下の場合は処理しない（二度押し防止）
                    if (content.split('\n').length <= 1) {
                        log('[EXTRACT] Editor content is single line, skipping');
                        return;
                    }
                    // VSCode 側に TODOS.md への書き出しを依頼
                    vscode.postMessage({
                        type: 'extractToTodos',
                        data: content
                    });
                };
                addManagedEventListener(document.getElementById('btn-extract-to-todos'), 'click', extractToTodosHandler);

                // History ボタンのイベント設定
                const openHistoryHandler = () => {
                    vscode.postMessage({
                        type: 'openPromptHistory'
                    });
                };
                addManagedEventListener(document.getElementById('btn-open-history'), 'click', openHistoryHandler);

                // 定期的なバッファクリア機能を設定
                setupPeriodicBufferCleanup();

                // 初期化完了フラグを設定
                terminalState.isInitialized = true;

                // 入力フォーカスを明示的に与える
                if (terminalState.term) {
                    terminalState.term.focus();
                }

                // VSCode 側に準備完了を通知（これをトリガにシェルを起動）
                vscode.postMessage({ type: 'terminalReady' });

            } catch (error) {
                log('Error initializing terminal:', error);
                vscode.postMessage({ type: 'error', error: error.message });
                document.getElementById('terminal').innerHTML = '<p style="color: red;">Error loading terminal: ' + error.message + '</p>';
            }
        }

        // ターミナル初期化を実行
        initializeTerminal();

        // ACE エディタ初期化を実行
        setTimeout(() => {
            log('[ACE] Attempting to initialize editor...');
            initializeAceEditor();
            // 初期化後の確認
            if (editorState.editor) {
                log('[ACE] Editor successfully initialized, testing keybindings...');
                const commands = editorState.editor.commands.byName;
                if (commands.sendToTerminal) {
                    log('[ACE] sendToTerminal command is registered');
                } else {
                    log('[ACE] sendToTerminal command NOT found!');
                }
            } else {
                log('[ACE] Editor initialization failed!');
            }
        }, 100);

    </script>
</body>

</html>