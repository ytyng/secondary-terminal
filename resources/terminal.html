<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; style-src {{CSP_SOURCE}} 'unsafe-inline'; script-src {{CSP_SOURCE}} 'unsafe-inline';">
    <title>Secondary Terminal</title>
    <link rel="stylesheet" href="{{XTERM_CSS_URI}}" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }

        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-editor-foreground);
            font-family: "RobotoMono Nerd Font Mono", "Roboto Mono", Consolas, "Courier New", monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-container {
            flex: 1;
            width: 100%;
            min-height: 0;
            /* ÈáçË¶ÅÔºöflexbox„ÅßÂ≠êË¶ÅÁ¥†„ÅåÁ∏Æ„ÇÄ„ÅÆ„ÇíË®±ÂèØ */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* ‚Üì TERMINAL_BG_COLOR „Åß‰∏äÊõ∏„Åç„Åï„Çå„Çã */
            background-color: var(--vscode-sideBar-background);
        }

        #terminal {
            flex: 1;
            width: 100%;
            padding: 0 0 0 5px;
            min-height: 0;
            /* ÈáçË¶ÅÔºöflexbox„ÅßÁ∏Æ„ÇÄ„ÅÆ„ÇíË®±ÂèØ */
            overflow: hidden;
            /* „ÅØ„ÅøÂá∫„ÅóÈò≤Ê≠¢ */
        }

        .terminal.xterm {
            padding: 0;

            /* xterm.js „ÅÆ„Ç≥„É≥„ÉÜ„Éä„ÇíÈÄèÊòé„Å´ */
            .xterm-viewport {
                background-color: transparent !important;
            }

            .xterm-screen {
                background-color: transparent !important;
            }

            .xterm-helper-textarea {
                background-color: transparent !important;
            }
        }

        /* „Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ */
        .control-panel {
            flex-shrink: 0;
            /* ÈáçË¶ÅÔºöÁ∏Æ„Åæ„Å™„ÅÑ„Çà„ÅÜ„Å´Âõ∫ÂÆö */
            background-color: var(--vscode-panel-background, #252526);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            padding: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: start;
            box-sizing: border-box;
        }

        .control-panel-left-controls {
            display: flex;
            align-items: center;
            justify-content: start;
            flex-grow: 1;
            gap: 0.5em;
        }

        .control-panel-right-controls {
            display: flex;
            align-items: center;
            justify-content: end;
            padding: 0.5em;
            gap: 0.5em;
        }

        .control-button {
            background-color: var(--vscode-button-secondaryBackground, #3c3c3c);
            color: var(--vscode-button-secondaryForeground, #cccccc);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: background-color 0.2s;

            &:hover {
                background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
            }
        }

        .copy-button {
            background-color: var(--vscode-button-secondaryBackground, #3c3c3c);
            color: var(--vscode-button-secondaryForeground, #cccccc);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: background-color 0.2s;
            position: relative;

            &:hover {
                background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
            }

            &.done {
                color: transparent;
            }

            &.done::after {
                content: '‚úì';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: var(--vscode-button-secondaryForeground, #cccccc);
            }
        }


        /* CLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„Ç¢„ÇØ„ÉÜ„Ç£„ÉñË°®Á§∫ */
        .cli-agent-indicator {
            color: #888;
            font-family: inherit;
            font-size: 12px;
            transition: opacity 0.3s ease;
            opacity: 0;

            &.active {
                opacity: 1;
            }
        }

        /* „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË®àÊ∏¨ HUD */
        .performance-hud {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.85);
            color: #00ff00;
            font-family: "RobotoMono Nerd Font Mono", "Roboto Mono", Consolas, "Courier New", monospace;
            font-size: 11px;
            padding: 10px 12px;
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            z-index: 10000;
            min-width: 220px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            display: none;

            &.visible {
                display: block;
            }
        }

        .performance-hud-title {
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
            color: #00ffff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .performance-hud-close {
            background: none;
            border: none;
            color: #ff6666;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            margin: 0;
            line-height: 1;
            transition: color 0.2s;

            &:hover {
                color: #ff3333;
            }
        }

        .performance-hud-item {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            line-height: 1.4;

            .label {
                color: #aaaaaa;
            }

            .value {
                color: #00ff00;
                font-weight: bold;
            }
        }

        .performance-hud-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.5);
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            z-index: 9999;
            transition: background-color 0.2s;

            &:hover {
                background-color: rgba(0, 255, 0, 0.3);
            }
        }

        /* ACE „Ç®„Éá„Ç£„Çø„Ç≥„É≥„ÉÜ„Éä */
        .editor-container {
            flex-shrink: 0;
            background-color: var(--vscode-editor-background);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            border-bottom: 1px solid var(--vscode-panel-border, #3c3c3c);
            height: 200px;
            overflow: hidden;
        }

        #ace-editor {
            width: 100%;
            height: 100%;
        }

        /* „Ç´„Çπ„Çø„É† ACE „ÉÜ„Éº„Éû - VSCode „ÉÄ„Éº„ÇØÈ¢® */
        .ace-vscode-dark {
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);

            .ace_gutter {
                background-color: var(--vscode-editorGutter-background);
                color: var(--vscode-editorLineNumber-foreground);
                border-right: 1px solid var(--vscode-panel-border, #3c3c3c);
            }

            .ace_print-margin {
                width: 1px;
                background: var(--vscode-editorRuler-foreground);
            }

            .ace_cursor {
                color: var(--vscode-editorCursor-foreground);
            }

            .ace_marker-layer {
                .ace_selection {
                    background: var(--vscode-editor-selectionBackground);
                }

                .ace_step {
                    background: var(--vscode-debugTokenExpression-number);
                }

                .ace_bracket {
                    margin: -1px 0 0 -1px;
                    border: 1px solid var(--vscode-editorBracketMatch-border);
                    background: var(--vscode-editorBracketMatch-background);
                }

                .ace_active-line {
                    background: var(--vscode-editor-lineHighlightBackground);
                }

                .ace_selected-word {
                    border: 1px solid var(--vscode-editor-selectionHighlightBorder);
                    background: var(--vscode-editor-selectionHighlightBackground);
                }
            }

            &.ace_multiselect .ace_selection.ace_start {
                box-shadow: 0 0 3px 0px var(--vscode-editor-background);
                border-radius: 2px;
            }

            .ace_gutter-active-line {
                background-color: var(--vscode-editor-lineHighlightBackground);
            }

            .ace_invisible {
                color: var(--vscode-editorWhitespace-foreground, #404040);
            }

            .ace_keyword,
            .ace_meta,
            .ace_storage,
            .ace_storage.ace_type,
            .ace_support.ace_type {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_keyword.ace_operator {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_constant.ace_character,
            .ace_constant.ace_language,
            .ace_constant.ace_numeric,
            .ace_keyword.ace_other.ace_unit,
            .ace_support.ace_constant,
            .ace_variable.ace_parameter {
                color: var(--vscode-debugTokenExpression-number);
            }

            .ace_constant.ace_other {
                color: var(--vscode-debugTokenExpression-number);
            }

            .ace_invalid {
                color: var(--vscode-editorError-foreground);
                background-color: var(--vscode-editorError-background);

                &.ace_deprecated {
                    color: var(--vscode-editorWarning-foreground);
                    background-color: var(--vscode-editorWarning-background);
                }
            }

            .ace_fold {
                background-color: var(--vscode-debugTokenExpression-name);
                border-color: var(--vscode-debugTokenExpression-name);
            }

            .ace_entity.ace_name.ace_function,
            .ace_support.ace_function,
            .ace_variable {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_support.ace_class,
            .ace_support.ace_type {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_heading,
            .ace_markup.ace_heading {
                color: var(--vscode-debugTokenExpression-name);
                font-weight: bold;
            }

            .ace_list,
            .ace_markup.ace_list {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_list.ace_markup {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_punctuation.ace_definition.ace_list_begin {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_entity.ace_name.ace_tag,
            .ace_entity.ace_other.ace_attribute-name,
            .ace_meta.ace_tag,
            .ace_string.ace_regexp,
            .ace_variable {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_comment {
                color: var(--vscode-debugConsole-infoForeground);
                font-style: italic;
            }

            .ace_string {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_entity.ace_other.ace_attribute-name {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_indent-guide {
                background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChAGGzJY5NwAAAABJRU5ErkJggg==") right repeat-y;
            }
        }
    </style>
</head>

<body>
    <!-- „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ HUD „Éà„Ç∞„É´„Éú„Çø„É≥ -->
    <button class="performance-hud-toggle" id="perf-hud-toggle" title="Toggle Performance HUD">üìä</button>

    <!-- „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ HUD -->
    <div class="performance-hud" id="perf-hud">
        <div class="performance-hud-title">
            <span>üìä Performance Metrics</span>
            <button class="performance-hud-close" id="perf-hud-close" title="Close Performance HUD">√ó</button>
        </div>
        <div class="performance-hud-item">
            <span class="label">Buffer:</span>
            <span class="value" id="hud-buffer-size">0 KB</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Scrollback:</span>
            <span class="value" id="hud-scrollback">0 lines</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Buffer Chars:</span>
            <span class="value" id="hud-buffer-chars">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">DOM Nodes:</span>
            <span class="value" id="hud-dom-nodes">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Child Procs:</span>
            <span class="value" id="hud-child-procs">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Write Avg:</span>
            <span class="value" id="hud-write-avg">0 ms</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Write Max:</span>
            <span class="value" id="hud-write-max">0 ms</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Output:</span>
            <span class="value" id="hud-output-count">0 msgs</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Total Chars (Á¥ØÁ©ç):</span>
            <span class="value" id="hud-total-chars">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Resize:</span>
            <span class="value" id="hud-resize-count">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Session:</span>
            <span class="value" id="hud-session-time">0s</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Event Listeners:</span>
            <span class="value" id="hud-event-listeners">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Xterm Listeners:</span>
            <span class="value" id="hud-xterm-listeners">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Addons:</span>
            <span class="value" id="hud-addons">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Active Timers:</span>
            <span class="value" id="hud-active-timers">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Long Tasks:</span>
            <span class="value" id="hud-long-tasks">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Long Task Max:</span>
            <span class="value" id="hud-long-task-max">0.00 ms</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Last Long Task:</span>
            <span class="value" id="hud-last-long-task">never</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Backend Processes:</span>
            <span class="value" id="hud-backend-processes">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Backend Sessions:</span>
            <span class="value" id="hud-backend-sessions">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">BG Color Time:</span>
            <span class="value" id="hud-bg-color-time">0.00 ms</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Canvas Size:</span>
            <span class="value" id="hud-canvas-size">0x0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Canvas Memory:</span>
            <span class="value" id="hud-canvas-memory">0 KB</span>
        </div>
    </div>

    <div class="terminal-container" id="terminal-container">

        <div id="terminal"></div>

        <!-- ACE „Ç®„Éá„Ç£„Çø„Éö„Ç§„É≥ -->
        <div class="editor-container">
            <div id="ace-editor"></div>
        </div>

        <!-- ‰∏ãÈÉ®„Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ -->
        <div class="control-panel">
            <div class="control-panel-left-controls">
                <button class="control-button" id="btn-send-selection"
                    title="Send editor selection to terminal (Cmd+L)">
                    @Selection
                </button>
                <button class="copy-button" id="btn-copy-selection" title="Copy editor selection context to clipboard">
                    Copy
                </button>
                <button class="control-button" id="btn-scroll-to-bottom" title="Scroll to bottom of terminal">
                    ‚Üì
                </button>
            </div>
            <div class="control-panel-right-controls">
                <!-- CLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº -->
                <div class="cli-agent-indicator" id="cli-agent-indicator"
                    title="CLI Agent is active - Shift+Enter inputs a newline">CLI Agent</div>
            </div>
        </div>
    </div>

    <script src="{{XTERM_JS_URI}}"></script>
    <script src="{{XTERM_UNICODE11_JS_URI}}"></script>
    <script src="{{XTERM_WEBGL_JS_URI}}"></script>

    <!-- ACE Editor Scripts -->
    <script src="{{ACE_JS_URI}}"></script>
    <script src="{{ACE_MODE_JAVASCRIPT_URI}}"></script>
    <script src="{{ACE_MODE_MARKDOWN_URI}}"></script>
    <script src="{{ACE_KEYBINDING_VSCODE_URI}}"></script>
    <script>
        const MAX_BUFFER_LINES = parseInt('{{SCROLLBACK_MAX}}'); // Ë®≠ÂÆö„Åï„Çå„ÅüÊúÄÂ§ßË°åÊï∞
        const vscode = acquireVsCodeApi();

        // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å®„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÁÆ°ÁêÜ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        const terminalState = {
            term: null,
            resizeObserver: null,
            timers: {
                sizeCheckInterval: null,
                backgroundColorInterval: null,
                writeBuffer: null
            },
            eventListeners: [],
            isInitialized: false,
            writeBufferData: '',
            writeBufferPending: false,
            currentContainerBackgroundColor: null,
        };

        // ACE „Ç®„Éá„Ç£„ÇøÁî®„ÅÆÁä∂ÊÖãÁÆ°ÁêÜ
        const editorState = {
            editor: null,
            isInitialized: false
        };

        // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË®àÊ∏¨Áî®„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        const performanceMetrics = {
            // „É°„É¢„É™Èñ¢ÈÄ£
            writeBufferSize: 0,
            scrollbackLines: 0,
            terminalBufferSize: 0,
            bufferCharCount: 0,      // xterm.js „Éê„ÉÉ„Éï„Ç°„ÅÆÁ∑èÊñáÂ≠óÊï∞
            domNodeCount: 0,         // DOM „Éé„Éº„ÉâÊï∞

            // „Éó„É≠„Çª„ÇπÈñ¢ÈÄ£
            childProcessCount: 0,    // Â≠ê„Éó„É≠„Çª„ÇπÊï∞

            // Âá¶ÁêÜÊôÇÈñìÈñ¢ÈÄ£
            lastWriteTime: 0,
            avgWriteTime: 0,
            maxWriteTime: 0,
            writeTimeSum: 0,
            writeTimeCount: 0,

            // „Ç´„Ç¶„É≥„Çø„Éº
            outputCount: 0,
            totalOutputChars: 0,
            resizeObserverCount: 0,

            // „Çø„Ç§„Éü„É≥„Ç∞
            sessionStartTime: Date.now(),
            lastUpdateTime: Date.now(),

            // „É™„Éº„ÇØÊ§úÂá∫Áî®„ÅÆËøΩÂä†„É°„Éà„É™„ÇØ„Çπ
            eventListenerCount: 0,
            xtermListenerCount: 0,
            addonCount: 0,
            activeTimerCount: 0,
            longTaskCount: 0,
            backendProcessCount: 0,
            backendSessionCount: 0,

            // Long Task Ë©≥Á¥∞„É°„Éà„É™„ÇØ„Çπ
            maxLongTaskDuration: 0,      // ÊúÄÂ§ß Long Task ÂÆüË°åÊôÇÈñì (ms)
            lastLongTaskTime: 0,         // ÊúÄÁµÇ Long Task Áô∫ÁîüÊôÇÂàª (Date.now())

            // applyBackgroundColor „É°„Éà„É™„ÇØ„Çπ
            bgColorTime: 0,              // applyBackgroundColor „ÅÆÂÆüË°åÊôÇÈñì (ms)
            canvasWidth: 0,              // Canvas „ÅÆÂπÖ (px)
            canvasHeight: 0,             // Canvas „ÅÆÈ´ò„Åï (px)
            canvasMemoryKB: 0            // Canvas „ÅÆ„É°„É¢„É™„Çµ„Ç§„Ç∫ (KB)
        };

        // HUD Êõ¥Êñ∞Èñ¢Êï∞
        function updatePerformanceHUD() {
            const hudStart = performance.now();
            try {
                // „Éê„ÉÉ„Éï„Ç°„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
                if (terminalState.term && terminalState.term.buffer) {
                    const buffer = terminalState.term.buffer.active;
                    if (buffer) {
                        performanceMetrics.scrollbackLines = buffer.length - (terminalState.term.rows || 24);
                        performanceMetrics.terminalBufferSize = buffer.length;

                        // xterm.js „Éê„ÉÉ„Éï„Ç°„ÅÆÁ∑èÊñáÂ≠óÊï∞„ÇíË®àÁÆó
                        performanceMetrics.bufferCharCount = buffer.length * (terminalState.term.cols || 80);
                    }
                }

                // DOM „Éé„Éº„ÉâÊï∞„ÇíÂèñÂæó
                const terminalElement = document.querySelector('#terminal');
                if (terminalElement) {
                    performanceMetrics.domNodeCount = terminalElement.querySelectorAll('*').length;
                }

                // „É™„Éº„ÇØÊ§úÂá∫„É°„Éà„É™„ÇØ„Çπ„ÇíË®àÊ∏¨
                performanceMetrics.eventListenerCount = terminalState.eventListeners ? terminalState.eventListeners.length : 0;
                performanceMetrics.xtermListenerCount = terminalState.xtermListeners ? terminalState.xtermListeners.length : 0;
                performanceMetrics.addonCount = terminalState.addons ? terminalState.addons.length : 0;

                // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Çø„Ç§„Éû„ÉºÊï∞„ÇíË®àÊ∏¨
                performanceMetrics.activeTimerCount = Object.values(terminalState.timers).filter(t => t !== null).length;

                // ÂêÑË¶ÅÁ¥†„ÇíÊõ¥Êñ∞
                document.getElementById('hud-buffer-size').textContent =
                    (performanceMetrics.writeBufferSize / 1024).toFixed(2) + ' KB';

                document.getElementById('hud-scrollback').textContent =
                    performanceMetrics.scrollbackLines + ' lines';

                document.getElementById('hud-buffer-chars').textContent =
                    (performanceMetrics.bufferCharCount / 1000).toFixed(1) + 'K';

                document.getElementById('hud-dom-nodes').textContent =
                    performanceMetrics.domNodeCount.toString();

                document.getElementById('hud-child-procs').textContent =
                    performanceMetrics.childProcessCount.toString();

                document.getElementById('hud-write-avg').textContent =
                    performanceMetrics.avgWriteTime.toFixed(2) + ' ms';

                document.getElementById('hud-write-max').textContent =
                    performanceMetrics.maxWriteTime.toFixed(2) + ' ms';

                document.getElementById('hud-output-count').textContent =
                    performanceMetrics.outputCount + ' msgs';

                document.getElementById('hud-total-chars').textContent =
                    (performanceMetrics.totalOutputChars / 1024).toFixed(1) + ' KB';

                document.getElementById('hud-resize-count').textContent =
                    performanceMetrics.resizeObserverCount.toString();

                // „Çª„ÉÉ„Ç∑„Éß„É≥ÊôÇÈñì„ÇíË®àÁÆó
                const sessionDuration = (Date.now() - performanceMetrics.sessionStartTime) / 1000;
                const minutes = Math.floor(sessionDuration / 60);
                const seconds = Math.floor(sessionDuration % 60);
                document.getElementById('hud-session-time').textContent =
                    minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;

                // „É™„Éº„ÇØÊ§úÂá∫„É°„Éà„É™„ÇØ„Çπ„ÇíË°®Á§∫
                document.getElementById('hud-event-listeners').textContent =
                    performanceMetrics.eventListenerCount.toString();

                document.getElementById('hud-xterm-listeners').textContent =
                    performanceMetrics.xtermListenerCount.toString();

                document.getElementById('hud-addons').textContent =
                    performanceMetrics.addonCount.toString();

                document.getElementById('hud-active-timers').textContent =
                    performanceMetrics.activeTimerCount.toString();

                document.getElementById('hud-long-tasks').textContent =
                    performanceMetrics.longTaskCount.toString();

                // Long Task Max „ÅÆË°®Á§∫
                document.getElementById('hud-long-task-max').textContent =
                    (performanceMetrics.maxLongTaskDuration || 0).toFixed(2) + ' ms';

                // Last Long Task „ÅÆË°®Á§∫ (ÁµåÈÅéÊôÇÈñì„Å®„Åó„Å¶Ë°®Á§∫)
                const lastLongTaskEl = document.getElementById('hud-last-long-task');
                if (performanceMetrics.lastLongTaskTime > 0) {
                    const elapsed = Math.floor((Date.now() - performanceMetrics.lastLongTaskTime) / 1000);
                    if (elapsed < 60) {
                        lastLongTaskEl.textContent = elapsed + 's ago';
                    } else if (elapsed < 3600) {
                        lastLongTaskEl.textContent = Math.floor(elapsed / 60) + 'm ' + (elapsed % 60) + 's ago';
                    } else {
                        lastLongTaskEl.textContent = Math.floor(elapsed / 3600) + 'h ' + Math.floor((elapsed % 3600) / 60) + 'm ago';
                    }
                } else {
                    lastLongTaskEl.textContent = 'never';
                }

                document.getElementById('hud-backend-processes').textContent =
                    performanceMetrics.backendProcessCount.toString();

                document.getElementById('hud-backend-sessions').textContent =
                    performanceMetrics.backendSessionCount.toString();

                // applyBackgroundColor „É°„Éà„É™„ÇØ„Çπ„ÇíË°®Á§∫
                document.getElementById('hud-bg-color-time').textContent =
                    (performanceMetrics.bgColorTime || 0).toFixed(2) + ' ms';

                document.getElementById('hud-canvas-size').textContent =
                    performanceMetrics.canvasWidth + 'x' + performanceMetrics.canvasHeight;

                document.getElementById('hud-canvas-memory').textContent =
                    (performanceMetrics.canvasMemoryKB || 0).toFixed(2) + ' KB';

                performanceMetrics.lastUpdateTime = Date.now();

                const hudEnd = performance.now();
                const hudExecutionTime = hudEnd - hudStart;

                // ÂÆüË°åÊôÇÈñì„Åå 50ms ‰ª•‰∏ä„ÅÆÂ†¥Âêà„ÅØË≠¶Âëä„É≠„Ç∞„ÇíÂá∫Âäõ
                if (hudExecutionTime >= 50) {
                    log('[PERF] ‚ö†Ô∏è updatePerformanceHUD() took ' + hudExecutionTime.toFixed(2) + 'ms', {
                        domNodeCount: performanceMetrics.domNodeCount,
                        bufferSize: performanceMetrics.terminalBufferSize
                    });
                }

            } catch (error) {
                log('[PERF HUD] Error updating HUD:', error);
            }
        }

        // HUD Ë°®Á§∫„Éà„Ç∞„É´Ê©üËÉΩ
        function setupPerformanceHUD() {
            const hudElement = document.getElementById('perf-hud');
            const toggleButton = document.getElementById('perf-hud-toggle');
            const closeButton = document.getElementById('perf-hud-close');

            // „Éà„Ç∞„É´„Éú„Çø„É≥„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
            toggleButton.addEventListener('click', () => {
                hudElement.classList.toggle('visible');

                // Ë°®Á§∫Áä∂ÊÖã„Çí localStorage „Å´‰øùÂ≠ò
                const isVisible = hudElement.classList.contains('visible');
                localStorage.setItem('performanceHUDVisible', isVisible ? 'true' : 'false');
            });

            // Èñâ„Åò„Çã„Éú„Çø„É≥„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
            closeButton.addEventListener('click', () => {
                hudElement.classList.remove('visible');

                // Ë°®Á§∫Áä∂ÊÖã„Çí localStorage „Å´‰øùÂ≠ò
                localStorage.setItem('performanceHUDVisible', 'false');
            });

            // ÂàùÊúüÁä∂ÊÖã„Çí localStorage „Åã„ÇâÂæ©ÂÖÉ
            const savedState = localStorage.getItem('performanceHUDVisible');
            if (savedState === 'true') {
                hudElement.classList.add('visible');
            }

            // 500ms „Åî„Å®„Å´ HUD „ÇíÊõ¥Êñ∞
            setInterval(updatePerformanceHUD, 500);

            // 5Áßí„Åî„Å®„Å´„Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„É°„Éà„É™„ÇØ„Çπ„Çí„É™„ÇØ„Ç®„Çπ„Éà
            setInterval(() => {
                vscode.postMessage({
                    type: 'requestBackendMetrics',
                    timestamp: Date.now()
                });
            }, 5000);

            // Long Task „ÅÆÊ§úÂá∫ (PerformanceObserver)
            try {
                if (typeof PerformanceObserver !== 'undefined') {
                    const observer = new PerformanceObserver((list) => {
                        for (const entry of list.getEntries()) {
                            // 50ms ‰ª•‰∏ä„Åã„Åã„Å£„Åü„Çø„Çπ„ÇØ„Çí„Ç´„Ç¶„É≥„Éà
                            if (entry.duration >= 50) {
                                performanceMetrics.longTaskCount++;

                                // Ë©≥Á¥∞„É≠„Ç∞„ÇíÂá∫Âäõ
                                const logDetails = {
                                    duration: entry.duration.toFixed(2) + 'ms',
                                    startTime: entry.startTime.toFixed(2) + 'ms',
                                    name: entry.name || 'unknown',
                                    entryType: entry.entryType,
                                    count: performanceMetrics.longTaskCount
                                };

                                // attribution ÊÉÖÂ†±„Åå„ÅÇ„Çå„Å∞ËøΩÂä†
                                if (entry.attribution && entry.attribution.length > 0) {
                                    logDetails.attribution = entry.attribution.map(attr => ({
                                        name: attr.name,
                                        entryType: attr.entryType,
                                        startTime: attr.startTime,
                                        duration: attr.duration,
                                        containerType: attr.containerType,
                                        containerSrc: attr.containerSrc,
                                        containerId: attr.containerId,
                                        containerName: attr.containerName
                                    }));
                                }

                                log('[PERF] ‚ö†Ô∏è Long Task Detected (#' + performanceMetrics.longTaskCount + '):', logDetails);
                                log('[PERF] Full entry object:', entry);

                                // ÊúÄÂ§ßÂÆüË°åÊôÇÈñì„Å®ÊúÄÁµÇÁô∫ÁîüÊôÇÂàª„ÇíÊõ¥Êñ∞
                                performanceMetrics.maxLongTaskDuration = Math.max(
                                    performanceMetrics.maxLongTaskDuration || 0,
                                    entry.duration
                                );
                                performanceMetrics.lastLongTaskTime = Date.now();
                            }
                        }
                    });
                    observer.observe({ entryTypes: ['longtask'] });
                    log('[PERF] PerformanceObserver for long tasks is active');
                } else {
                    log('[PERF] PerformanceObserver is not supported in this browser');
                }
            } catch (error) {
                log('[PERF] Failed to setup PerformanceObserver:', error);
            }
        }

        /**
         * „É≠„Ç∞„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°„Åô„Çã
         */
        function log(...args) {
            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');
            vscode.postMessage({
                type: 'log',
                message: `[terminal.html] ${message}`
            })
        }

        // ACE „Ç®„Éá„Ç£„ÇøÂàùÊúüÂåñÈñ¢Êï∞
        function initializeAceEditor() {
            try {
                if (editorState.isInitialized) {
                    log('[ACE] Editor is already initialized');
                    return;
                }

                if (typeof ace === 'undefined') {
                    throw new Error('ACE is not defined. ace-builds may not have loaded.');
                }

                log('[ACE] Starting editor initialization');

                // VSCode „ÉÄ„Éº„ÇØ„ÉÜ„Éº„Éû„Çí ACE „Å´ÁôªÈå≤
                if (ace.define) {
                    ace.define('ace/theme/vscode-dark', ['require', 'exports', 'module'], function(require, exports, module) {
                        exports.isDark = true;
                        exports.cssClass = "ace-vscode-dark";
                        exports.cssText = ""; // CSS „ÅØ HTML „ÅÆ„Çπ„Çø„Ç§„É´„ÅßÂÆöÁæ©Ê∏à„Åø
                    });
                }

                // „Ç®„Éá„Ç£„Çø„ÇíÂàùÊúüÂåñ
                editorState.editor = ace.edit("ace-editor");

                // Ë®≠ÂÆö„ÇíÈÅ©Áî®
                editorState.editor.setTheme("ace/theme/vscode-dark");
                editorState.editor.session.setMode("ace/mode/markdown");
                // VSCode „Ç≠„Éº„Éú„Éº„Éâ„Éè„É≥„Éâ„É©„Éº„Çí„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„ÉàÔºàÁ´∂Âêà„Åô„ÇãÂèØËÉΩÊÄßÔºâ
                // editorState.editor.setKeyboardHandler("ace/keyboard/vscode");

                // „Ç®„Éá„Ç£„Çø„Ç™„Éó„Ç∑„Éß„É≥
                editorState.editor.setOptions({
                    fontSize: 13,
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    showPrintMargin: false,
                    wrap: true,
                    showInvisibles: true,
                    enableBasicAutocompletion: true,
                    enableLiveAutocompletion: true,
                    enableSnippets: true
                });

                // ÂàùÊúüÂÄ§„ÇíË®≠ÂÆöÔºàÊ∞∏Á∂öÂåñ„Åï„Çå„ÅüÂÄ§„Åå„ÅÇ„Çå„Å∞Âæ©ÂÖÉÔºâ
                const savedContent = vscode.getState()?.editorContent || '';
                editorState.editor.setValue(savedContent, -1); // -1 „Åß„Ç´„Éº„ÇΩ„É´„ÇíÂÖàÈ†≠„Å´

                // Command+Enter „Ç≠„Éº„Éê„Ç§„É≥„Éâ„ÇíËøΩÂä†
                editorState.editor.commands.addCommand({
                    name: 'sendToTerminal',
                    bindKey: { win: 'Ctrl-Enter', mac: 'Cmd-Enter' },
                    exec: function(editor) {
                        log('[ACE] Command+Enter pressed');
                        const content = editor.getValue();
                        log('[ACE] Editor content:', content);

                        if (content.trim()) {
                            log('[ACE] Processing content for terminal...');

                            // 1. Êú´Â∞æ„ÅÆ„Éõ„ÉØ„Ç§„Éà„Çπ„Éö„Éº„ÇπÔºàÊîπË°åÂê´„ÇÄÔºâ„ÇíÈô§Âéª
                            const trimmedContent = content.trimEnd();
                            log('[ACE] Trimmed content:', trimmedContent);

                            // 2. „Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çí„Çø„Éº„Éü„Éä„É´„Å´ÈÄÅ‰ø°
                            log('[ACE] Sending content to terminal');
                            vscode.postMessage({
                                type: 'editorSendContent',
                                data: trimmedContent
                            });
                            log('[ACE] Content sent to terminal');

                            // 3. 200ms ÂæÖÊ©üÂæå„Å´ Enter „ÇíÈÄÅ‰ø°
                            setTimeout(() => {
                                log('[ACE] Sending Enter after 200ms');
                                vscode.postMessage({
                                    type: 'terminalInput',
                                    data: '\r'
                                });
                                log('[ACE] Enter sent to terminal');

                                // 4. „Ç®„Éá„Ç£„Çø„ÅÆÂÜÖÂÆπ„Çí„ÇØ„É™„Ç¢
                                editor.setValue('', -1);
                                log('[ACE] Editor content cleared');
                            }, 200);
                        } else {
                            log('[ACE] Editor content is empty, not sending');
                        }
                    }
                });

                // „Ç®„Éá„Ç£„Çø„ÅÆÂÜÖÂÆπ„ÅåÂ§âÊõ¥„Åï„Çå„ÅüÊôÇ„ÅÆÂá¶ÁêÜ
                editorState.editor.on('change', function() {
                    const content = editorState.editor.getValue();
                    // ÂÜÖÂÆπ„ÇíÊ∞∏Á∂öÂåñ
                    vscode.setState({
                        ...vscode.getState(),
                        editorContent: content
                    });
                });

                // DOM „É¨„Éô„É´„Åß„ÅÆ„Ç≠„Éº„Ç§„Éô„É≥„ÉàÂá¶ÁêÜ„ÇíËøΩÂä†ÔºàACE „ÅÆ„Ç≠„Éº„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞„Çà„ÇäÂÑ™ÂÖàÂ∫¶È´òÔºâ
                const aceContainer = document.getElementById('ace-editor');
                if (aceContainer) {
                    aceContainer.addEventListener('keydown', function(event) {
                        // Command+Enter (Mac) „Åæ„Åü„ÅØ Ctrl+Enter (Windows) „Çí„Ç≠„É£„ÉÉ„ÉÅ
                        if (event.key === 'Enter' && (event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey) {
                            log('[ACE DOM] Command+Enter detected');
                            event.preventDefault(); // „Éá„Éï„Ç©„É´„Éà„ÅÆÂãï‰Ωú„ÇíÈòªÊ≠¢
                            event.stopPropagation(); // „Ç§„Éô„É≥„Éà„ÅÆ‰ºùÊí≠„ÇíÂÅúÊ≠¢

                            const content = editorState.editor.getValue();
                            log('[ACE DOM] Editor content:', content);

                            if (content.trim()) {
                                log('[ACE DOM] Processing content for terminal...');

                                // 1. Êú´Â∞æ„ÅÆ„Éõ„ÉØ„Ç§„Éà„Çπ„Éö„Éº„ÇπÔºàÊîπË°åÂê´„ÇÄÔºâ„ÇíÈô§Âéª
                                const trimmedContent = content.trimEnd();
                                log('[ACE DOM] Trimmed content:', trimmedContent);

                                // 2. „Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çí„Çø„Éº„Éü„Éä„É´„Å´ÈÄÅ‰ø°
                                log('[ACE DOM] Sending content to terminal');
                                vscode.postMessage({
                                    type: 'editorSendContent',
                                    data: trimmedContent
                                });
                                log('[ACE DOM] Content sent to terminal');

                                // 3. 200ms ÂæÖÊ©üÂæå„Å´ Enter „ÇíÈÄÅ‰ø°
                                setTimeout(() => {
                                    log('[ACE DOM] Sending Enter after 200ms');
                                    vscode.postMessage({
                                        type: 'terminalInput',
                                        data: '\r'
                                    });
                                    log('[ACE DOM] Enter sent to terminal');

                                    // 4. „Ç®„Éá„Ç£„Çø„ÅÆÂÜÖÂÆπ„Çí„ÇØ„É™„Ç¢
                                    editorState.editor.setValue('', -1);
                                    log('[ACE DOM] Editor content cleared');
                                }, 200);
                            } else {
                                log('[ACE DOM] Editor content is empty, not sending');
                            }

                            return false; // „Ç§„Éô„É≥„ÉàÂá¶ÁêÜÁµÇ‰∫Ü
                        }
                    }, true); // useCapture = true „ÅßÊó©Êúü„Å´„Ç≠„É£„Éó„ÉÅ„É£
                    log('[ACE] DOM keydown listener added');
                }

                editorState.isInitialized = true;
                log('[ACE] Editor initialization completed');

            } catch (error) {
                log('[ACE] Error initializing editor:', error);
            }
        }

        // „É™„ÇΩ„Éº„ÇπÂÆåÂÖ®„É™„Çª„ÉÉ„ÉàÈñ¢Êï∞
        function resetTerminalResources() {
            log('[LEAK CHECK] Starting resource reset');

            // xterm „ÅÆ„É™„Çπ„Éä„Éº„ÇíÂÖà„Å´ dispose
            if (terminalState.xtermListeners && terminalState.xtermListeners.length > 0) {
                log('[LEAK CHECK] Disposing ' + terminalState.xtermListeners.length + ' xterm listeners');
                terminalState.xtermListeners.forEach(listener => {
                    try {
                        if (listener && listener.dispose) {
                            listener.dispose();
                        }
                    } catch (error) {
                        log('[LEAK CHECK] Error disposing xterm listener:', error);
                    }
                });
                terminalState.xtermListeners = [];
            }

            // „Ç¢„Éâ„Ç™„É≥„Çí dispose
            if (terminalState.addons && terminalState.addons.length > 0) {
                log('[LEAK CHECK] Disposing ' + terminalState.addons.length + ' addons');
                terminalState.addons.forEach(addon => {
                    try {
                        if (addon && addon.dispose) {
                            addon.dispose();
                        }
                    } catch (error) {
                        log('[LEAK CHECK] Error disposing addon:', error);
                    }
                });
                terminalState.addons = [];
            }

            // Êó¢Â≠ò„ÅÆ„Çø„Éº„Éü„Éä„É´„ÇíÁ†¥Ê£Ñ
            if (terminalState.term) {
                try {
                    log('[LEAK CHECK] Disposing terminal instance');
                    terminalState.term.dispose();
                } catch (error) {
                    log('Error disposing terminal:', error);
                }
                terminalState.term = null;
            }

            // ResizeObserver „ÇíÂÅúÊ≠¢
            if (terminalState.resizeObserver) {
                try {
                    terminalState.resizeObserver.disconnect();
                } catch (error) {
                    log('Error disconnecting ResizeObserver:', error);
                }
                terminalState.resizeObserver = null;
            }

            // „Åô„Åπ„Å¶„ÅÆ„Çø„Ç§„Éû„Éº„Çí„ÇØ„É™„Ç¢
            Object.keys(terminalState.timers).forEach(timerKey => {
                if (terminalState.timers[timerKey]) {
                    try {
                        clearTimeout(terminalState.timers[timerKey]);
                        clearInterval(terminalState.timers[timerKey]);
                    } catch (error) {
                        log(`Error clearing timer ${timerKey}:`, error);
                    }
                    terminalState.timers[timerKey] = null;
                }
            });

            // „Éê„ÉÉ„Éï„Ç°„ÇÇ„ÇØ„É™„Ç¢
            terminalState.writeBufferData = '';
            terminalState.writeBufferPending = false;

            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„Çí„Åô„Åπ„Å¶ÂâäÈô§
            terminalState.eventListeners.forEach(({ element, event, handler }) => {
                try {
                    element.removeEventListener(event, handler);
                } catch (error) {
                    log('Error removing event listener:', error);
                }
            });
            terminalState.eventListeners = [];

            // ÂàùÊúüÂåñ„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„Éà
            terminalState.isInitialized = false;
        }

        // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÁôªÈå≤„Éò„É´„Éë„ÉºÔºàÁÆ°ÁêÜÂØæË±°„Å´ËøΩÂä†Ôºâ
        function addManagedEventListener(element, event, handler) {
            element.addEventListener(event, handler);
            terminalState.eventListeners.push({ element, event, handler });
        }

        // Â§ßÈáè„Éö„Éº„Çπ„Éà„ÅÆ„ÉÅ„É£„É≥„ÇØÈÄÅ‰ø°Ê©üËÉΩ
        function sendBytesInChunks(bytes, meta) {
            const CHUNK_SIZE = 32 * 1024; // 32KB „ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫
            const id = Math.random().toString(36).slice(2); // „É©„É≥„ÉÄ„É† ID
            let offset = 0;

            // ACK ÂæÖ„Å°Áî®„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            const onAck = (event) => {
                const message = event.data;
                if (!message || message.type !== 'terminalInputAck' || message.id !== id) {
                    return;
                }

                if (message.done) {
                    // ÈÄÅ‰ø°ÂÆå‰∫Ü
                    window.removeEventListener('message', onAck);
                    log('[PASTE CHUNKS] All chunks sent successfully');
                    return;
                }

                // Ê¨°„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíÈÄÅ‰ø°
                sendNextChunk();
            };

            window.addEventListener('message', onAck);

            // ÈÄÅ‰ø°ÈñãÂßãÈÄöÁü•
            log('[PASTE CHUNKS] Starting chunked paste, total bytes:', bytes.length);
            vscode.postMessage({
                type: 'terminalInputBegin',
                id: id,
                totalBytes: bytes.length,
                ...meta
            });

            function sendNextChunk() {
                if (offset >= bytes.length) {
                    // ÈÄÅ‰ø°ÁµÇ‰∫ÜÈÄöÁü•
                    vscode.postMessage({ type: 'terminalInputEnd', id: id });
                    return;
                }

                const chunkEnd = Math.min(offset + CHUNK_SIZE, bytes.length);
                const slice = bytes.subarray(offset, chunkEnd);

                // base64 „Ç®„É≥„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„ÅßÂÆâÂÖ®„Å´Ëª¢ÈÄÅ
                const b64 = btoa(String.fromCharCode.apply(null, slice));

                log('[PASTE CHUNKS] Sending chunk', offset, 'to', chunkEnd, 'of', bytes.length);
                vscode.postMessage({
                    type: 'terminalInputChunk',
                    id: id,
                    b64: b64,
                    offset: offset,
                    size: slice.length
                });

                offset = chunkEnd;
            }

            // ÊúÄÂàù„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíÈÄÅ‰ø°
            sendNextChunk();
        }

        // ÂÆöÊúüÁöÑ„Å™„Éê„ÉÉ„Éï„Ç°„ÇØ„É™„Ç¢Ê©üËÉΩ
        function setupPeriodicBufferCleanup() {
            // Ë®≠ÂÆöÂèØËÉΩ„Å™ÂÄ§
            const BUFFER_CHECK_INTERVAL = 30000; // 30ÁßíÈñìÈöî„Åß„ÉÅ„Çß„ÉÉ„ÇØ
            const CLEANUP_THRESHOLD = Math.floor(MAX_BUFFER_LINES * 0.8); // 80%„ÅßË≠¶Âëä
            const CLEANUP_TARGET = Math.floor(MAX_BUFFER_LINES * 0.6); // 60%„Åæ„ÅßÂâäÊ∏õ

            log('[BUFFER CLEANUP] Setting up periodic buffer cleanup', {
                checkInterval: BUFFER_CHECK_INTERVAL,
                maxLines: MAX_BUFFER_LINES,
                cleanupThreshold: CLEANUP_THRESHOLD,
                cleanupTarget: CLEANUP_TARGET
            });

            const bufferCleanupTimer = setInterval(() => {
                if (!terminalState.term) {
                    return;
                }

                try {
                    const buffer = terminalState.term.buffer;
                    if (!buffer || !buffer.active) {
                        return;
                    }

                    const totalLines = buffer.active.length;
                    const scrollbackLines = totalLines - terminalState.term.rows;

                    log('[BUFFER CLEANUP] Buffer check', {
                        totalLines,
                        scrollbackLines,
                        threshold: CLEANUP_THRESHOLD,
                        terminalRows: terminalState.term.rows
                    });

                    // „Çπ„ÇØ„É≠„Éº„É´„Éê„ÉÉ„ÇØË°åÊï∞„ÅåÈñæÂÄ§„ÇíË∂Ö„Åà„ÅüÂ†¥Âêà„ÄÅ„ÇØ„É™„Ç¢„ÇíÂÆüË°å
                    if (scrollbackLines > CLEANUP_THRESHOLD) {
                        log('[BUFFER CLEANUP] Buffer cleanup triggered', {
                            currentLines: scrollbackLines,
                            targetLines: CLEANUP_TARGET
                        });

                        // ÁèæÂú®„ÅÆ„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„Çí‰øùÂ≠ò
                        const currentScrollY = terminalState.term.buffer.active.viewportY;
                        const isAtBottom = currentScrollY >= (totalLines - terminalState.term.rows);

                        log('[BUFFER CLEANUP] Current scroll position', {
                            currentScrollY,
                            totalLines,
                            terminalRows: terminalState.term.rows,
                            isAtBottom
                        });

                        // Â∞ë„ÅóÂæÖ„Å£„Å¶„Åã„Çâ„ÇØ„É™„Ç¢„ÇíÂÆüË°å
                        setTimeout(() => {
                            try {
                                // VSCode ÂÅ¥„Å´„Éê„ÉÉ„Éï„Ç°„ÇØ„É™„Ç¢Ë¶ÅÊ±Ç„ÇíÈÄÅ‰ø°
                                vscode.postMessage({
                                    type: 'bufferCleanupRequest',
                                    currentLines: scrollbackLines,
                                    threshold: CLEANUP_THRESHOLD,
                                    preserveScrollPosition: !isAtBottom // ÊúÄ‰∏ãÈÉ®„Å´„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„Çí‰øùÊåÅ
                                });

                                // ÊúÄ‰∏ãÈÉ®„Å´„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„ÇíÂ§âÊõ¥„Åó„Å™„ÅÑ
                                // ÊúÄ‰∏ãÈÉ®„Å´„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„Åæ„Åü„ÅØÂïèÈ°å„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„Åø scrollToBottom() „ÇíÂÆüË°å
                                if (isAtBottom) {
                                    log('[BUFFER CLEANUP] User was at bottom, scrolling to bottom');
                                    terminalState.term.scrollToBottom();
                                } else {
                                    log('[BUFFER CLEANUP] User was not at bottom, preserving scroll position');
                                }

                                log('[BUFFER CLEANUP] Buffer cleanup completed');

                            } catch (error) {
                                log('[BUFFER CLEANUP] Error during buffer cleanup:', error);
                                // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂº∑Âà∂ÁöÑ„Å´„Çπ„ÇØ„É≠„Éº„É´
                                terminalState.term.scrollToBottom();
                            }
                        }, 100);
                    }
                } catch (error) {
                    log('[BUFFER CLEANUP] Error checking buffer:', error);
                }
            }, BUFFER_CHECK_INTERVAL);

            // „Çø„Ç§„Éû„Éº„ÇíÁÆ°ÁêÜÂØæË±°„Å´ËøΩÂä†
            terminalState.timers.bufferCleanup = bufferCleanupTimer;
            log('[BUFFER CLEANUP] Periodic buffer cleanup timer set');
        }

        // „Çø„Éº„Éü„Éä„É´ÂàùÊúüÂåñÈñ¢Êï∞
        function initializeTerminal() {
            try {
                // ÈáçË§áÂàùÊúüÂåñ„ÇíÂé≥ÂØÜ„Å´„ÉÅ„Çß„ÉÉ„ÇØ
                if (terminalState.isInitialized) {
                    log('[INIT] Terminal is already initialized, skipping duplicate initialization');

                    // Êó¢„Å´ÂàùÊúüÂåñÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Çµ„Ç§„Ç∫Ë™øÊï¥„Å®„Éï„Ç©„Éº„Ç´„Çπ„ÅÆ„ÅøÂÆüË°å
                    if (terminalState.term) {
                        setTimeout(() => {
                            setTerminalSize();
                            terminalState.term.focus();
                        }, 50);
                    }
                    return;
                }

                // CSSÂ§âÊï∞„Çí„Éá„Éê„ÉÉ„Ç∞
                log(`[INIT] CSS Variables: vscode-sideBar-background:${document.documentElement.style.getPropertyValue('--vscode-sideBar-background')}, vscode-terminal-foreground:${document.documentElement.style.getPropertyValue('--vscode-terminal-foreground')}, vscode-terminal-cursor-foreground:${document.documentElement.style.getPropertyValue('--vscode-terminal-cursor-foreground')}, vscode-terminal-selection-background:${document.documentElement.style.getPropertyValue('--vscode-terminal-selection-background')}`);

                // ‰∫åÈáçÂàùÊúüÂåñ„ÇíÈò≤„Åê„Åü„ÇÅ„ÄÅÊúÄÂàù„Å´„Éï„É©„Ç∞„ÇíÁ´ã„Å¶„Çã
                terminalState.isInitialized = true;

                log('[INIT] Starting terminal initialization');


                if (typeof Terminal === 'undefined') {
                    throw new Error('Terminal is not defined. xterm.js may not have loaded.');
                }

                terminalState.term = new Terminal({
                    theme: {
                        // ‚Üì „Çø„Éº„Éü„Éä„É´ÂÜÖ„Åß TERMINAL_BG_COLOR „Åß‰∏äÊõ∏„Åç„Åï„Çå„Çã
                        background: 'var(--vscode-sideBar-background)',
                        foreground: 'var(--vscode-terminal-foreground)',
                        cursor: 'var(--vscode-terminal-cursor-foreground)',
                        selection: 'var(--vscode-terminal-selection-background)'
                    },
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    fontSize: 13,
                    letterSpacing: 0,
                    lineHeight: 1.2,
                    cursorBlink: false,
                    smoothScrollDuration: 0,  // „Çπ„É†„Éº„Ç∫„Çπ„ÇØ„É≠„Éº„É´„ÇíÁÑ°ÂäπÂåñÔºà„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂêë‰∏äÔºâ
                    convertEol: true,
                    allowProposedApi: true,
                    allowTransparency: false,
                    minimumContrastRatio: 1,
                    // „Éö„Éº„Çπ„Éà„Çí„Ç¢„Éó„É™„Å´„Äå„Åæ„Å®„Åæ„Çä„Äç„Å®„Åó„Å¶‰ºù„Åà„Çã
                    bracketedPasteMode: true,
                    // „Çπ„ÇØ„É≠„Éº„É´„Éê„ÉÉ„ÇØ‰∏äÈôê„ÇíË®≠ÂÆöÔºàÂ§ß„Åç„Å™Â±•Ê≠¥„Åß„ÅÆ write/render Ë≤†Ëç∑„ÇíËªΩÊ∏õÔºâ
                    scrollback: MAX_BUFFER_LINES
                });

                const terminalElement = document.getElementById('terminal');
                terminalState.term.open(terminalElement);

                // Unicode 11 „Ç¢„Éâ„Ç™„É≥„Çí„É≠„Éº„Éâ
                if (typeof Unicode11Addon !== 'undefined') {
                    try {
                        const unicode11 = new Unicode11Addon.Unicode11Addon();
                        terminalState.term.loadAddon(unicode11);
                        unicode11.activate(terminalState.term);
                        log('[LEAK CHECK] Unicode11 addon loaded');

                        // „Ç¢„Éâ„Ç™„É≥„ÇíÁÆ°ÁêÜÂØæË±°„Å´ËøΩÂä†
                        if (!terminalState.addons) {
                            terminalState.addons = [];
                        }
                        terminalState.addons.push(unicode11);
                    } catch (error) {
                        log('Failed to load Unicode 11 addon:', error);
                    }
                }

                // WebGL „Ç¢„Éâ„Ç™„É≥„Çí„É≠„Éº„Éâ
                if (typeof WebglAddon !== 'undefined') {
                    try {
                        const webgl = new WebglAddon.WebglAddon();

                        // WebGL context loss „ÅÆ„Éè„É≥„Éâ„É™„É≥„Ç∞
                        webgl.onContextLoss(() => {
                            log('[RENDERER] WebGL context lost!');
                            webgl.dispose();
                        });

                        terminalState.term.loadAddon(webgl);
                        log('[RENDERER] WebGL addon loaded successfully');

                        // „Ç¢„Éâ„Ç™„É≥„ÇíÁÆ°ÁêÜÂØæË±°„Å´ËøΩÂä†
                        if (!terminalState.addons) {
                            terminalState.addons = [];
                        }
                        terminalState.addons.push(webgl);
                    } catch (error) {
                        log('[RENDERER] Failed to load WebGL addon:', error);
                        throw error;
                    }
                } else {
                    throw new Error('WebglAddon is not defined');
                }

                // „Çø„Éº„Éü„Éä„É´Ë¶ÅÁ¥†„ÅÆ„Çµ„Ç§„Ç∫„ÅåÁ¢∫ÂÆö„Åô„Çã„Åæ„ÅßÂæÖÊ©ü
                function waitForSize() {
                    return new Promise((resolve) => {
                        const checkSize = () => {
                            const rect = terminalElement.getBoundingClientRect();
                            if (rect.width > 0 && rect.height > 0) {

                                resolve();
                            } else {
                                setTimeout(checkSize, 10);
                            }
                        };
                        checkSize();
                    });
                }

                // „Çµ„Ç§„Ç∫Á¢∫ÂÆöÂæå„Å´ÂàùÊúüË®≠ÂÆö
                waitForSize().then(() => {
                    // ÂàùÊúü„Çµ„Ç§„Ç∫Ë®≠ÂÆö
                    setTerminalSize();

                });

                // „Çø„Éº„Éü„Éä„É´„Çµ„Ç§„Ç∫„ÇíÂãïÁöÑ„Å´Ë®≠ÂÆöÔºàÂÖÉ„ÅÆÊâãÂãïË®àÁÆóÊñπÂºèÔºâ
                function setTerminalSize() {
                    const sizeStart = performance.now();

                    const container = document.querySelector('.terminal-container');
                    const terminal = document.getElementById('terminal');

                    if (!container || !terminal) {
                        log('Terminal container not found');
                        return;
                    }

                    // „Ç≥„É≥„ÉÜ„Éä„ÅÆÂÆüÈöõ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
                    const terminalRect = terminal.getBoundingClientRect();
                    const availableWidth = terminalRect.width - 20; // „Éë„Éá„Ç£„É≥„Ç∞ËÄÉÊÖÆ
                    // const availableHeight = Math.max(terminalRect.height - 20, 200); // „Éë„Éá„Ç£„É≥„Ç∞ËÄÉÊÖÆ
                    const availableHeight = terminalRect.height - 5;

                    // „Éï„Ç©„É≥„ÉàÊÉÖÂ†±„Åã„ÇâÊñáÂ≠ó„Çµ„Ç§„Ç∫„ÇíÊ≠£Á¢∫„Å´Ë®àÁÆó
                    const fontSize = 13;
                    const targetLineHeight = 1.2; // TerminalË®≠ÂÆö„Å®Âêå„ÅòË°åÈñì

                    // ‰∏ÄÊôÇÁöÑ„Å™Ê∏¨ÂÆöÁî®„Ç®„É¨„É°„É≥„Éà„Çí‰ΩúÊàê„Åó„Å¶ÊñáÂ≠óÂπÖ„ÇíÊ≠£Á¢∫„Å´Ê∏¨ÂÆö
                    const measurer = document.createElement('div');
                    measurer.style.position = 'absolute';
                    measurer.style.visibility = 'hidden';
                    measurer.style.fontFamily = '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace';
                    measurer.style.fontSize = fontSize + 'px';
                    measurer.style.lineHeight = targetLineHeight; // Êï∞ÂÄ§„ÅßÊåáÂÆö
                    measurer.style.whiteSpace = 'pre';
                    measurer.textContent = 'M'.repeat(10); // Á≠âÂπÖ„Éï„Ç©„É≥„Éà„ÅÆMÊñáÂ≠ó„ÅßÊ∏¨ÂÆö

                    document.body.appendChild(measurer);
                    const rawCharWidth = measurer.getBoundingClientRect().width / 10;
                    const rawLineHeight = measurer.getBoundingClientRect().height;
                    document.body.removeChild(measurer);

                    // „Çµ„Ç§„Ç∫Ë™øÊï¥‰øÇÊï∞ÔºàÂæÆË™øÊï¥Áî®Ôºâ
                    // Â§ß„Åç„Åè„Åô„Çã„Åª„Å©Ë°®Á§∫„Çµ„Ç§„Ç∫„ÅØÂ∞è„Åï„Åè„Å™„Çã„ÄÇ„ÅØ„ÅøÂá∫„Åó„Åü„ÇâÂ§ß„Åç„Åè„Åô„Çã„ÄÇ
                    const widthAdjustment = 0.88; // Ê®™ÂπÖ„ÇíÂ∞ë„ÅóË©∞„ÇÅ„ÇãÔºàÂè≥‰ΩôÁôΩ„ÇíÊ∏õ„Çâ„ÅôÔºâ
                    //const widthAdjustment = 1.0; // Ê®™ÂπÖ„ÇíÂ∞ë„ÅóË©∞„ÇÅ„ÇãÔºàÂè≥‰ΩôÁôΩ„ÇíÊ∏õ„Çâ„ÅôÔºâ
                    const heightAdjustment = 1.34; // Á∏¶ÂπÖ„ÇíÂ∞ë„ÅóË©∞„ÇÅ„ÇãÔºà„ÅØ„ÅøÂá∫„ÅóÈò≤Ê≠¢Ôºâ

                    const adjustedCharWidth = rawCharWidth * widthAdjustment;
                    const adjustedLineHeight = rawLineHeight * heightAdjustment;

                    // ÂàóÊï∞„Å®Ë°åÊï∞„ÇíË®àÁÆó
                    const cols = Math.floor(availableWidth / adjustedCharWidth);
                    const rows = Math.floor(availableHeight / adjustedLineHeight);

                    // ÊúÄÂ∞è„Çµ„Ç§„Ç∫„Çí‰øùË®º
                    const finalCols = Math.max(cols, 20);
                    const finalRows = Math.max(rows, 5);

                    // „Çø„Éº„Éü„Éä„É´„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö
                    if (terminalState.term && (terminalState.term.cols !== finalCols || terminalState.term.rows !== finalRows)) {
                        terminalState.term.resize(finalCols, finalRows);

                        // „Çµ„Ç§„Ç∫Â§âÊõ¥„Çí VSCode „Å´ÈÄöÁü•
                        vscode.postMessage({
                            type: 'resize',
                            cols: finalCols,
                            rows: finalRows
                        });


                    }

                    const sizeEnd = performance.now();
                    const sizeExecutionTime = sizeEnd - sizeStart;

                    // ÂÆüË°åÊôÇÈñì„Åå 50ms ‰ª•‰∏ä„ÅÆÂ†¥Âêà„ÅØË≠¶Âëä„É≠„Ç∞„ÇíÂá∫Âäõ
                    if (sizeExecutionTime >= 50) {
                        log('[PERF] ‚ö†Ô∏è setTerminalSize() took ' + sizeExecutionTime.toFixed(2) + 'ms', {
                            cols: finalCols,
                            rows: finalRows,
                            availableWidth: availableWidth,
                            availableHeight: availableHeight,
                            charWidth: adjustedCharWidth.toFixed(2),
                            lineHeight: adjustedLineHeight.toFixed(2)
                        });
                    }
                }

                // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÊôÇ„ÅÆÂá¶ÁêÜ
                const windowResizeHandler = () => {
                    setTimeout(setTerminalSize, 50);
                };
                addManagedEventListener(window, 'resize', windowResizeHandler);

                // ResizeObserver „Åß„Ç≥„É≥„ÉÜ„Éä„Çµ„Ç§„Ç∫Â§âÊõ¥„ÇíÁõ£Ë¶ñ
                let lastResizeTime = 0;
                let resizeCount = 0;

                // Êó¢Â≠ò„ÅÆ ResizeObserver „Åå„ÅÇ„Çå„Å∞Ë≠¶Âëä
                if (terminalState.resizeObserver) {
                    log('[LEAK CHECK] ResizeObserver already exists! This might be a duplicate.');
                }

                terminalState.resizeObserver = new ResizeObserver((entries) => {
                    const now = Date.now();
                    resizeCount++;

                    // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË®àÊ∏¨„ÇíÊõ¥Êñ∞
                    performanceMetrics.resizeObserverCount++;

                    // „Éá„Éê„Ç¶„É≥„ÇπÂá¶ÁêÜÔºöÈÄ£Á∂ö„Åô„Çã resize „ÇíÂà∂Èôê
                    if (now - lastResizeTime < 100) {

                        return;
                    }

                    for (const entry of entries) {

                        lastResizeTime = now;

                        // ÈÅÖÂª∂„ÇíÁü≠Á∏Æ„Åó„Å¶„É¨„Çπ„Éù„É≥„Ç∑„ÉñÊÄß„ÇíÂêë‰∏ä
                        setTimeout(setTerminalSize, 30);
                    }
                });

                // terminal-container „ÇíÁõ£Ë¶ñ
                const container = document.querySelector('.terminal-container');
                if (container) {
                    terminalState.resizeObserver.observe(container);
                }

                // ÂÆöÊúüÁöÑ„Å™„Çµ„Ç§„Ç∫„ÉÅ„Çß„ÉÉ„ÇØÔºàVSCode „ÅÆÂà∂Á¥ÑÂØæÂøúÔºâ
                let lastSizeCheck = Date.now();
                // „É™„Éº„ÇØÊ§úË®º„ÅÆ„Åü„ÇÅ‰∏ÄÊó¶ÁÑ°ÂäπÂåñ
                // terminalState.timers.sizeCheckInterval = setInterval(() => {
                //     const now = Date.now();
                //     lastSizeCheck = now;
                //     setTerminalSize();
                // }, 2000);
                setTimeout(() => {
                    setTerminalSize();
                }, 2000);

                let cliAgentState = { active: false, agent_type: null }; // CLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆÁä∂ÊÖã

                // CLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº„ÅÆË°®Á§∫Êõ¥Êñ∞
                function updateCliAgentIndicator() {
                    const indicator = document.getElementById('cli-agent-indicator');
                    if (indicator) {
                        if (cliAgentState.active) {
                            indicator.classList.add('active');
                            // „Ç®„Éº„Ç∏„Çß„É≥„ÉàÁ®ÆÂà•„Å´Âøú„Åò„Åü„É©„Éô„É´Ë°®Á§∫
                            if (cliAgentState.agent_type === 'claude') {
                                indicator.textContent = 'Claude';
                                indicator.title = 'Claude is active - Shift+Enter inputs a newline';
                            } else if (cliAgentState.agent_type === 'gemini') {
                                indicator.textContent = 'Gemini';
                                indicator.title = 'Gemini is active - Shift+Enter inputs a newline';
                            } else if (cliAgentState.agent_type === 'codex') {
                                indicator.textContent = 'Codex';
                                indicator.title = 'Codex is active - Shift+Enter sends Ctrl+J';
                            } else {
                                indicator.textContent = 'CLI Agent';
                                indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                            }
                        } else {
                            indicator.classList.remove('active');
                            indicator.textContent = 'CLI Agent';
                            indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                        }
                    }
                }

                // „Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂá¶ÁêÜ
                function handleStatusMessage(data) {

                    try {
                        // CSI „Ç∑„Éº„Ç±„É≥„Çπ ]777; „ÅßÂßã„Åæ„Çã„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂá¶ÁêÜÔºàÂÆüÈöõ„ÅÆESCÊñáÂ≠ó„ÇíÊ§úÁ¥¢Ôºâ
                        if (data.includes('\x1b]777;')) {
                            // Ë§áÊï∞„ÅÆ„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„Å´ÂØæÂøú„Åô„Çã„Åü„ÇÅ matchAll „Çí‰ΩøÁî®
                            const matches = data.matchAll(/\x1b\]777;(.+?)\x07/g);
                            const matchesArray = [...matches];

                            for (const match of matchesArray) {
                                try {
                                    const messageJson = match[1];
                                    const message = JSON.parse(messageJson);

                                    if (message.type === 'cli_agent_status') {
                                        cliAgentState = message.data;
                                        updateCliAgentIndicator(); // „Ç§„É≥„Ç∏„Ç±„Éº„Çø„ÉºË°®Á§∫„ÇíÊõ¥Êñ∞
                                    }

                                    if (message.type === 'child_process_count') {
                                        performanceMetrics.childProcessCount = message.data.count || 0;
                                    }

                                    if (message.type === 'terminal_bg_color') {
                                        // ËÉåÊôØËâ≤„ÇíÈÅ©Áî®
                                        applyContainerBackgroundColor(message.data.color);
                                    }

                                    if (message.type === 'log') {
                                        // Python „Åã„Çâ„ÅÆ„É≠„Ç∞„É°„ÉÉ„Çª„Éº„Ç∏„Çí VSCode ÂÅ¥„Å´Ëª¢ÈÄÅ
                                        vscode.postMessage({
                                            type: 'log',
                                            message: `[pty-shell.py] ${message.data}`
                                        });
                                    }
                                } catch (parseError) {
                                    // ÂÄãÂà•„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Éë„Éº„Çπ„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
                                    log('Individual message parse error:', parseError);
                                }
                            }
                        }
                    } catch (error) {
                        // JSON „Éë„Éº„Çπ„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
                        log('Status message parse error:', error);
                    }
                }

                // Shift + Enter „Çí Alt + Enter „Å´Â§âÊèõ„Åô„Çã„Ç≠„Éº„Éè„É≥„Éâ„É©„Éº
                try {
                    if (typeof terminalState.term.attachCustomKeyEventHandler === 'function') {


                        terminalState.term.attachCustomKeyEventHandler(function (event) {
                            // ESC „Ç≠„Éº„ÅÆÂá¶ÁêÜÔºàvim „Å™„Å©ÂØæÂøúÔºâ
                            if (event.type === 'keydown' && event.key === 'Escape') {
                                // „Éñ„É©„Ç¶„Ç∂„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂãï‰Ωú„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                                event.preventDefault();
                                event.stopPropagation();

                                // Ê≠£„Åó„ÅÑ„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÈÄÅ‰ø°
                                vscode.postMessage({
                                    type: 'terminalInput',
                                    data: '\x1b'  // ESCÊñáÂ≠óÔºàASCII 27Ôºâ„ÇíÁ¢∫ÂÆü„Å´ÈÄÅ‰ø°
                                });

                                // false „ÇíËøî„Åó„Å¶„Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜ„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                                return false;
                            }

                            // Shift + Enter „ÅÆÂ†¥ÂêàÔºàCLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅåÂãï‰Ωú‰∏≠„ÅÆ„Å®„Åç„ÅÆ„ÅøÔºâ
                            if (event.type === 'keydown' &&
                                event.key === 'Enter' &&
                                event.shiftKey &&
                                !event.ctrlKey &&
                                !event.altKey &&
                                !event.metaKey) {

                                // CLI „Ç®„Éº„Ç∏„Çß„É≥„ÉàÔºàClaude/GeminiÔºâ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„ÅÆÂ†¥Âêà„ÅÆ„Åø Alt+Enter „Å´Â§âÊèõ
                                if (cliAgentState.active) {
                                    const agentType = cliAgentState.agent_type || 'CLI Agent';
                                    // „Éñ„É©„Ç¶„Ç∂„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂãï‰Ωú„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                                    event.preventDefault();
                                    event.stopPropagation();

                                    if (agentType === 'codex') {
                                        // Codex „É¢„Éº„Éâ: Ctrl+J „Çí„Ç®„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ (LF)
                                        const ctrlJ = '\n';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            data: ctrlJ
                                        });
                                    } else {
                                        // Êó¢Â≠ò„Ç®„Éº„Ç∏„Çß„É≥„Éà(Claude/Gemini): Alt+Enter „ÇíÈÄÅ‰ø° (ESC + CR)
                                        const altEnterSequence = '\x1b\r';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            data: altEnterSequence
                                        });
                                    }

                                    // false „ÇíËøî„Åó„Å¶„Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜ„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                                    return false;
                                } else {
                                    // CLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Åß„Å™„ÅÑÂ†¥Âêà„ÅØÈÄöÂ∏∏„ÅÆ Enter „Å®„Åó„Å¶Âá¶ÁêÜ

                                    return true;
                                }
                            }

                            // „Åù„ÅÆ‰ªñ„ÅÆ„Ç≠„Éº„ÅØ„Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜ„ÇíÁ∂ôÁ∂ö
                            return true;
                        });


                    } else {
                        log('attachCustomKeyEventHandler is not available');
                    }
                } catch (error) {
                    log('Failed to attach custom key handler:', error);
                }

                // onData „ÅÆ„É™„Çπ„Éä„Éº„Çí‰øùÂ≠ò„Åó„Å¶Âæå„Åß dispose „Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã
                const dataListener = terminalState.term.onData((data) => {
                    vscode.postMessage({
                        type: 'terminalInput',
                        data: data
                    });
                });

                // dataListener „ÇíÁÆ°ÁêÜÂØæË±°„Å´ËøΩÂä†Ôºàdispose ÊôÇ„Å´„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Åô„Çã„Åü„ÇÅÔºâ
                if (!terminalState.xtermListeners) {
                    terminalState.xtermListeners = [];
                }
                terminalState.xtermListeners.push(dataListener);
                log('[LEAK CHECK] Added onData listener, total listeners: ' + terminalState.xtermListeners.length);

                // „Éö„Éº„Çπ„Éà„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÉºÔºàDOM „Ç§„Éô„É≥„Éà„Çí‰ΩøÁî®Ôºâ
                const pasteHandler = (event) => {
                    // „Éá„Éï„Ç©„É´„Éà„ÅÆ„Éö„Éº„Çπ„ÉàÂá¶ÁêÜ„ÇíÈòªÊ≠¢
                    event.preventDefault();

                    // „ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Åã„Çâ„Éá„Éº„Çø„ÇíÂèñÂæó
                    const clipboardData = event.clipboardData || window.clipboardData;
                    if (clipboardData && clipboardData.getData) {
                        const pastedText = clipboardData.getData('text');
                        if (pastedText) {
                            log('[PASTE] Intercepted paste event, length:', pastedText.length);
                            // Â§ßÈáè„Éö„Éº„Çπ„ÉàÊôÇ„ÅØ„ÉÅ„É£„É≥„ÇØÈÄÅ‰ø°„Åß„Éï„É≠„ÉºÂà∂Âæ°
                            sendBytesInChunks(new TextEncoder().encode(pastedText), { kind: 'paste' });
                        }
                    }
                };

                // „Çø„Éº„Éü„Éä„É´Ë¶ÅÁ¥†„Å´„Éö„Éº„Çπ„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
                addManagedEventListener(terminalElement, 'paste', pasteHandler);
                log('[LEAK CHECK] Added DOM paste listener');

                let outputCount = 0;
                let totalOutputChars = 0;

                const messageHandler = (event) => {
                    const message = event.data;
                    switch (message.type) {
                        case 'output':
                            const outputStart = performance.now();
                            outputCount++;
                            totalOutputChars += message.data.length;

                            // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË®àÊ∏¨„ÇíÊõ¥Êñ∞
                            performanceMetrics.outputCount++;
                            performanceMetrics.totalOutputChars += message.data.length;

                            // „Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                            handleStatusMessage(message.data);

                            // „Éê„ÉÉ„ÉÅÂá¶ÁêÜ: „Éá„Éº„Çø„Çí„Éê„ÉÉ„Éï„Ç°„Å´ËøΩÂä†
                            terminalState.writeBufferData += message.data;

                            // „Åæ„Å†„Çø„Ç§„Éû„Éº„Åå„Çª„ÉÉ„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø
                            if (!terminalState.writeBufferPending && terminalState.term) {
                                terminalState.writeBufferPending = true;

                                // 16ms Âæå (Á¥Ñ60fps) „Å´‰∏ÄÊã¨Êõ∏„ÅçËæº„Åø
                                terminalState.timers.writeBuffer = setTimeout(() => {
                                    if (terminalState.term && terminalState.writeBufferData) {
                                        // write Âá¶ÁêÜ„ÅÆÊôÇÈñì„ÇíË®àÊ∏¨
                                        const writeStart = performance.now();
                                        const bufferLength = terminalState.writeBufferData.length;
                                        terminalState.term.write(terminalState.writeBufferData);
                                        const writeEnd = performance.now();
                                        const writeTime = writeEnd - writeStart;

                                        // Ë®àÊ∏¨„Éá„Éº„Çø„ÇíÊõ¥Êñ∞
                                        performanceMetrics.lastWriteTime = writeTime;
                                        performanceMetrics.writeTimeSum += writeTime;
                                        performanceMetrics.writeTimeCount++;
                                        performanceMetrics.avgWriteTime = performanceMetrics.writeTimeSum / performanceMetrics.writeTimeCount;
                                        performanceMetrics.maxWriteTime = Math.max(performanceMetrics.maxWriteTime, writeTime);
                                        performanceMetrics.writeBufferSize = bufferLength;

                                        // ÂÆüË°åÊôÇÈñì„Åå 50ms ‰ª•‰∏ä„ÅÆÂ†¥Âêà„ÅØË≠¶Âëä„É≠„Ç∞„ÇíÂá∫Âäõ
                                        if (writeTime >= 50) {
                                            log('[PERF] ‚ö†Ô∏è term.write() took ' + writeTime.toFixed(2) + 'ms', {
                                                bufferSize: bufferLength,
                                                avgWriteTime: performanceMetrics.avgWriteTime.toFixed(2) + 'ms',
                                                maxWriteTime: performanceMetrics.maxWriteTime.toFixed(2) + 'ms',
                                                writeCount: performanceMetrics.writeTimeCount
                                            });
                                        }

                                        terminalState.writeBufferData = '';
                                    }
                                    terminalState.writeBufferPending = false;
                                    terminalState.timers.writeBuffer = null;
                                }, 16);
                            }

                            const outputEnd = performance.now();
                            const outputTime = outputEnd - outputStart;

                            // Èáç„ÅÑÂá¶ÁêÜÔºà2ms‰ª•‰∏äÔºâ„ÅÆ„Åø„É≠„Ç∞Âá∫Âäõ
                            if (outputTime > 2) {

                            }

                            // 100Âõû„Åî„Å®„Å´Áµ±Ë®à„ÇíÂá∫Âäõ
                            if (outputCount % 100 === 0) {

                            }
                            break;
                        case 'clear':
                            if (terminalState.term) {
                                terminalState.term.clear();
                            }

                            break;
                        case 'reset':
                            // VSCode ÂÅ¥„ÅÆ„É™„Çª„ÉÉ„ÉàÂÆå‰∫Ü„Å´Âêà„Çè„Åõ„Å¶„ÄÅ„Éï„É≠„É≥„ÉàÂÅ¥„ÇÇÂÆåÂÖ®ÂÜçÂàùÊúüÂåñ
                            // „Åì„Çå„Å´„Çà„Çä„Ç≠„Éº„Éè„É≥„Éâ„É©„ÄÅ„Éï„Ç©„Éº„Ç´„Çπ„ÄÅResizeObserver„ÄÅ„Çø„Ç§„Éû„Éº„ÇíÂÅ•ÂÖ®„Å™Áä∂ÊÖã„Å´Êàª„Åô
                            resetTerminalResources();
                            setTimeout(() => {
                                initializeTerminal();
                            }, 10);
                            break;
                        case 'visibility_restored':
                            // WebView „ÅÆÂèØË¶ñÁä∂ÊÖã„ÅåÂæ©ÂÖÉ„Åï„Çå„ÅüÊôÇ„ÅÆÂá¶ÁêÜ
                            log('[LEAK CHECK] visibility_restored event received');
                            if (terminalState.term) {
                                // „Çø„Éº„Éü„Éä„É´„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Çµ„Ç§„Ç∫„ÇíÂÜçË™øÊï¥
                                setTimeout(() => {
                                    log('[LEAK CHECK] Calling setTerminalSize from visibility_restored');
                                    setTerminalSize();
                                    // „Éï„Ç©„Éº„Ç´„Çπ„ÇíÂæ©ÂÖÉ
                                    terminalState.term.focus();

                                    // CLI AgentÁä∂ÊÖã„ÇíÂº∑Âà∂ÁöÑ„Å´ÂÜç„ÉÅ„Çß„ÉÉ„ÇØË¶ÅÊ±Ç
                                    vscode.postMessage({
                                        type: 'refreshCliAgentStatus',
                                        timestamp: Date.now()
                                    });
                                }, 50);
                            } else if (terminalState.isInitialized) {
                                // „Çø„Éº„Éü„Éä„É´„ÅåÁ†¥Ê£Ñ„Åï„Çå„Å¶„ÅÑ„Çã„ÅåÂàùÊúüÂåñÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„ÄÅÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
                                log('Terminal was disposed unexpectedly, resetting state');
                                resetTerminalResources();
                                // „Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶ÂÆåÂÖ®„Å´Âæ©ÂÖÉ
                                window.location.reload();
                            }
                            break;
                        case 'bufferCleanupCompleted':
                            log('[BUFFER CLEANUP] Received cleanup completion notification', {
                                success: message.success,
                                timestamp: message.timestamp,
                                error: message.error
                            });
                            if (!message.success) {
                                log('[BUFFER CLEANUP] Backend cleanup failed:', message.error);
                            }
                            break;
                        case 'sendTextToEditor':
                            // „ÉÜ„Ç≠„Çπ„Éà„Çí ACE „Ç®„Éá„Ç£„Çø„Å´ÂÖ•Âäõ
                            if (editorState.editor && message.text) {
                                editorState.editor.insert(message.text);
                                editorState.editor.focus();
                            }
                            break;
                        case 'backendMetrics':
                            // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„É°„Éà„É™„ÇØ„Çπ„ÇíÂèó‰ø°„Åó„Å¶Êõ¥Êñ∞
                            if (message.data) {
                                performanceMetrics.backendProcessCount = message.data.processCount || 0;
                                performanceMetrics.backendSessionCount = message.data.sessionCount || 0;
                            }
                            break;
                    }
                };
                addManagedEventListener(window, 'message', messageHandler);

                // „Éú„Çø„É≥„Ç§„Éô„É≥„Éà„ÅÆË®≠ÂÆö
                const sendSelectionHandler = () => {
                    vscode.postMessage({ type: 'buttonSendSelection' });
                    // „Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØÂæå„Å´„Çø„Éº„Éü„Éä„É´„Å´„Éï„Ç©„Éº„Ç´„Çπ„ÇíÁßªÂãï
                    if (terminalState.term) {
                        terminalState.term.focus();
                    }
                };
                addManagedEventListener(document.getElementById('btn-send-selection'), 'click', sendSelectionHandler);

                // „Ç≥„Éî„Éº„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„ÉàË®≠ÂÆö
                const copySelectionHandler = () => {
                    const button = document.getElementById('btn-copy-selection');

                    vscode.postMessage({ type: 'buttonCopySelection' });

                    // „Éú„Çø„É≥„Å´ .done „ÇØ„É©„Çπ„ÇíËøΩÂä†„Åó„Å¶„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØË°®Á§∫
                    button.classList.add('done');
                    setTimeout(() => {
                        button.classList.remove('done');
                    }, 2000);

                    // „Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØÂæå„Å´„Çø„Éº„Éü„Éä„É´„Å´„Éï„Ç©„Éº„Ç´„Çπ„ÇíÁßªÂãï
                    if (terminalState.term) {
                        terminalState.term.focus();
                    }
                };
                addManagedEventListener(document.getElementById('btn-copy-selection'), 'click', copySelectionHandler);

                // „Çπ„ÇØ„É≠„Éº„É´„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„ÉàË®≠ÂÆö
                const scrollToBottomHandler = () => {
                    // „Çø„Éº„Éü„Éä„É´„Çí‰∏ÄÁï™‰∏ã„Åæ„Åß„Çπ„ÇØ„É≠„Éº„É´
                    if (terminalState.term) {
                        terminalState.term.scrollToBottom();
                        terminalState.term.focus();
                    }
                };
                addManagedEventListener(document.getElementById('btn-scroll-to-bottom'), 'click', scrollToBottomHandler);

                // ÂÆöÊúüÁöÑ„Å™„Éê„ÉÉ„Éï„Ç°„ÇØ„É™„Ç¢Ê©üËÉΩ„ÇíË®≠ÂÆö
                setupPeriodicBufferCleanup();

                // ÂàùÊúüÂåñÂÆå‰∫Ü„Éï„É©„Ç∞„ÇíË®≠ÂÆö
                terminalState.isInitialized = true;

                // ÂÖ•Âäõ„Éï„Ç©„Éº„Ç´„Çπ„ÇíÊòéÁ§∫ÁöÑ„Å´‰∏é„Åà„Çã
                if (terminalState.term) {
                    terminalState.term.focus();
                }

                // VSCode ÂÅ¥„Å´Ê∫ñÂÇôÂÆå‰∫Ü„ÇíÈÄöÁü•Ôºà„Åì„Çå„Çí„Éà„É™„Ç¨„Å´„Ç∑„Çß„É´„ÇíËµ∑ÂãïÔºâ
                vscode.postMessage({ type: 'terminalReady' });

            } catch (error) {
                log('Error initializing terminal:', error);
                vscode.postMessage({ type: 'error', error: error.message });
                document.getElementById('terminal').innerHTML = '<p style="color: red;">Error loading terminal: ' + error.message + '</p>';
            }
        }

        // „Çø„Éº„Éü„Éä„É´ÂàùÊúüÂåñ„ÇíÂÆüË°å
        initializeTerminal();

        // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ HUD „ÇíÂàùÊúüÂåñ
        setupPerformanceHUD();

        // ACE „Ç®„Éá„Ç£„ÇøÂàùÊúüÂåñ„ÇíÂÆüË°å
        setTimeout(() => {
            log('[ACE] Attempting to initialize editor...');
            initializeAceEditor();
            // ÂàùÊúüÂåñÂæå„ÅÆÁ¢∫Ë™ç
            if (editorState.editor) {
                log('[ACE] Editor successfully initialized, testing keybindings...');
                const commands = editorState.editor.commands.byName;
                if (commands.sendToTerminal) {
                    log('[ACE] sendToTerminal command is registered');
                } else {
                    log('[ACE] sendToTerminal command NOT found!');
                }
            } else {
                log('[ACE] Editor initialization failed!');
            }
        }, 100);

        /**
         * „Ç≥„É≥„ÉÜ„Éä(Êû†)„ÅÆËÉåÊôØËâ≤„ÇíÈÅ©Áî®
         */
        function applyContainerBackgroundColor(colorCode) {
            if (!colorCode || typeof colorCode !== 'string') {
                return;
            }
            if (colorCode === terminalState.currentContainerBackgroundColor) {
                return;
            }
            log('[BG COLOR] Applying container background color:', colorCode);
            // CSSVar „ÇíÊõ¥Êñ∞
            document.documentElement.style.setProperty('--vscode-sideBar-background', colorCode);

            // const terminalContainer = document.getElementById('terminal-container');
            // terminalContainer.style.backgroundColor = colorCode;
            // terminalState.currentContainerBackgroundColor = colorCode;
        }

    </script>
</body>

</html>