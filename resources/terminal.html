<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; style-src {{CSP_SOURCE}} 'unsafe-inline'; script-src {{CSP_SOURCE}} 'unsafe-inline';">
    <title>Secondary Terminal</title>
    <link rel="stylesheet" href="{{XTERM_CSS_URI}}" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }

        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-editor-foreground);
            font-family: "RobotoMono Nerd Font Mono", "Roboto Mono", Consolas, "Courier New", monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-container {
            flex: 1;
            width: 100%;
            min-height: 0;
            /* 重要：flexboxで子要素が縮むのを許可 */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: var(--vscode-sideBar-background);
        }


        .terminal.xterm {
            padding: 0;

            /* xterm.js のコンテナを透明に */
            .xterm-viewport {
                background-color: transparent !important;
            }

            .xterm-screen {
                background-color: transparent !important;
            }

            .xterm-helper-textarea {
                background-color: transparent !important;
            }

            /* スクロール時に選択ハイライトが残る問題を修正 */
            .xterm-selection {
                overflow: hidden;
            }
        }

        /* Tab Bar Styles */
        .tab-bar {
            display: flex;
            align-items: center;
            background-color: var(--vscode-tab-activeBackground, #1e1e1e);
            border-bottom: 1px solid var(--vscode-tab-border, #3c3c3c);
            height: 30px;
            flex-shrink: 0;
            overflow: hidden;
        }

        .tab-list {
            display: flex;
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none;
        }

        .tab-list::-webkit-scrollbar {
            display: none;
        }

        .tab {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            background-color: var(--vscode-tab-inactiveBackground, #2d2d2d);
            color: var(--vscode-tab-inactiveForeground, #888);
            border-right: 1px solid var(--vscode-tab-border, #3c3c3c);
            cursor: pointer;
            white-space: nowrap;
            font-size: 12px;
            min-width: 80px;
            max-width: 150px;
            user-select: none;
        }

        .tab.active {
            background-color: var(--vscode-tab-activeBackground, #1e1e1e);
            color: var(--vscode-tab-activeForeground, #fff);
        }

        .tab-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tab-close {
            margin-left: 6px;
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            opacity: 0.6;
            font-size: 14px;
            line-height: 1;
        }

        .tab-close:hover {
            opacity: 1;
            background-color: var(--vscode-toolbar-hoverBackground, #444);
        }

        .tab-close:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .tab-add {
            padding: 4px 12px;
            background: none;
            border: none;
            color: var(--vscode-foreground, #ccc);
            cursor: pointer;
            font-size: 16px;
            flex-shrink: 0;
        }

        .tab-add:hover {
            background-color: var(--vscode-toolbar-hoverBackground, #444);
        }

        /* Terminal Panes Container */
        .terminal-panes {
            flex: 1;
            position: relative;
            min-height: 0;
        }

        .terminal-pane {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            padding: 0 0 0 5px;
        }

        .terminal-pane.active {
            display: flex;
            flex-direction: column;
        }

        /* コントロールパネル */
        .control-panel {
            flex-shrink: 0;
            /* 重要：縮まないように固定 */
            background-color: var(--vscode-panel-background, #252526);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            padding: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: start;
            box-sizing: border-box;
        }

        .control-panel-left-controls {
            display: flex;
            align-items: center;
            justify-content: start;
            flex-grow: 1;
            gap: 0.5em;
        }

        .control-panel-right-controls {
            display: flex;
            align-items: center;
            justify-content: end;
            padding: 0.5em;
            gap: 0.5em;
        }

        .control-button {
            background-color: var(--vscode-button-secondaryBackground, #3c3c3c);
            color: var(--vscode-button-secondaryForeground, #cccccc);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: background-color 0.2s;

            &:hover {
                background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
            }
        }

        .copy-button {
            background-color: var(--vscode-button-secondaryBackground, #3c3c3c);
            color: var(--vscode-button-secondaryForeground, #cccccc);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: background-color 0.2s;
            position: relative;

            &:hover {
                background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
            }

            &.done {
                color: transparent;
            }

            &.done::after {
                content: '✓';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: var(--vscode-button-secondaryForeground, #cccccc);
            }
        }


        /* CLI エージェントアクティブ表示 */
        .cli-agent-indicator {
            color: #888;
            font-family: inherit;
            font-size: 12px;
            transition: opacity 0.3s ease;
            opacity: 0;

            &.active {
                opacity: 1;
            }
        }


        /* ACE エディタコンテナ */
        .editor-container {
            flex-shrink: 0;
            background-color: var(--vscode-editor-background);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            border-bottom: 1px solid var(--vscode-panel-border, #3c3c3c);
            height: 200px;
            overflow: hidden;
        }

        #ace-editor {
            width: 100%;
            height: 100%;
        }

        /* カスタム ACE テーマ - VSCode ダーク風 */
        .ace-vscode-dark {
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);

            .ace_gutter {
                background-color: var(--vscode-editorGutter-background);
                color: var(--vscode-editorLineNumber-foreground);
                border-right: 1px solid var(--vscode-panel-border, #3c3c3c);
            }

            .ace_print-margin {
                width: 1px;
                background: var(--vscode-editorRuler-foreground);
            }

            .ace_cursor {
                color: var(--vscode-editorCursor-foreground);
            }

            .ace_marker-layer {
                .ace_selection {
                    background: var(--vscode-editor-selectionBackground);
                }

                .ace_step {
                    background: var(--vscode-debugTokenExpression-number);
                }

                .ace_bracket {
                    margin: -1px 0 0 -1px;
                    border: 1px solid var(--vscode-editorBracketMatch-border);
                    background: var(--vscode-editorBracketMatch-background);
                }

                .ace_active-line {
                    background: var(--vscode-editor-lineHighlightBackground);
                }

                .ace_selected-word {
                    border: 1px solid var(--vscode-editor-selectionHighlightBorder);
                    background: var(--vscode-editor-selectionHighlightBackground);
                }
            }

            &.ace_multiselect .ace_selection.ace_start {
                box-shadow: 0 0 3px 0px var(--vscode-editor-background);
                border-radius: 2px;
            }

            .ace_gutter-active-line {
                background-color: var(--vscode-editor-lineHighlightBackground);
            }

            .ace_invisible {
                color: var(--vscode-editorWhitespace-foreground, #404040);
            }

            .ace_keyword,
            .ace_meta,
            .ace_storage,
            .ace_storage.ace_type,
            .ace_support.ace_type {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_keyword.ace_operator {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_constant.ace_character,
            .ace_constant.ace_language,
            .ace_constant.ace_numeric,
            .ace_keyword.ace_other.ace_unit,
            .ace_support.ace_constant,
            .ace_variable.ace_parameter {
                color: var(--vscode-debugTokenExpression-number);
            }

            .ace_constant.ace_other {
                color: var(--vscode-debugTokenExpression-number);
            }

            .ace_invalid {
                color: var(--vscode-editorError-foreground);
                background-color: var(--vscode-editorError-background);

                &.ace_deprecated {
                    color: var(--vscode-editorWarning-foreground);
                    background-color: var(--vscode-editorWarning-background);
                }
            }

            .ace_fold {
                background-color: var(--vscode-debugTokenExpression-name);
                border-color: var(--vscode-debugTokenExpression-name);
            }

            .ace_entity.ace_name.ace_function,
            .ace_support.ace_function,
            .ace_variable {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_support.ace_class,
            .ace_support.ace_type {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_heading,
            .ace_markup.ace_heading {
                color: var(--vscode-debugTokenExpression-name);
                font-weight: bold;
            }

            .ace_list,
            .ace_markup.ace_list {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_list.ace_markup {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_punctuation.ace_definition.ace_list_begin {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_entity.ace_name.ace_tag,
            .ace_entity.ace_other.ace_attribute-name,
            .ace_meta.ace_tag,
            .ace_string.ace_regexp,
            .ace_variable {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_comment {
                color: var(--vscode-debugConsole-infoForeground);
                font-style: italic;
            }

            .ace_string {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_entity.ace_other.ace_attribute-name {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_indent-guide {
                background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChAGGzJY5NwAAAABJRU5ErkJggg==") right repeat-y;
            }
        }
    </style>
</head>

<body>
    <div class="terminal-container" id="terminal-container">

        <!-- Tab Bar -->
        <div class="tab-bar" id="tab-bar">
            <div class="tab-list" id="tab-list"></div>
            <button class="tab-add" id="btn-add-tab" title="New Terminal">+</button>
        </div>

        <!-- Terminal Panes Container -->
        <div class="terminal-panes" id="terminal-panes"></div>

        <!-- ACE エディタペイン -->
        <div class="editor-container">
            <div id="ace-editor"></div>
        </div>

        <!-- 下部コントロールパネル -->
        <div class="control-panel">
            <div class="control-panel-left-controls">
                <button class="control-button" id="btn-send-selection"
                    title="Send editor selection to terminal (Cmd+L)">
                    @Selection
                </button>
                <button class="copy-button" id="btn-copy-selection" title="Copy editor selection context to clipboard">
                    Copy
                </button>
                <button class="control-button" id="btn-extract-to-todos" title="Extract editor content to TODOS.md">
                    Extract
                </button>
                <button class="control-button" id="btn-open-history" title="Open prompt history file">
                    History
                </button>
                <button class="control-button" id="btn-scroll-to-bottom" title="Scroll to bottom of terminal">
                    ↓
                </button>
            </div>
            <div class="control-panel-right-controls">
                <!-- CLI エージェントインジケーター -->
                <div class="cli-agent-indicator" id="cli-agent-indicator"
                    title="CLI Agent is active - Shift+Enter inputs a newline">CLI Agent</div>
            </div>
        </div>
    </div>

    <script src="{{XTERM_JS_URI}}"></script>
    <script src="{{XTERM_UNICODE11_JS_URI}}"></script>
    <script src="{{XTERM_WEBGL_JS_URI}}"></script>

    <!-- ACE Editor Scripts -->
    <script src="{{ACE_JS_URI}}"></script>
    <script src="{{ACE_MODE_JAVASCRIPT_URI}}"></script>
    <script src="{{ACE_MODE_MARKDOWN_URI}}"></script>
    <script src="{{ACE_KEYBINDING_VSCODE_URI}}"></script>
    <script>
        const MAX_BUFFER_LINES = parseInt('{{SCROLLBACK_MAX}}'); // 設定された最大行数
        const vscode = acquireVsCodeApi();

        // タブ状態管理
        const tabState = {
            tabs: [],                    // Array of {id, title}
            activeTabId: null,
            terminals: new Map(),        // tabId -> xterm Terminal instance
            terminalStates: new Map(),   // tabId -> per-tab terminalState
            globalEventListeners: [],    // グローバルなイベントリスナー
            resizeObserver: null,
        };

        // 新しいタブ用のデフォルト terminalState を生成
        function createTerminalState() {
            return {
                term: null,
                timers: {
                    sizeCheckInterval: null,
                    backgroundColorInterval: null,
                    writeBuffer: null
                },
                eventListeners: [],
                isInitialized: false,
                writeBufferData: '',
                writeBufferPending: false,
                currentContainerBackgroundColor: null,
                lastWriteTime: 0,
                recentWriteCount: 0,
                adaptiveDelayMs: 16,
                addons: [],
                xtermListeners: [],
                cliAgentState: { active: false, agent_type: null },
            };
        }

        // 後方互換性のため、現在のアクティブタブの terminalState を返すゲッター
        function getActiveTerminalState() {
            if (!tabState.activeTabId) return null;
            return tabState.terminalStates.get(tabState.activeTabId);
        }

        // 注: terminalState は tabState.terminalStates に移行済み

        // ACE エディタ用の状態管理
        const editorState = {
            editor: null,
            isInitialized: false
        };



        /**
         * ログメッセージを送信する
         */
        function log(...args) {
            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');
            vscode.postMessage({
                type: 'log',
                message: `[terminal.html] ${message}`
            })
        }

        // ========================================
        // Tab UI Functions
        // ========================================

        /**
         * タブ UI 要素を作成
         */
        function createTabUI(tabInfo) {
            const tabList = document.getElementById('tab-list');
            const tab = document.createElement('div');
            tab.className = 'tab';
            tab.dataset.tabId = tabInfo.id;
            tab.innerHTML = `
                <span class="tab-title">${tabInfo.title}</span>
                <button class="tab-close" title="Close">×</button>
            `;
            tabList.appendChild(tab);
            updateTabCloseButtons();
            return tab;
        }

        /**
         * タブの close ボタンの状態を更新
         * 全てのタブが閉じられるようになった（タブ0個も可）
         */
        function updateTabCloseButtons() {
            // 現在は全てのタブが閉じられるため、特に無効化は行わない
        }

        /**
         * 指定したタブに切り替え
         */
        function switchToTab(tabId) {
            log('[TAB] Switching to tab:', tabId);

            // タブ UI の active 状態を更新
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tabId === tabId);
            });

            // ターミナルペインの表示/非表示
            document.querySelectorAll('.terminal-pane').forEach(pane => {
                pane.classList.toggle('active', pane.dataset.tabId === tabId);
            });

            // 状態を更新
            tabState.activeTabId = tabId;

            // アクティブなターミナルにフォーカス
            const state = tabState.terminalStates.get(tabId);
            if (state && state.term) {
                setTimeout(() => {
                    state.term.focus();
                    setTerminalSize(tabId);
                }, 50);
            }
        }

        /**
         * タブを閉じる（UI とリソースを削除）
         */
        function closeTabUI(tabId) {
            log('[TAB] Closing tab:', tabId);

            // タブ要素を削除
            const tabElement = document.querySelector(`.tab[data-tab-id="${tabId}"]`);
            if (tabElement) {
                tabElement.remove();
            }

            // ターミナルペインを削除
            const paneElement = document.querySelector(`.terminal-pane[data-tab-id="${tabId}"]`);
            if (paneElement) {
                paneElement.remove();
            }

            // ターミナル状態をクリーンアップ
            const state = tabState.terminalStates.get(tabId);
            if (state) {
                cleanupTerminalState(state);
                tabState.terminalStates.delete(tabId);
            }

            // ターミナルインスタンスを削除
            tabState.terminals.delete(tabId);

            // タブリストから削除
            const tabIndex = tabState.tabs.findIndex(t => t.id === tabId);
            if (tabIndex !== -1) {
                tabState.tabs.splice(tabIndex, 1);
            }

            updateTabCloseButtons();

            // 閉じたタブがアクティブだった場合、別のタブに切り替え
            if (tabState.activeTabId === tabId) {
                const nextTab = tabState.tabs[0];
                if (nextTab) {
                    switchToTab(nextTab.id);
                    vscode.postMessage({ type: 'switchTab', tabId: nextTab.id });
                } else {
                    // 他にタブがない場合はアクティブタブをクリア
                    tabState.activeTabId = null;
                }
            }
        }

        /**
         * ターミナル状態のクリーンアップ
         */
        function cleanupTerminalState(state) {
            // xterm リスナーを dispose
            if (state.xtermListeners && state.xtermListeners.length > 0) {
                state.xtermListeners.forEach(listener => {
                    try {
                        if (listener && listener.dispose) {
                            listener.dispose();
                        }
                    } catch (e) { }
                });
                state.xtermListeners = [];
            }

            // アドオンを dispose
            if (state.addons && state.addons.length > 0) {
                state.addons.forEach(addon => {
                    try {
                        if (addon && addon.dispose) {
                            addon.dispose();
                        }
                    } catch (e) { }
                });
                state.addons = [];
            }

            // ターミナルを破棄
            if (state.term) {
                try {
                    state.term.dispose();
                } catch (e) { }
                state.term = null;
            }

            // タイマーをクリア
            Object.keys(state.timers).forEach(timerKey => {
                if (state.timers[timerKey]) {
                    try {
                        clearTimeout(state.timers[timerKey]);
                        clearInterval(state.timers[timerKey]);
                    } catch (e) { }
                    state.timers[timerKey] = null;
                }
            });

            // イベントリスナーを削除
            state.eventListeners.forEach(({ element, event, handler }) => {
                try {
                    element.removeEventListener(event, handler);
                } catch (e) { }
            });
            state.eventListeners = [];
        }

        /**
         * ターミナルペイン DOM を作成
         */
        function createTerminalPane(tabId) {
            const panesContainer = document.getElementById('terminal-panes');
            const pane = document.createElement('div');
            pane.className = 'terminal-pane';
            pane.dataset.tabId = tabId;
            pane.id = `terminal-pane-${tabId}`;
            panesContainer.appendChild(pane);
            return pane;
        }

        /**
         * ターミナルサイズを動的に設定（タブ対応）
         */
        function setTerminalSize(tabId) {
            const state = tabState.terminalStates.get(tabId);
            if (!state || !state.term) {
                return;
            }

            const terminalPane = document.getElementById('terminal-pane-' + tabId);
            if (!terminalPane) {
                log('Terminal pane not found for tab:', tabId);
                return;
            }

            // ターミナルペインの実際のサイズを取得
            const terminalRect = terminalPane.getBoundingClientRect();
            const availableWidth = terminalRect.width - 20; // パディング考慮
            const availableHeight = terminalRect.height - 5;

            if (availableWidth <= 0 || availableHeight <= 0) {
                return;
            }

            // フォント情報から文字サイズを正確に計算
            const fontSize = 13;
            const targetLineHeight = 1.2;

            // 一時的な測定用エレメントを作成して文字幅を正確に測定
            const measurer = document.createElement('div');
            measurer.style.position = 'absolute';
            measurer.style.visibility = 'hidden';
            measurer.style.fontFamily = '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace';
            measurer.style.fontSize = fontSize + 'px';
            measurer.style.lineHeight = targetLineHeight;
            measurer.style.whiteSpace = 'pre';
            measurer.textContent = 'M'.repeat(10);

            document.body.appendChild(measurer);
            const rawCharWidth = measurer.getBoundingClientRect().width / 10;
            const rawLineHeight = measurer.getBoundingClientRect().height;
            document.body.removeChild(measurer);

            // サイズ調整係数
            const widthAdjustment = 0.88;
            const heightAdjustment = 1.34;

            const adjustedCharWidth = rawCharWidth * widthAdjustment;
            const adjustedLineHeight = rawLineHeight * heightAdjustment;

            // 列数と行数を計算
            const cols = Math.floor(availableWidth / adjustedCharWidth);
            const rows = Math.floor(availableHeight / adjustedLineHeight);

            // 最小サイズを保証
            const finalCols = Math.max(cols, 20);
            const finalRows = Math.max(rows, 5);

            // ターミナルサイズを設定
            if (state.term.cols !== finalCols || state.term.rows !== finalRows) {
                state.term.resize(finalCols, finalRows);

                // サイズ変更を VSCode に通知（tabId を含める）
                vscode.postMessage({
                    type: 'resize',
                    tabId: tabId,
                    cols: finalCols,
                    rows: finalRows
                });
            }
        }

        /**
         * 画面消去系エスケープシーケンスを検知する
         * vim, less 等のTUIアプリの全画面再描画パターンを判定
         * 注: \x1b[H (カーソルホーム) はプロンプト表示でも使われるため除外
         */
        function hasScreenClearSequence(data) {
            return data.includes('\x1b[2J') ||    // 画面クリア
                   data.includes('\x1b[?1049');   // 代替バッファ切り替え
        }

        // ACE エディタ初期化関数
        function initializeAceEditor() {
            try {
                if (editorState.isInitialized) {
                    log('[ACE] Editor is already initialized');
                    return;
                }

                if (typeof ace === 'undefined') {
                    throw new Error('ACE is not defined. ace-builds may not have loaded.');
                }

                log('[ACE] Starting editor initialization');

                // VSCode ダークテーマを ACE に登録
                if (ace.define) {
                    ace.define('ace/theme/vscode-dark', ['require', 'exports', 'module'], function(require, exports, module) {
                        exports.isDark = true;
                        exports.cssClass = "ace-vscode-dark";
                        exports.cssText = ""; // CSS は HTML のスタイルで定義済み
                    });
                }

                // エディタを初期化
                editorState.editor = ace.edit("ace-editor");

                // 設定を適用
                editorState.editor.setTheme("ace/theme/vscode-dark");
                editorState.editor.session.setMode("ace/mode/markdown");
                editorState.editor.setKeyboardHandler("ace/keyboard/vscode");

                // エディタオプション
                editorState.editor.setOptions({
                    fontSize: 13,
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    showPrintMargin: false,
                    wrap: true,
                    showInvisibles: true,
                    enableBasicAutocompletion: true,
                    enableLiveAutocompletion: true,
                    enableSnippets: true
                });

                // 初期値を設定（永続化された値があれば復元）
                const savedContent = vscode.getState()?.editorContent || '';
                editorState.editor.setValue(savedContent, -1); // -1 でカーソルを先頭に

                // Command+Enter キーバインドを追加
                editorState.editor.commands.addCommand({
                    name: 'sendToTerminal',
                    bindKey: { win: 'Ctrl-Enter', mac: 'Cmd-Enter' },
                    exec: function(editor) {
                        log('[ACE] Command+Enter pressed');
                        const content = editor.getValue();
                        log('[ACE] Editor content:', content);

                        if (content.trim()) {
                            log('[ACE] Processing content for terminal...');

                            // 1. 末尾のホワイトスペース（改行含む）を除去
                            const trimmedContent = content.trimEnd();
                            log('[ACE] Trimmed content:', trimmedContent);

                            // 2. コンテンツをターミナルに送信
                            log('[ACE] Sending content to terminal');
                            vscode.postMessage({
                                type: 'editorSendContent',
                                data: trimmedContent,
                                tabId: tabState.activeTabId
                            });
                            log('[ACE] Content sent to terminal');

                            // 3. 200ms 待機後に Enter を送信
                            setTimeout(() => {
                                log('[ACE] Sending Enter after 200ms');
                                vscode.postMessage({
                                    type: 'terminalInput',
                                    data: '\r',
                                    tabId: tabState.activeTabId
                                });
                                log('[ACE] Enter sent to terminal');

                                // 4. エディタの内容をクリア
                                editor.setValue('', -1);
                                log('[ACE] Editor content cleared');
                            }, 200);
                        } else {
                            log('[ACE] Editor content is empty, not sending');
                        }
                    }
                });

                // エディタの内容が変更された時の処理
                editorState.editor.on('change', function() {
                    const content = editorState.editor.getValue();
                    // 内容を永続化
                    vscode.setState({
                        ...vscode.getState(),
                        editorContent: content
                    });
                });

                // DOM レベルでのキーイベント処理を追加（ACE のキーバインディングより優先度高）
                const aceContainer = document.getElementById('ace-editor');
                if (aceContainer) {
                    aceContainer.addEventListener('keydown', function(event) {
                        // Command+Enter (Mac) または Ctrl+Enter (Windows) をキャッチ
                        if (event.key === 'Enter' && (event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey) {
                            log('[ACE DOM] Command+Enter detected');
                            event.preventDefault(); // デフォルトの動作を阻止
                            event.stopPropagation(); // イベントの伝播を停止

                            const content = editorState.editor.getValue();
                            log('[ACE DOM] Editor content:', content);

                            if (content.trim()) {
                                log('[ACE DOM] Processing content for terminal...');

                                // 1. 末尾のホワイトスペース（改行含む）を除去
                                const trimmedContent = content.trimEnd();
                                log('[ACE DOM] Trimmed content:', trimmedContent);

                                // 2. コンテンツをターミナルに送信
                                log('[ACE DOM] Sending content to terminal');
                                vscode.postMessage({
                                    type: 'editorSendContent',
                                    data: trimmedContent,
                                    tabId: tabState.activeTabId
                                });
                                log('[ACE DOM] Content sent to terminal');

                                // 3. 200ms 待機後に Enter を送信
                                setTimeout(() => {
                                    log('[ACE DOM] Sending Enter after 200ms');
                                    vscode.postMessage({
                                        type: 'terminalInput',
                                        data: '\r',
                                        tabId: tabState.activeTabId
                                    });
                                    log('[ACE DOM] Enter sent to terminal');

                                    // 4. エディタの内容をクリア
                                    editorState.editor.setValue('', -1);
                                    log('[ACE DOM] Editor content cleared');
                                }, 200);
                            } else {
                                log('[ACE DOM] Editor content is empty, not sending');
                            }

                            return false; // イベント処理終了
                        }
                    }, true); // useCapture = true で早期にキャプチャ
                    log('[ACE] DOM keydown listener added');
                }

                editorState.isInitialized = true;
                log('[ACE] Editor initialization completed');

            } catch (error) {
                log('[ACE] Error initializing editor:', error);
            }
        }

        // リソース完全リセット関数（マルチタブ対応）
        function resetTerminalResources() {
            log('[LEAK CHECK] Starting resource reset');

            // 全タブの状態をクリーンアップ
            tabState.terminalStates.forEach((termState, tabId) => {
                log('[LEAK CHECK] Cleaning up tab:', tabId);
                cleanupTerminalState(termState);
            });

            // グローバル ResizeObserver を停止
            if (tabState.resizeObserver) {
                try {
                    tabState.resizeObserver.disconnect();
                } catch (error) {
                    log('Error disconnecting ResizeObserver:', error);
                }
                tabState.resizeObserver = null;
            }

            // グローバルイベントリスナーを削除
            tabState.globalEventListeners.forEach(({ element, event, handler }) => {
                try {
                    element.removeEventListener(event, handler);
                } catch (error) {
                    log('Error removing global event listener:', error);
                }
            });
            tabState.globalEventListeners = [];

            // タブ状態をリセット
            tabState.tabs = [];
            tabState.activeTabId = null;
            tabState.terminals.clear();
            tabState.terminalStates.clear();

            // タブ UI をクリア
            const tabList = document.getElementById('tab-list');
            if (tabList) {
                tabList.innerHTML = '';
            }
            const terminalPanes = document.getElementById('terminal-panes');
            if (terminalPanes) {
                terminalPanes.innerHTML = '';
            }

            log('[LEAK CHECK] Resource reset completed');
        }

        // イベントリスナー登録ヘルパー（管理対象に追加）
        // targetState が指定された場合はそのタブの state に、なければグローバルに登録
        function addManagedEventListener(element, event, handler, targetState = null) {
            element.addEventListener(event, handler);
            if (targetState && targetState.eventListeners) {
                targetState.eventListeners.push({ element, event, handler });
            } else {
                tabState.globalEventListeners.push({ element, event, handler });
            }
        }

        // 大量ペーストのチャンク送信機能
        function sendBytesInChunks(bytes, meta) {
            const CHUNK_SIZE = 32 * 1024; // 32KB チャンクサイズ
            const id = Math.random().toString(36).slice(2); // ランダム ID
            let offset = 0;

            // ACK 待ち用のイベントリスナー
            const onAck = (event) => {
                const message = event.data;
                if (!message || message.type !== 'terminalInputAck' || message.id !== id) {
                    return;
                }

                if (message.done) {
                    // 送信完了
                    window.removeEventListener('message', onAck);
                    log('[PASTE CHUNKS] All chunks sent successfully');
                    return;
                }

                // 次のチャンクを送信
                sendNextChunk();
            };

            window.addEventListener('message', onAck);

            // 送信開始通知
            log('[PASTE CHUNKS] Starting chunked paste, total bytes:', bytes.length);
            vscode.postMessage({
                type: 'terminalInputBegin',
                id: id,
                totalBytes: bytes.length,
                ...meta
            });

            function sendNextChunk() {
                if (offset >= bytes.length) {
                    // 送信終了通知
                    vscode.postMessage({ type: 'terminalInputEnd', id: id });
                    return;
                }

                const chunkEnd = Math.min(offset + CHUNK_SIZE, bytes.length);
                const slice = bytes.subarray(offset, chunkEnd);

                // base64 エンコーディングで安全に転送
                const b64 = btoa(String.fromCharCode.apply(null, slice));

                log('[PASTE CHUNKS] Sending chunk', offset, 'to', chunkEnd, 'of', bytes.length);
                vscode.postMessage({
                    type: 'terminalInputChunk',
                    id: id,
                    b64: b64,
                    offset: offset,
                    size: slice.length
                });

                offset = chunkEnd;
            }

            // 最初のチャンクを送信
            sendNextChunk();
        }

        // 定期的なバッファクリア機能（マルチタブ対応）
        let bufferCleanupSetup = false;
        function setupPeriodicBufferCleanup() {
            // 既にセットアップ済みの場合はスキップ
            if (bufferCleanupSetup) {
                return;
            }
            bufferCleanupSetup = true;

            // 設定可能な値
            const BUFFER_CHECK_INTERVAL = 30000; // 30秒間隔でチェック
            const CLEANUP_THRESHOLD = Math.floor(MAX_BUFFER_LINES * 0.8); // 80%で警告
            const CLEANUP_TARGET = Math.floor(MAX_BUFFER_LINES * 0.6); // 60%まで削減

            log('[BUFFER CLEANUP] Setting up periodic buffer cleanup', {
                checkInterval: BUFFER_CHECK_INTERVAL,
                maxLines: MAX_BUFFER_LINES,
                cleanupThreshold: CLEANUP_THRESHOLD,
                cleanupTarget: CLEANUP_TARGET
            });

            const bufferCleanupTimer = setInterval(() => {
                // 全タブのバッファをチェック
                tabState.terminalStates.forEach((termState, tabId) => {
                    if (!termState.term) {
                        return;
                    }

                    try {
                        const buffer = termState.term.buffer;
                        if (!buffer || !buffer.active) {
                            return;
                        }

                        const totalLines = buffer.active.length;
                        const scrollbackLines = totalLines - termState.term.rows;

                        // スクロールバック行数が閾値を超えた場合、クリアを実行
                        if (scrollbackLines > CLEANUP_THRESHOLD) {
                            log('[BUFFER CLEANUP] Buffer cleanup triggered for tab:', tabId, {
                                currentLines: scrollbackLines,
                                targetLines: CLEANUP_TARGET
                            });

                            // 現在のスクロール位置を保存
                            const currentScrollY = termState.term.buffer.active.viewportY;
                            const isAtBottom = currentScrollY >= (totalLines - termState.term.rows);

                            // 少し待ってからクリアを実行
                            setTimeout(() => {
                                try {
                                    // VSCode 側にバッファクリア要求を送信
                                    vscode.postMessage({
                                        type: 'bufferCleanupRequest',
                                        tabId: tabId,
                                        currentLines: scrollbackLines,
                                        threshold: CLEANUP_THRESHOLD,
                                        preserveScrollPosition: !isAtBottom
                                    });

                                    if (isAtBottom && termState.term) {
                                        termState.term.scrollToBottom();
                                    }

                                } catch (error) {
                                    log('[BUFFER CLEANUP] Error during buffer cleanup:', error);
                                    if (termState.term) {
                                        termState.term.scrollToBottom();
                                    }
                                }
                            }, 100);
                        }
                    } catch (error) {
                        log('[BUFFER CLEANUP] Error checking buffer for tab:', tabId, error);
                    }
                });
            }, BUFFER_CHECK_INTERVAL);

            // グローバルタイマーとして保存
            tabState.bufferCleanupTimer = bufferCleanupTimer;
            log('[BUFFER CLEANUP] Periodic buffer cleanup timer set');
        }

        // グローバルイベントハンドラ初期化（一度だけ実行）
        let globalHandlersInitialized = false;
        function initializeGlobalHandlers() {
            if (globalHandlersInitialized) {
                log('[GLOBAL] Global handlers already initialized, skipping');
                return;
            }
            globalHandlersInitialized = true;
            log('[GLOBAL] Initializing global handlers');

            // グローバルメッセージハンドラ（全タブに対応）
            const globalMessageHandler = (event) => {
                const message = event.data;
                switch (message.type) {
                    case 'output':
                        // メッセージの tabId を取得（アクティブタブへのフォールバック）
                        const outputTabId = message.tabId || tabState.activeTabId;
                        if (!outputTabId) {
                            log('[OUTPUT] No tabId available');
                            break;
                        }
                        const outputState = tabState.terminalStates.get(outputTabId);
                        if (!outputState) {
                            log('[OUTPUT] No state found for tabId:', outputTabId);
                            break;
                        }

                        // ステータスメッセージをチェック（タブ固有のハンドラを使用）
                        if (outputState.handleStatusMessage) {
                            outputState.handleStatusMessage(message.data);
                        }

                        // アダプティブレンダリング: 画面消去検知と更新頻度追跡
                        const payload = message.data;
                        const hasScreenClear = hasScreenClearSequence(payload);

                        // 更新頻度を追跡（50ms以内の連続更新をカウント）
                        const now = Date.now();
                        if (now - outputState.lastWriteTime < 50) {
                            outputState.recentWriteCount = Math.min(outputState.recentWriteCount + 1, 10);
                        } else {
                            outputState.recentWriteCount = Math.max(0, outputState.recentWriteCount - 2);
                        }
                        outputState.lastWriteTime = now;

                        // 動的に遅延を調整
                        if (hasScreenClear || outputState.recentWriteCount > 5) {
                            outputState.adaptiveDelayMs = 50;  // 20fps（TUI アプリ向け）
                        } else if (outputState.recentWriteCount > 2) {
                            outputState.adaptiveDelayMs = 33;  // 30fps
                        } else {
                            outputState.adaptiveDelayMs = 16;  // 60fps（通常出力）
                        }

                        // バッチ処理: データをバッファに追加
                        outputState.writeBufferData += payload;

                        // まだタイマーがセットされていない場合のみ
                        if (!outputState.writeBufferPending && outputState.term) {
                            outputState.writeBufferPending = true;
                            outputState.timers.writeBuffer = setTimeout(() => {
                                if (outputState.term && outputState.writeBufferData) {
                                    outputState.term.write(outputState.writeBufferData);
                                    outputState.writeBufferData = '';
                                }
                                outputState.writeBufferPending = false;
                                outputState.timers.writeBuffer = null;
                            }, outputState.adaptiveDelayMs);
                        }
                        break;

                    case 'clear':
                        const clearTabId = message.tabId || tabState.activeTabId;
                        const clearState = tabState.terminalStates.get(clearTabId);
                        if (clearState && clearState.term) {
                            clearState.term.clear();
                        }
                        break;

                    case 'reset':
                        resetTerminalResources();
                        // 新しいタブを作成して初期化
                        setTimeout(() => {
                            const newTabId = createNewTab();
                            if (newTabId) {
                                initializeTerminal(newTabId);
                            }
                        }, 10);
                        break;

                    case 'visibility_restored':
                        log('[LEAK CHECK] visibility_restored event received');
                        const activeState = getActiveTerminalState();
                        if (activeState && activeState.term) {
                            setTimeout(() => {
                                log('[LEAK CHECK] Calling setTerminalSize from visibility_restored');
                                setTerminalSize(tabState.activeTabId);
                                activeState.term.focus();
                                vscode.postMessage({
                                    type: 'refreshCliAgentStatus',
                                    tabId: tabState.activeTabId,
                                    timestamp: Date.now()
                                });
                            }, 50);
                        } else if (activeState && activeState.isInitialized) {
                            log('Terminal was disposed unexpectedly, resetting state');
                            resetTerminalResources();
                            window.location.reload();
                        }
                        break;

                    case 'tabCreated':
                        // バックエンドからのタブ作成通知
                        if (message.tab) {
                            const tab = message.tab;
                            tabState.tabs.push(tab);
                            createTabUI(tab);
                            createTerminalPane(tab.id);
                            switchToTab(tab.id);
                            initializeTerminal(tab.id);
                        }
                        break;

                    case 'tabList':
                        // バックエンドからのタブリスト復元
                        if (message.tabs && message.tabs.length > 0) {
                            log('[GLOBAL] Restoring tabs:', message.tabs.length);
                            message.tabs.forEach(tab => {
                                tabState.tabs.push(tab);
                                createTabUI(tab);
                                createTerminalPane(tab.id);
                            });
                            if (message.activeTabId) {
                                switchToTab(message.activeTabId);
                                initializeTerminal(message.activeTabId);
                            }
                        }
                        break;

                    case 'tabClosed':
                        // バックエンドからのタブ閉じ通知
                        if (message.tabId) {
                            log('[GLOBAL] Tab closed by backend:', message.tabId);
                            closeTabUI(message.tabId);
                        }
                        break;

                    case 'tabProcessExited':
                        // プロセス終了によるタブ閉じ（Ctrl-D等）
                        if (message.tabId) {
                            log('[GLOBAL] Process exited, closing tab:', message.tabId);
                            closeTabUI(message.tabId);
                        }
                        break;

                    case 'bufferCleanupCompleted':
                        log('[BUFFER CLEANUP] Received cleanup completion notification', {
                            success: message.success,
                            timestamp: message.timestamp,
                            error: message.error
                        });
                        break;

                    case 'sendTextToEditor':
                        if (editorState.editor && message.text) {
                            editorState.editor.insert(message.text);
                            editorState.editor.focus();
                        }
                        break;

                    case 'extractToTodosResult':
                        if (message.success && editorState.editor) {
                            const reference = `See [@${message.filePath}]`;
                            editorState.editor.setValue(reference, -1);
                            log('[EXTRACT] Editor content replaced with reference:', reference);
                        } else if (!message.success) {
                            log('[EXTRACT] Failed to write TODOS.md:', message.error);
                        }
                        break;
                }
            };
            window.addEventListener('message', globalMessageHandler);
            tabState.globalEventListeners.push({ element: window, event: 'message', handler: globalMessageHandler });

            // ボタンイベントの設定
            const btnSendSelection = document.getElementById('btn-send-selection');
            if (btnSendSelection) {
                btnSendSelection.addEventListener('click', () => {
                    vscode.postMessage({ type: 'buttonSendSelection', tabId: tabState.activeTabId });
                    const activeTermState = getActiveTerminalState();
                    if (activeTermState && activeTermState.term) {
                        activeTermState.term.focus();
                    }
                });
            }

            const btnCopySelection = document.getElementById('btn-copy-selection');
            if (btnCopySelection) {
                btnCopySelection.addEventListener('click', () => {
                    vscode.postMessage({ type: 'buttonCopySelection', tabId: tabState.activeTabId });
                    btnCopySelection.classList.add('done');
                    setTimeout(() => btnCopySelection.classList.remove('done'), 2000);
                    const activeTermState = getActiveTerminalState();
                    if (activeTermState && activeTermState.term) {
                        activeTermState.term.focus();
                    }
                });
            }

            const btnScrollToBottom = document.getElementById('btn-scroll-to-bottom');
            if (btnScrollToBottom) {
                btnScrollToBottom.addEventListener('click', () => {
                    const activeTermState = getActiveTerminalState();
                    if (activeTermState && activeTermState.term) {
                        activeTermState.term.scrollToBottom();
                        activeTermState.term.focus();
                    }
                });
            }

            const btnExtractToTodos = document.getElementById('btn-extract-to-todos');
            if (btnExtractToTodos) {
                btnExtractToTodos.addEventListener('click', () => {
                    if (!editorState.editor) return;
                    const content = editorState.editor.getValue();
                    if (!content.trim() || content.split('\n').length <= 1) return;
                    vscode.postMessage({ type: 'extractToTodos', data: content });
                });
            }

            const btnOpenHistory = document.getElementById('btn-open-history');
            if (btnOpenHistory) {
                btnOpenHistory.addEventListener('click', () => {
                    vscode.postMessage({ type: 'openPromptHistory' });
                });
            }

            // タブバーイベントの設定
            const btnAddTab = document.getElementById('btn-add-tab');
            if (btnAddTab) {
                btnAddTab.addEventListener('click', () => {
                    log('[TAB] Add tab button clicked');
                    vscode.postMessage({ type: 'createTab' });
                });
            }

            // タブリストのクリックイベント（イベント委譲）
            const tabList = document.getElementById('tab-list');
            if (tabList) {
                tabList.addEventListener('click', (event) => {
                    const tabElement = event.target.closest('.tab');
                    if (!tabElement) return;

                    const tabId = tabElement.dataset.tabId;
                    if (!tabId) return;

                    // 閉じるボタンがクリックされた場合
                    if (event.target.closest('.tab-close')) {
                        log('[TAB] Close button clicked for tab:', tabId);
                        vscode.postMessage({ type: 'closeTab', tabId: tabId });
                        return;
                    }

                    // タブ本体がクリックされた場合
                    if (tabId !== tabState.activeTabId) {
                        log('[TAB] Tab clicked:', tabId);
                        switchToTab(tabId);
                        vscode.postMessage({ type: 'switchTab', tabId: tabId });
                    }
                });
            }

            log('[GLOBAL] Global handlers initialized');
        }

        // 新しいタブを作成するヘルパー関数
        let nextTabNumber = 1;
        function createNewTab() {
            const tabId = 'tab-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            const tab = {
                id: tabId,
                title: 'Terminal ' + nextTabNumber++
            };
            tabState.tabs.push(tab);
            createTabUI(tab);
            createTerminalPane(tab.id);
            switchToTab(tab.id);
            return tabId;
        }

        // ターミナル初期化関数（タブ対応）
        function initializeTerminal(tabId) {
            // タブ固有の状態を取得または作成
            let state = tabState.terminalStates.get(tabId);
            if (!state) {
                state = createTerminalState();
                tabState.terminalStates.set(tabId, state);
            }

            try {
                // 重複初期化を厳密にチェック
                if (state.isInitialized) {
                    log('[INIT] Terminal for tab', tabId, 'is already initialized, skipping');

                    // 既に初期化済みの場合は、サイズ調整とフォーカスのみ実行
                    if (state.term) {
                        setTimeout(() => {
                            setTerminalSize(tabId);
                            state.term.focus();
                        }, 50);
                    }
                    return;
                }

                // CSS変数をデバッグ
                log(`[INIT] CSS Variables: vscode-sideBar-background:${document.documentElement.style.getPropertyValue('--vscode-sideBar-background')}, vscode-terminal-foreground:${document.documentElement.style.getPropertyValue('--vscode-terminal-foreground')}, vscode-terminal-background:${document.documentElement.style.getPropertyValue('--vscode-terminal-background')}`);

                // 二重初期化を防ぐため、最初にフラグを立てる
                state.isInitialized = true;

                log('[INIT] Starting terminal initialization for tab:', tabId);

                if (typeof Terminal === 'undefined') {
                    throw new Error('Terminal is not defined. xterm.js may not have loaded.');
                }

                state.term = new Terminal({
                    theme: {
                        // ↓ おそらく、ターミナル内で上書きされる
                        // background: 'var(--vscode-sideBar-background)',
                        background: document.documentElement.style.getPropertyValue('--vscode-sideBar-background') || '#111111',
                        foreground: document.documentElement.style.getPropertyValue('--vscode-terminal-foreground') || '#ffffff',
                        cursor: document.documentElement.style.getPropertyValue('--vscode-terminal-cursor-foreground') || '#ffffff',
                        selection: document.documentElement.style.getPropertyValue('--vscode-terminal-selection-background') || '#ffffff'
                    },
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    fontSize: 13,
                    letterSpacing: 0,
                    lineHeight: 1.2,
                    cursorBlink: false,
                    smoothScrollDuration: 0,  // スムーズスクロールを無効化（パフォーマンス向上）
                    convertEol: true,
                    allowProposedApi: true,
                    allowTransparency: false,
                    minimumContrastRatio: 1,
                    // ペーストをアプリに「まとまり」として伝える
                    bracketedPasteMode: true,
                    // スクロールバック上限を設定（大きな履歴での write/render 負荷を軽減）
                    scrollback: MAX_BUFFER_LINES
                });

                const terminalElement = document.getElementById('terminal-pane-' + tabId);
                state.term.open(terminalElement);

                // Map にも登録
                tabState.terminals.set(tabId, state.term);

                // 2秒ごとにスクロール位置をチェックし、最上部なら最下部にスクロール
                const scrollCheckInterval = setInterval(() => {
                    if (!state.term || !state.term.buffer || !state.term.buffer.active) {
                        return;
                    }
                    const buffer = state.term.buffer.active;
                    // スクロール位置が厳密に0(最上部)の時のみ
                    if (buffer.viewportY === 0) {
                        state.term.scrollToBottom();
                    }
                }, 2000);

                // タイマーを管理対象に追加
                state.timers.scrollCheck = scrollCheckInterval;
                log('[LEAK CHECK] Added scroll position check interval (2000ms)');

                // Unicode 11 アドオンをロード
                if (typeof Unicode11Addon !== 'undefined') {
                    try {
                        const unicode11 = new Unicode11Addon.Unicode11Addon();
                        state.term.loadAddon(unicode11);
                        unicode11.activate(state.term);
                        log('[LEAK CHECK] Unicode11 addon loaded');

                        state.addons.push(unicode11);
                    } catch (error) {
                        log('Failed to load Unicode 11 addon:', error);
                    }
                }

                // WebGL アドオンをロード
                if (typeof WebglAddon !== 'undefined') {
                    try {
                        const webgl = new WebglAddon.WebglAddon();

                        // WebGL context loss のハンドリング
                        webgl.onContextLoss(() => {
                            log('[RENDERER] WebGL context lost!');
                            webgl.dispose();
                        });

                        state.term.loadAddon(webgl);
                        log('[RENDERER] WebGL addon loaded successfully');

                        state.addons.push(webgl);
                    } catch (error) {
                        log('[RENDERER] Failed to load WebGL addon:', error);
                        throw error;
                    }
                } else {
                    throw new Error('WebglAddon is not defined');
                }

                // ターミナル要素のサイズが確定するまで待機
                function waitForSize() {
                    return new Promise((resolve) => {
                        const checkSize = () => {
                            const rect = terminalElement.getBoundingClientRect();
                            if (rect.width > 0 && rect.height > 0) {

                                resolve();
                            } else {
                                setTimeout(checkSize, 10);
                            }
                        };
                        checkSize();
                    });
                }

                // サイズ確定後に初期設定
                waitForSize().then(() => {
                    // 初期サイズ設定
                    setTerminalSize(tabId);

                });

                // ウィンドウリサイズ時の処理（グローバル - 全タブに適用）
                if (!tabState.resizeObserver) {
                    const windowResizeHandler = () => {
                        // アクティブなタブのみリサイズ
                        if (tabState.activeTabId) {
                            setTimeout(() => setTerminalSize(tabState.activeTabId), 50);
                        }
                    };
                    window.addEventListener('resize', windowResizeHandler);
                    tabState.globalEventListeners.push({ element: window, event: 'resize', handler: windowResizeHandler });

                    // ResizeObserver でコンテナサイズ変更を監視（グローバル）
                    let lastResizeTime = 0;

                    tabState.resizeObserver = new ResizeObserver((entries) => {
                        const now = Date.now();

                        // デバウンス処理：連続する resize を制限
                        if (now - lastResizeTime < 100) {
                            return;
                        }

                        if (entries.length > 0) {
                            lastResizeTime = now;

                            // アクティブなタブのみリサイズ
                            if (tabState.activeTabId) {
                                setTimeout(() => setTerminalSize(tabState.activeTabId), 30);
                            }
                        }
                    });

                    // terminal-panes コンテナを監視
                    const panesContainer = document.getElementById('terminal-panes');
                    if (panesContainer) {
                        tabState.resizeObserver.observe(panesContainer);
                    }
                }

                // 定期的なサイズチェック（VSCode の制約対応）
                setTimeout(() => {
                    setTerminalSize(tabId);
                }, 2000);

                // CLI エージェントインジケーターの表示更新
                function updateCliAgentIndicator() {
                    const indicator = document.getElementById('cli-agent-indicator');
                    if (indicator) {
                        if (state.cliAgentState.active) {
                            indicator.classList.add('active');
                            // エージェント種別に応じたラベル表示
                            if (state.cliAgentState.agent_type === 'claude') {
                                indicator.textContent = 'Claude';
                                indicator.title = 'Claude is active - Shift+Enter inputs a newline';
                            } else if (state.cliAgentState.agent_type === 'gemini') {
                                indicator.textContent = 'Gemini';
                                indicator.title = 'Gemini is active - Shift+Enter inputs a newline';
                            } else if (state.cliAgentState.agent_type === 'codex') {
                                indicator.textContent = 'Codex';
                                indicator.title = 'Codex is active - Shift+Enter sends Ctrl+J';
                            } else {
                                indicator.textContent = 'CLI Agent';
                                indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                            }
                        } else {
                            indicator.classList.remove('active');
                            indicator.textContent = 'CLI Agent';
                            indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                        }
                    }
                }

                // ステータスメッセージの処理（このタブ用）
                function handleStatusMessage(data) {
                    try {
                        // CSI シーケンス ]777; で始まるメッセージを処理（実際のESC文字を検索）
                        if (data.includes('\x1b]777;')) {
                            // 複数のエスケープシーケンスに対応するため matchAll を使用
                            const matches = data.matchAll(/\x1b\]777;(.+?)\x07/g);
                            const matchesArray = [...matches];

                            for (const match of matchesArray) {
                                try {
                                    const messageJson = match[1];
                                    const message = JSON.parse(messageJson);

                                    if (message.type === 'cli_agent_status') {
                                        state.cliAgentState = message.data;
                                        // アクティブタブの場合のみインジケーター更新
                                        if (tabState.activeTabId === tabId) {
                                            updateCliAgentIndicator();
                                        }
                                    }

                                    if (message.type === 'log') {
                                        // Python からのログメッセージを VSCode 側に転送
                                        vscode.postMessage({
                                            type: 'log',
                                            message: `[pty-shell.py] ${message.data}`
                                        });
                                    }
                                } catch (parseError) {
                                    // 個別メッセージのパースエラーは無視
                                    log('Individual message parse error:', parseError);
                                }
                            }
                        }
                    } catch (error) {
                        // JSON パースエラーは無視
                        log('Status message parse error:', error);
                    }
                }

                // handleStatusMessage を state に保存（output 処理で使用）
                state.handleStatusMessage = handleStatusMessage;

                // Shift + Enter を Alt + Enter に変換するキーハンドラー
                try {
                    if (typeof state.term.attachCustomKeyEventHandler === 'function') {
                        state.term.attachCustomKeyEventHandler(function (event) {
                            // ESC キーの処理（vim など対応）
                            if (event.type === 'keydown' && event.key === 'Escape') {
                                // ブラウザのデフォルト動作を完全に停止
                                event.preventDefault();
                                event.stopPropagation();

                                // 正しいエスケープシーケンスを送信（tabId を含める）
                                vscode.postMessage({
                                    type: 'terminalInput',
                                    tabId: tabId,
                                    data: '\x1b'  // ESC文字（ASCII 27）を確実に送信
                                });

                                // false を返してデフォルト処理を完全に停止
                                return false;
                            }

                            // Shift + Enter の場合（CLI エージェントが動作中のときのみ）
                            if (event.type === 'keydown' &&
                                event.key === 'Enter' &&
                                event.shiftKey &&
                                !event.ctrlKey &&
                                !event.altKey &&
                                !event.metaKey) {

                                // CLI エージェント（Claude/Gemini）がアクティブの場合のみ Alt+Enter に変換
                                if (state.cliAgentState.active) {
                                    const agentType = state.cliAgentState.agent_type || 'CLI Agent';
                                    // ブラウザのデフォルト動作を完全に停止
                                    event.preventDefault();
                                    event.stopPropagation();

                                    if (agentType === 'codex') {
                                        // Codex モード: Ctrl+J をエミュレーション (LF)
                                        const ctrlJ = '\n';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            tabId: tabId,
                                            data: ctrlJ
                                        });
                                    } else {
                                        // 既存エージェント(Claude/Gemini): Alt+Enter を送信 (ESC + CR)
                                        const altEnterSequence = '\x1b\r';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            tabId: tabId,
                                            data: altEnterSequence
                                        });
                                    }

                                    // false を返してデフォルト処理を完全に停止
                                    return false;
                                } else {
                                    // CLI エージェントがアクティブでない場合は通常の Enter として処理
                                    return true;
                                }
                            }

                            // その他のキーはデフォルト処理を継続
                            return true;
                        });
                    } else {
                        log('attachCustomKeyEventHandler is not available');
                    }
                } catch (error) {
                    log('Failed to attach custom key handler:', error);
                }

                // onData のリスナーを保存して後で dispose できるようにする
                const dataListener = state.term.onData((data) => {
                    vscode.postMessage({
                        type: 'terminalInput',
                        tabId: tabId,
                        data: data
                    });
                });

                // dataListener を管理対象に追加
                state.xtermListeners.push(dataListener);
                log('[LEAK CHECK] Added onData listener for tab:', tabId);

                // ペーストイベントハンドラー（DOM イベントを使用）
                const pasteHandler = (event) => {
                    // デフォルトのペースト処理を阻止
                    event.preventDefault();

                    // クリップボードからデータを取得
                    const clipboardData = event.clipboardData || window.clipboardData;
                    if (clipboardData && clipboardData.getData) {
                        const pastedText = clipboardData.getData('text');
                        if (pastedText) {
                            log('[PASTE] Intercepted paste event, length:', pastedText.length);
                            // 大量ペースト時はチャンク送信でフロー制御
                            sendBytesInChunks(new TextEncoder().encode(pastedText), { kind: 'paste' });
                        }
                    }
                };

                // ターミナル要素にペーストリスナーを追加（タブ固有）
                addManagedEventListener(terminalElement, 'paste', pasteHandler, state);
                log('[LEAK CHECK] Added DOM paste listener for tab:', tabId);

                // メッセージハンドラと button ハンドラは initializeGlobalHandlers で登録済み

                // 定期的なバッファクリア機能を設定
                setupPeriodicBufferCleanup();

                // 初期化完了フラグは既に設定済み (state.isInitialized = true)

                // 入力フォーカスを明示的に与える
                if (state.term) {
                    state.term.focus();
                }

                // VSCode 側に準備完了を通知（これをトリガにシェルを起動）
                vscode.postMessage({ type: 'tabReady', tabId: tabId });

            } catch (error) {
                log('Error initializing terminal:', error);
                vscode.postMessage({ type: 'error', error: error.message });
                const pane = document.getElementById(`terminal-pane-${tabId}`);
                if (pane) {
                    pane.innerHTML = '<p style="color: red;">Error loading terminal: ' + error.message + '</p>';
                }
            }
        }

        // グローバルハンドラを初期化
        initializeGlobalHandlers();

        // 最初のタブを作成してターミナル初期化を実行
        const firstTabId = createNewTab();
        initializeTerminal(firstTabId);

        // ACE エディタ初期化を実行
        setTimeout(() => {
            log('[ACE] Attempting to initialize editor...');
            initializeAceEditor();
            // 初期化後の確認
            if (editorState.editor) {
                log('[ACE] Editor successfully initialized, testing keybindings...');
                const commands = editorState.editor.commands.byName;
                if (commands.sendToTerminal) {
                    log('[ACE] sendToTerminal command is registered');
                } else {
                    log('[ACE] sendToTerminal command NOT found!');
                }
            } else {
                log('[ACE] Editor initialization failed!');
            }
        }, 100);

    </script>
</body>

</html>