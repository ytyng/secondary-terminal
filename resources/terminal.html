<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src {{CSP_SOURCE}} 'unsafe-inline'; script-src {{CSP_SOURCE}} 'unsafe-inline';">
    <title>Secondary Terminal</title>
    <link rel="stylesheet" href="{{XTERM_CSS_URI}}" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            height: 100%;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }
        body {
            width: 100%;
            height: 100vh;
            padding: 0;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-editor-foreground);
            font-family: "RobotoMono Nerd Font Mono", "Roboto Mono", Consolas, "Courier New", monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-container {
            flex: 1;
            width: 100%;
            height: 100%;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        #terminal {
            flex: 1;
            width: 100%;
            height: 100%;
        }
        .terminal.xterm {
            padding: 5px 0 0 5px;
        }

        /* xterm.js „ÅÆ„Ç≥„É≥„ÉÜ„Éä„ÇíÈÄèÊòé„Å´ */
        .xterm .xterm-viewport {
            background-color: transparent !important;
        }

        .xterm .xterm-screen {
            background-color: transparent !important;
        }

        .xterm .xterm-helper-textarea {
            background-color: transparent !important;
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div id="terminal"></div>
    </div>

    <script src="{{XTERM_JS_URI}}"></script>
    <script src="{{XTERM_UNICODE11_JS_URI}}"></script>
    <script src="{{XTERM_CANVAS_JS_URI}}"></script>
    <script>
        const vscode = acquireVsCodeApi();

        try {
            console.log('Initializing terminal...');

            if (typeof Terminal === 'undefined') {
                throw new Error('Terminal is not defined. xterm.js may not have loaded.');
            }

            // „Ç¢„Éâ„Ç™„É≥„ÅÆÂèØÁî®ÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            console.log('Checking addons availability:');
            console.log('Unicode11Addon available:', typeof Unicode11Addon !== 'undefined');
            console.log('CanvasAddon available:', typeof CanvasAddon !== 'undefined');

            // Áã¨Ëá™„ÅÆ wcwidth Èñ¢Êï∞„ÇíÂÆöÁæ©
            const customWcwidth = (codepoint) => {
                // ÁµµÊñáÂ≠ó„ÅÆÁØÑÂõ≤
                if ((codepoint >= 0x1F300 && codepoint <= 0x1F9FF) || // Emoticons, symbols
                    (codepoint >= 0x2600 && codepoint <= 0x26FF) ||   // Miscellaneous Symbols
                    (codepoint >= 0x2700 && codepoint <= 0x27BF) ||   // Dingbats
                    (codepoint >= 0x1F000 && codepoint <= 0x1F02F) || // Mahjong tiles, dominos
                    (codepoint >= 0x1F0A0 && codepoint <= 0x1F0FF) || // Playing cards
                    (codepoint >= 0x1F100 && codepoint <= 0x1F1FF) || // Enclosed characters
                    (codepoint >= 0x1F200 && codepoint <= 0x1F2FF) || // Enclosed ideographs
                    (codepoint >= 0x1F600 && codepoint <= 0x1F64F) || // Emoticons
                    (codepoint >= 0x1F680 && codepoint <= 0x1F6FF) || // Transport symbols
                    (codepoint >= 0x1F900 && codepoint <= 0x1F9FF) || // Supplemental symbols
                    (codepoint >= 0x1F1E6 && codepoint <= 0x1F1FF)) { // Regional indicator symbols (flags)
                    return 2; // ÂÖ®ËßíÂπÖ
                }
                
                // Êó•Êú¨Ë™û„Å™„Å©„ÅÆÂÖ®ËßíÊñáÂ≠ó
                if ((codepoint >= 0x3000 && codepoint <= 0x303F) || // CJK symbols
                    (codepoint >= 0x3040 && codepoint <= 0x309F) || // Hiragana
                    (codepoint >= 0x30A0 && codepoint <= 0x30FF) || // Katakana
                    (codepoint >= 0x4E00 && codepoint <= 0x9FFF) || // CJK ideographs
                    (codepoint >= 0xFF00 && codepoint <= 0xFFEF)) { // Halfwidth/Fullwidth
                    return 2; // ÂÖ®ËßíÂπÖ
                }
                
                // „Çº„É≠ÂπÖÊñáÂ≠ó
                if ((codepoint >= 0x200B && codepoint <= 0x200F) || // Zero width characters
                    (codepoint >= 0x2028 && codepoint <= 0x202E) || // Line/paragraph separator
                    (codepoint >= 0x2060 && codepoint <= 0x2064)) { // Word joiner, etc.
                    return 0;
                }
                
                return 1; // „Éá„Éï„Ç©„É´„Éà„ÅØÂçäËßíÂπÖ
            };

            const term = new Terminal({
            theme: {
                background: 'transparent',
                foreground: 'var(--vscode-terminal-foreground)',
                cursor: 'var(--vscode-terminal-cursor-foreground)',
                selection: 'var(--vscode-terminal-selection-background)'
            },
            fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
            fontSize: 13,
            letterSpacing: 0,
            lineHeight: 1.2,
            cursorBlink: true,
            convertEol: true,
            allowProposedApi: true,
            allowTransparency: false,
            minimumContrastRatio: 1,
            // VSCode ‰∫íÊèõ„ÅÆË®≠ÂÆö
            rescaleOverlappingGlyphs: true, // ÈáçË§á„Åô„Çã„Ç∞„É™„Éï„Çí„É™„Çπ„Ç±„Éº„É´
            customGlyphs: true, // „Ç´„Çπ„Çø„É†„Ç∞„É™„Éï„ÇíÊúâÂäπÂåñ
            // Áã¨Ëá™„ÅÆ wcwidth Èñ¢Êï∞„Çí‰ΩøÁî®
            wcwidth: customWcwidth
        });

        const terminalElement = document.getElementById('terminal');
        term.open(terminalElement);

        // „Çø„Éº„Éü„Éä„É´ÂàùÊúüÂåñÂæå„Å´ wcwidth „ÇíÁõ¥Êé•Ë®≠ÂÆö
        console.log('Setting up custom wcwidth...');
        if (term.unicode) {
            console.log('Terminal unicode object exists:', term.unicode);
            // Unicode 11 „Ç¢„Éâ„Ç™„É≥„ÅÆ wcwidth „Çí‰∏äÊõ∏„Åç
            const originalWcwidth = term.unicode.wcwidth;
            term.unicode.wcwidth = customWcwidth;
            console.log('Custom wcwidth function set');
        } else {
            console.warn('Terminal unicode object not available');
        }

        // Unicode 11 „Ç¢„Éâ„Ç™„É≥„Çí„É≠„Éº„Éâ
        if (typeof Unicode11Addon !== 'undefined') {
            console.log('Loading Unicode 11 addon...');
            try {
                const unicode11 = new Unicode11Addon.Unicode11Addon();
                term.loadAddon(unicode11);
                console.log('Unicode 11 addon loaded');
                
                // „Çø„Éº„Éü„Éä„É´„ÅåÈñã„Åã„Çå„ÅüÂæå„Å´ activate
                setTimeout(() => {
                    try {
                        unicode11.activate(term);
                        console.log('Unicode 11 addon activated successfully');
                        console.log('Terminal unicode object:', term.unicode);
                        
                        // Unicode 11 „Ç¢„Éâ„Ç™„É≥„ÅÆ wcwidth „Çí‰∏äÊõ∏„Åç
                        if (term.unicode) {
                            term.unicode.wcwidth = customWcwidth;
                            console.log('Unicode 11 wcwidth overridden with custom function');
                        }
                        
                        // Canvas „É¨„É≥„ÉÄ„É©„Éº„ÅÆÊñáÂ≠óÂπÖË®àÁÆó„Çí‰øÆÊ≠£
                        if (term._core && term._core._renderService) {
                            console.log('Attempting to fix Canvas renderer character width...');
                            const originalMeasureText = term._core._renderService._charAtlas ? 
                                term._core._renderService._charAtlas._ctx?.measureText : null;
                            
                            if (originalMeasureText) {
                                console.log('Overriding Canvas measureText for emoji width...');
                            }
                        }
                        
                        // ÁµµÊñáÂ≠óÂπÖ„ÉÜ„Çπ„Éà„ÇíÂÜçÂÆüË°å
                        window.testEmojiWidth();
                    } catch (activateError) {
                        console.error('Failed to activate Unicode 11 addon:', activateError);
                    }
                }, 500);
            } catch (error) {
                console.error('Failed to load Unicode 11 addon:', error);
            }
        } else {
            console.error('Unicode11Addon is not available - check if script loaded correctly');
        }

        // Canvas „Ç¢„Éâ„Ç™„É≥„Çí„É≠„Éº„ÉâÔºàÁµµÊñáÂ≠óË°®Á§∫„ÅÆ„Åü„ÇÅÔºâ
        if (typeof CanvasAddon !== 'undefined') {
            console.log('Loading Canvas addon...');
            try {
                const canvas = new CanvasAddon.CanvasAddon();
                term.loadAddon(canvas);
                console.log('Canvas addon loaded successfully');
                
                // Canvas „Ç¢„Éâ„Ç™„É≥„ÅåÊ≠£„Åó„ÅèÊñáÂ≠óÂπÖ„ÇíË®àÁÆó„Åô„Çã„Çà„ÅÜ„Å´Ë®≠ÂÆö
                setTimeout(() => {
                    if (term._core && term._core._charSizeService) {
                        console.log('Configuring Canvas character size measurement...');
                        // Canvas „ÅÆÊñáÂ≠óÂπÖÊ∏¨ÂÆö„ÇíÂº∑Âà∂ÁöÑ„Å´Êõ¥Êñ∞
                        term._core._charSizeService.measure();
                    }
                }, 1000);
            } catch (error) {
                console.error('Failed to load Canvas addon:', error);
            }
        } else {
            console.error('CanvasAddon is not available - check if script loaded correctly');
        }

        // „Çø„Éº„Éü„Éä„É´Ë¶ÅÁ¥†„ÅÆ„Çµ„Ç§„Ç∫„ÅåÁ¢∫ÂÆö„Åô„Çã„Åæ„ÅßÂæÖÊ©ü
        function waitForSize() {
            return new Promise((resolve) => {
                const checkSize = () => {
                    const rect = terminalElement.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        console.log('Terminal element size confirmed:', rect.width, 'x', rect.height);
                        resolve();
                    } else {
                        setTimeout(checkSize, 10);
                    }
                };
                checkSize();
            });
        }

        // „Çµ„Ç§„Ç∫Á¢∫ÂÆöÂæå„Å´ÂàùÊúüË®≠ÂÆö
        waitForSize().then(() => {
            // ÂàùÊúü„Çµ„Ç§„Ç∫Ë®≠ÂÆö
            setTerminalSize();
            console.log('Terminal initialized with DOM renderer');

            console.log('Terminal initialized with addons');
        });

        // „Çø„Éº„Éü„Éä„É´„Çµ„Ç§„Ç∫„ÇíÂãïÁöÑ„Å´Ë®≠ÂÆöÔºàÂÖÉ„ÅÆÊâãÂãïË®àÁÆóÊñπÂºèÔºâ
        function setTerminalSize() {
            const container = document.querySelector('.terminal-container');
            const terminal = document.getElementById('terminal');

            if (!container || !terminal) {
                console.warn('Terminal container not found');
                return;
            }

            // „Ç≥„É≥„ÉÜ„Éä„ÅÆÂÆüÈöõ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
            const containerRect = container.getBoundingClientRect();
            const availableWidth = Math.max(containerRect.width - 20, 300); // „Éë„Éá„Ç£„É≥„Ç∞ËÄÉÊÖÆ
            const availableHeight = Math.max(containerRect.height - 20, 200); // „Éë„Éá„Ç£„É≥„Ç∞ËÄÉÊÖÆ

            console.log('Container size:', availableWidth, 'x', availableHeight);

            // „Éï„Ç©„É≥„ÉàÊÉÖÂ†±„Åã„ÇâÊñáÂ≠ó„Çµ„Ç§„Ç∫„ÇíÊ≠£Á¢∫„Å´Ë®àÁÆó
            const fontSize = 13;
            const targetLineHeight = 1.2; // TerminalË®≠ÂÆö„Å®Âêå„ÅòË°åÈñì

            // ‰∏ÄÊôÇÁöÑ„Å™Ê∏¨ÂÆöÁî®„Ç®„É¨„É°„É≥„Éà„Çí‰ΩúÊàê„Åó„Å¶ÊñáÂ≠óÂπÖ„ÇíÊ≠£Á¢∫„Å´Ê∏¨ÂÆö
            const measurer = document.createElement('div');
            measurer.style.position = 'absolute';
            measurer.style.visibility = 'hidden';
            measurer.style.fontFamily = '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace';
            measurer.style.fontSize = fontSize + 'px';
            measurer.style.lineHeight = targetLineHeight; // Êï∞ÂÄ§„ÅßÊåáÂÆö
            measurer.style.whiteSpace = 'pre';
            measurer.textContent = 'M'.repeat(10); // Á≠âÂπÖ„Éï„Ç©„É≥„Éà„ÅÆMÊñáÂ≠ó„ÅßÊ∏¨ÂÆö

            document.body.appendChild(measurer);
            const rawCharWidth = measurer.getBoundingClientRect().width / 10;
            const rawLineHeight = measurer.getBoundingClientRect().height;
            document.body.removeChild(measurer);

            // „Çµ„Ç§„Ç∫Ë™øÊï¥‰øÇÊï∞ÔºàÂæÆË™øÊï¥Áî®Ôºâ
            const widthAdjustment = 0.88; // Ê®™ÂπÖ„ÇíÂ∞ë„ÅóË©∞„ÇÅ„ÇãÔºàÂè≥‰ΩôÁôΩ„ÇíÊ∏õ„Çâ„ÅôÔºâ
            const heightAdjustment = 1.34; // Á∏¶ÂπÖ„ÇíÂ∞ë„ÅóË©∞„ÇÅ„ÇãÔºà„ÅØ„ÅøÂá∫„ÅóÈò≤Ê≠¢Ôºâ

            const adjustedCharWidth = rawCharWidth * widthAdjustment;
            const adjustedLineHeight = rawLineHeight * heightAdjustment;

            // ÂàóÊï∞„Å®Ë°åÊï∞„ÇíË®àÁÆó
            const cols = Math.floor(availableWidth / adjustedCharWidth);
            const rows = Math.floor(availableHeight / adjustedLineHeight);

            console.log('Font metrics - rawCharWidth:', rawCharWidth, 'rawLineHeight:', rawLineHeight);
            console.log('Adjusted metrics - charWidth:', adjustedCharWidth, 'lineHeight:', adjustedLineHeight);
            console.log('Calculated terminal size:', cols, 'x', rows);

            // ÊúÄÂ∞è„Çµ„Ç§„Ç∫„Çí‰øùË®º
            const finalCols = Math.max(cols, 20);
            const finalRows = Math.max(rows, 5);

            // „Çø„Éº„Éü„Éä„É´„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö
            if (term.cols !== finalCols || term.rows !== finalRows) {
                term.resize(finalCols, finalRows);

                // „Çµ„Ç§„Ç∫Â§âÊõ¥„Çí VSCode „Å´ÈÄöÁü•
                vscode.postMessage({
                    type: 'resize',
                    cols: finalCols,
                    rows: finalRows
                });

                console.log('Terminal resized to:', finalCols, 'x', finalRows);
            }
        }

        // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÊôÇ„ÅÆÂá¶ÁêÜ
        window.addEventListener('resize', () => {
            setTimeout(setTerminalSize, 50);
        });

        // ResizeObserver „Åß„Ç≥„É≥„ÉÜ„Éä„Çµ„Ç§„Ç∫Â§âÊõ¥„ÇíÁõ£Ë¶ñ
        const resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
                console.log('Container resized:', entry.contentRect.width, 'x', entry.contentRect.height);
                setTimeout(setTerminalSize, 50);
            }
        });

        // terminal-container „ÇíÁõ£Ë¶ñ
        const container = document.querySelector('.terminal-container');
        if (container) {
            resizeObserver.observe(container);
        }

        // ÂÆöÊúüÁöÑ„Å™„Çµ„Ç§„Ç∫„ÉÅ„Çß„ÉÉ„ÇØÔºàVSCode „ÅÆÂà∂Á¥ÑÂØæÂøúÔºâ
        setInterval(setTerminalSize, 2000);

        let claudeCodeActive = false; // Claude Code „ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖã

        // „Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂá¶ÁêÜ
        function handleStatusMessage(data) {
            try {
                // CSI „Ç∑„Éº„Ç±„É≥„Çπ ]777; „ÅßÂßã„Åæ„Çã„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂá¶ÁêÜÔºàÂÆüÈöõ„ÅÆESCÊñáÂ≠ó„ÇíÊ§úÁ¥¢Ôºâ
                if (data.includes('\x1b]777;')) {
                    const match = data.match(/\x1b\]777;(.+?)\x07/);
                    if (match) {
                        const messageJson = match[1];
                        const message = JSON.parse(messageJson);

                        if (message.type === 'claude_status') {
                            claudeCodeActive = message.data.active;
                            console.log('Claude Code active status changed:', claudeCodeActive);
                        }
                    }
                }
            } catch (error) {
                // JSON „Éë„Éº„Çπ„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
                console.debug('Status message parse error:', error);
            }
        }

        // Shift + Enter „Çí Alt + Enter „Å´Â§âÊèõ„Åô„Çã„Ç≠„Éº„Éè„É≥„Éâ„É©„Éº
        try {
            if (typeof term.attachCustomKeyEventHandler === 'function') {
                console.log('Setting up custom key handler for Shift+Enter');

                term.attachCustomKeyEventHandler(function(event) {
                    // Shift + Enter „ÅÆÂ†¥ÂêàÔºàclaude code „ÅåÂãï‰Ωú‰∏≠„ÅÆ„Å®„Åç„ÅÆ„ÅøÔºâ
                    if (event.type === 'keydown' &&
                        event.key === 'Enter' &&
                        event.shiftKey &&
                        !event.ctrlKey &&
                        !event.altKey &&
                        !event.metaKey) {

                        // Claude Code „Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„ÅÆÂ†¥Âêà„ÅÆ„Åø Alt+Enter „Å´Â§âÊèõ
                        if (claudeCodeActive) {
                            console.log('Shift+Enter detected (Claude Code active), sending Alt+Enter sequence');

                            // „Éñ„É©„Ç¶„Ç∂„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂãï‰Ωú„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                            event.preventDefault();
                            event.stopPropagation();

                            // Alt + Enter „ÅÆÊ≠£„Åó„ÅÑ„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÈÄÅ‰ø°
                            // ESC [ 1 3 ; 3 ~ (Alt+Enter „ÅÆ„Çø„Éº„Éü„Éä„É´„Ç∑„Éº„Ç±„É≥„Çπ)
                            var altEnterSequence = '\x1b\r';

                            vscode.postMessage({
                                type: 'terminalInput',
                                data: altEnterSequence
                            });

                            // false „ÇíËøî„Åó„Å¶„Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜ„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                            return false;
                        } else {
                            // Claude Code „Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Åß„Å™„ÅÑÂ†¥Âêà„ÅØÈÄöÂ∏∏„ÅÆ Enter „Å®„Åó„Å¶Âá¶ÁêÜ
                            console.log('Shift+Enter detected (Claude Code not active), processing as normal Enter');
                            return true;
                        }
                    }

                    // „Åù„ÅÆ‰ªñ„ÅÆ„Ç≠„Éº„ÅØ„Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜ„ÇíÁ∂ôÁ∂ö
                    return true;
                });

                console.log('Custom key handler attached successfully');
            } else {
                console.warn('attachCustomKeyEventHandler is not available');
            }
        } catch (error) {
            console.error('Failed to attach custom key handler:', error);
        }

        term.onData((data) => {
            vscode.postMessage({
                type: 'terminalInput',
                data: data
            });
        });

        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.type) {
                case 'output':
                    // „Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                    handleStatusMessage(message.data);
                    // ÈÄöÂ∏∏„ÅÆÂá∫Âäõ„Å®„Åó„Å¶Êõ∏„ÅçËæº„Åø
                    term.write(message.data);
                    break;
                case 'clear':
                    term.clear();
                    break;
            }
        });

        // ÁµµÊñáÂ≠ó„ÅÆÂπÖ„ÉÜ„Çπ„ÉàÈñ¢Êï∞
        window.testEmojiWidth = function() {
            console.log('Testing emoji width calculation...');
            const testEmojis = ['üòÄ', 'üéâ', 'üë©üèº‚Äçüíª', 'üáØüáµ'];
            testEmojis.forEach(emoji => {
                const codepoint = emoji.codePointAt(0);
                const customWidth = customWcwidth(codepoint);
                console.log(`Emoji ${emoji} (U+${codepoint.toString(16).toUpperCase()}): custom width = ${customWidth}`);
                
                // „Çø„Éº„Éü„Éä„É´ÂÜÖÈÉ®„ÅÆ wcwidth „ÇÇ„ÉÜ„Çπ„Éà
                if (term.unicode && term.unicode.wcwidth) {
                    const terminalWidth = term.unicode.wcwidth(codepoint);
                    console.log(`  Terminal width = ${terminalWidth}`);
                } else {
                    console.log(`  Terminal Unicode wcwidth not available`);
                }
            });
        };

        vscode.postMessage({ type: 'terminalReady' });

        console.log('Terminal initialized successfully');

        } catch (error) {
            console.error('Error initializing terminal:', error);
            vscode.postMessage({ type: 'error', error: error.message });
            document.getElementById('terminal').innerHTML = '<p style="color: red;">Error loading terminal: ' + error.message + '</p>';
        }
    </script>
</body>
</html>
