<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; style-src {{CSP_SOURCE}} 'unsafe-inline'; script-src {{CSP_SOURCE}} 'unsafe-inline';">
    <title>Secondary Terminal</title>
    <link rel="stylesheet" href="{{XTERM_CSS_URI}}" />
    <style>
        /* ========================================
           Reset & Base Styles
           ======================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }

        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-editor-foreground);
            font-family: "RobotoMono Nerd Font Mono", "Roboto Mono", Consolas, "Courier New", monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ========================================
           Terminal Container
           ======================================== */
        .terminal-container {
            flex: 1;
            width: 100%;
            min-height: 0; /* ÈáçË¶ÅÔºöflexbox„ÅßÂ≠êË¶ÅÁ¥†„ÅåÁ∏Æ„ÇÄ„ÅÆ„ÇíË®±ÂèØ */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: var(--vscode-sideBar-background);
        }

        /* ========================================
           xterm.js Overrides
           ======================================== */
        .terminal.xterm {
            padding: 0;

            .xterm-viewport,
            .xterm-screen,
            .xterm-helper-textarea {
                background-color: transparent !important;
            }

            .xterm-selection {
                overflow: hidden; /* „Çπ„ÇØ„É≠„Éº„É´ÊôÇ„Å´ÈÅ∏Êäû„Éè„Ç§„É©„Ç§„Éà„ÅåÊÆã„ÇãÂïèÈ°å„Çí‰øÆÊ≠£ */
            }
        }

        /* ========================================
           Tab Bar
           ======================================== */
        .tab-bar {
            display: flex;
            align-items: center;
            background-color: var(--vscode-tab-activeBackground, #1e1e1e);
            border-bottom: 1px solid var(--vscode-tab-border, #3c3c3c);
            height: 30px;
            flex-shrink: 0;
            overflow: hidden;

            .tab-list {
                display: flex;
                flex: 1;
                overflow-x: auto;
                overflow-y: hidden;
                scrollbar-width: none;

                &::-webkit-scrollbar {
                    display: none;
                }
            }

            .tab {
                display: flex;
                align-items: center;
                padding: 4px 8px;
                background-color: var(--vscode-tab-inactiveBackground, #2d2d2d);
                color: var(--vscode-tab-inactiveForeground, #888);
                border-right: 1px solid var(--vscode-tab-border, #3c3c3c);
                cursor: pointer;
                white-space: nowrap;
                font-size: 12px;
                min-width: 80px;
                max-width: 150px;
                user-select: none;

                &.active {
                    background-color: var(--vscode-tab-activeBackground, #1e1e1e);
                    color: var(--vscode-tab-activeForeground, #fff);

                    .tab-close {
                        display: inline-block;
                    }
                }

                .tab-title {
                    flex: 1;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .tab-close {
                    display: none;
                    margin-left: 6px;
                    background: none;
                    border: none;
                    color: inherit;
                    cursor: pointer;
                    padding: 2px 4px;
                    border-radius: 3px;
                    opacity: 0.6;
                    font-size: 14px;
                    line-height: 1;

                    &:hover {
                        opacity: 1;
                        background-color: var(--vscode-toolbar-hoverBackground, #444);
                    }

                    &:disabled {
                        opacity: 0.3;
                        cursor: not-allowed;
                    }
                }
            }

            .tab-add {
                padding: 4px 12px;
                background: none;
                border: none;
                color: var(--vscode-foreground, #ccc);
                cursor: pointer;
                font-size: 16px;
                flex-shrink: 0;

                &:hover {
                    background-color: var(--vscode-toolbar-hoverBackground, #444);
                }
            }
        }

        /* ========================================
           Terminal Panes
           ======================================== */
        .terminal-panes {
            flex: 1;
            position: relative;
            min-height: 0;

            .empty-state {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: none;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: var(--vscode-descriptionForeground, #888);
                cursor: pointer;
                user-select: none;

                &.visible {
                    display: flex;
                }

                &:hover {
                    .empty-state-icon,
                    .empty-state-text {
                        opacity: 0.7;
                    }
                }

                .empty-state-icon {
                    margin-bottom: 12px;
                    opacity: 0.25;
                }

                .empty-state-text {
                    font-size: 13px;
                    opacity: 0.35;
                }

                .empty-state-version {
                    margin-top: 16px;
                    font-size: 10px;
                    opacity: 0.4;
                }
            }

            .terminal-pane {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: none;
                flex-direction: column;

                &.active {
                    display: flex;
                }

                .terminal-area {
                    flex: 1;
                    min-height: 0;
                    padding: 0 0 0 5px;
                }

                .pane-editor-container {
                    flex-shrink: 0;
                    background-color: var(--vscode-editor-background);
                    border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
                    border-bottom: 1px solid var(--vscode-panel-border, #3c3c3c);
                    height: 200px;
                    overflow: hidden;

                    .ace-editor-instance {
                        width: 100%;
                        height: 100%;
                    }
                }
            }
        }

        /* ========================================
           Control Panel
           ======================================== */
        .control-panel {
            flex-shrink: 0; /* ÈáçË¶ÅÔºöÁ∏Æ„Åæ„Å™„ÅÑ„Çà„ÅÜ„Å´Âõ∫ÂÆö */
            background-color: var(--vscode-panel-background, #252526);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            padding: 2px 6px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: start;
            box-sizing: border-box;

            .control-panel-left-controls,
            .control-panel-right-controls {
                display: flex;
                align-items: center;
                gap: 0.5em;
            }

            .control-panel-left-controls {
                justify-content: start;
                flex-grow: 1;
            }

            .control-panel-right-controls {
                justify-content: end;
                padding: 0.5em;
            }

            .control-button {
                background-color: rgba(255, 255, 255, 0.05);
                color: var(--vscode-button-secondaryForeground, #cccccc);
                border: none;
                border-radius: 3px;
                padding: 3px 6px;
                font-size: 11px;
                cursor: pointer;
                font-family: inherit;
                transition: background-color 0.2s;
                position: relative;

                &:hover {
                    background-color: rgba(255, 255, 255, 0.1);
                }

                /* Custom tooltip - appears instantly on hover */
                &[data-tooltip]::after {
                    content: attr(data-tooltip);
                    position: absolute;
                    bottom: calc(100% + 6px);
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: var(--vscode-editorHoverWidget-background, #252526);
                    color: var(--vscode-editorHoverWidget-foreground, #cccccc);
                    border: 1px solid var(--vscode-editorHoverWidget-border, #454545);
                    padding: 4px 8px;
                    border-radius: 3px;
                    font-size: 11px;
                    white-space: normal;
                    width: max-content;
                    max-width: 250px;
                    text-align: left;
                    z-index: 1000;
                    pointer-events: none;
                    opacity: 0;
                    visibility: hidden;
                    transition: opacity 0.15s, visibility 0.15s;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                    line-height: 1.4;
                }

                &[data-tooltip]:hover::after {
                    opacity: 1;
                    visibility: visible;
                }
            }

            /* .copy-button „ÅØ .control-button „ÇíÊã°ÂºµÔºàHTML „Åß‰∏°Êñπ„ÅÆ„ÇØ„É©„Çπ„ÇíÊåáÂÆöÔºâ */
            .copy-button {
                position: relative;

                &:hover {
                    background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
                }

                &.done {
                    color: transparent;

                    &::after {
                        content: '‚úì';
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: var(--vscode-button-secondaryForeground, #cccccc);
                    }
                }
            }

            .cli-agent-indicator {
                color: #888;
                font-family: inherit;
                font-size: 12px;
                transition: opacity 0.3s ease;
                opacity: 0;

                &.active {
                    opacity: 1;
                }
            }
        }

        /* ========================================
           ACE Editor
           ======================================== */
        /* editor-container „ÅØ .terminal-pane ÂÜÖ„Å´ÁßªÂãïÊ∏à„Åø */

        /* ACE Theme - VSCode Dark */
        .ace-vscode-dark {
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);

            .ace_gutter {
                background-color: var(--vscode-editorGutter-background);
                color: var(--vscode-editorLineNumber-foreground);
                border-right: 1px solid var(--vscode-panel-border, #3c3c3c);
            }

            .ace_gutter-active-line {
                background-color: var(--vscode-editor-lineHighlightBackground);
            }

            .ace_print-margin {
                width: 1px;
                background: var(--vscode-editorRuler-foreground);
            }

            .ace_cursor {
                color: var(--vscode-editorCursor-foreground);
            }

            .ace_marker-layer {
                .ace_selection {
                    background: var(--vscode-editor-selectionBackground);
                }

                .ace_step {
                    background: var(--vscode-debugTokenExpression-number);
                }

                .ace_bracket {
                    margin: -1px 0 0 -1px;
                    border: 1px solid var(--vscode-editorBracketMatch-border);
                    background: var(--vscode-editorBracketMatch-background);
                }

                .ace_active-line {
                    background: var(--vscode-editor-lineHighlightBackground);
                }

                .ace_selected-word {
                    border: 1px solid var(--vscode-editor-selectionHighlightBorder);
                    background: var(--vscode-editor-selectionHighlightBackground);
                }
            }

            &.ace_multiselect .ace_selection.ace_start {
                box-shadow: 0 0 3px 0px var(--vscode-editor-background);
                border-radius: 2px;
            }

            .ace_invisible {
                color: var(--vscode-editorWhitespace-foreground, #404040);
            }

            /* Syntax Highlighting */
            .ace_keyword,
            .ace_meta,
            .ace_storage,
            .ace_storage.ace_type,
            .ace_support.ace_type,
            .ace_support.ace_class {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_keyword.ace_operator {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_constant.ace_character,
            .ace_constant.ace_language,
            .ace_constant.ace_numeric,
            .ace_constant.ace_other,
            .ace_keyword.ace_other.ace_unit,
            .ace_support.ace_constant,
            .ace_variable.ace_parameter {
                color: var(--vscode-debugTokenExpression-number);
            }

            .ace_invalid {
                color: var(--vscode-editorError-foreground);
                background-color: var(--vscode-editorError-background);

                &.ace_deprecated {
                    color: var(--vscode-editorWarning-foreground);
                    background-color: var(--vscode-editorWarning-background);
                }
            }

            .ace_fold {
                background-color: var(--vscode-debugTokenExpression-name);
                border-color: var(--vscode-debugTokenExpression-name);
            }

            .ace_entity.ace_name.ace_function,
            .ace_support.ace_function,
            .ace_variable {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_heading,
            .ace_markup.ace_heading {
                color: var(--vscode-debugTokenExpression-name);
                font-weight: bold;
            }

            .ace_list,
            .ace_markup.ace_list,
            .ace_list.ace_markup {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_punctuation.ace_definition.ace_list_begin {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_entity.ace_name.ace_tag,
            .ace_entity.ace_other.ace_attribute-name,
            .ace_meta.ace_tag,
            .ace_string.ace_regexp {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_comment {
                color: var(--vscode-debugConsole-infoForeground);
                font-style: italic;
            }

            .ace_string {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_indent-guide {
                background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChAGGzJY5NwAAAABJRU5ErkJggg==") right repeat-y;
            }
        }
    </style>
</head>

<body>
    <div class="terminal-container" id="terminal-container">

        <!-- Tab Bar -->
        <div class="tab-bar" id="tab-bar">
            <div class="tab-list" id="tab-list"></div>
            <button class="tab-add" id="btn-add-tab" title="New Terminal">+</button>
        </div>

        <!-- Terminal Panes Container -->
        <div class="terminal-panes" id="terminal-panes">
            <!-- Empty State Placeholder -->
            <div class="empty-state" id="empty-state">
                <svg class="empty-state-icon" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="4" width="18" height="16" rx="2" ry="2"></rect>
                    <polyline points="7 15 10 12 7 9"></polyline>
                    <line x1="13" y1="15" x2="17" y2="15"></line>
                </svg>
                <div class="empty-state-text">Launch New Terminal</div>
                <div class="empty-state-version">Secondary Terminal<br>ver.{{VERSION}}<br>({{BUILD_DATE}})</div>
            </div>
        </div>

        <!-- ACE „Ç®„Éá„Ç£„Çø„ÅØÂêÑ„Çø„Éñ„ÅÆ„Éö„Ç§„É≥ÂÜÖ„Å´ÂãïÁöÑ„Å´‰ΩúÊàê„Åï„Çå„Çã -->

        <!-- ‰∏ãÈÉ®„Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ -->
        <div class="control-panel">
            <div class="control-panel-left-controls">
                <button class="control-button" id="btn-send-selection"
                    data-tooltip="Send the editor content as context to the terminal input. Useful for providing code snippets or file references to CLI tools. (Cmd+L)">
                    @Selection
                </button>
                <button class="control-button copy-button" id="btn-copy-selection"
                    data-tooltip="Copy the editor content with file path and line numbers to clipboard. Ready to paste into other applications.">
                    Copy
                </button>
                <button class="control-button" id="btn-extract-to-todos"
                    data-tooltip="Extract the editor content to TODOS.md file in your workspace. Useful for saving prompts or notes.">
                    Extract
                </button>
                <button class="control-button" id="btn-open-history"
                    data-tooltip="Open the prompt history file (.secondary-terminal-history.md) to view or reuse previous prompts.">
                    History
                </button>
                <button class="control-button" id="btn-trim-lines"
                    data-tooltip="Trim whitespace from the beginning and end of each line in the editor. Removes leading/trailing spaces and tabs.">
                    Trim
                </button>
                <button class="control-button" id="btn-scroll-to-bottom"
                    data-tooltip="Scroll the terminal output to the bottom. Useful when viewing long output.">
                    ‚Üì
                </button>
                <button class="control-button" id="btn-paste-image"
                    data-tooltip="Paste an image from clipboard. Saves to temporary file and inserts the file path. (macOS only)">
                    üì∑
                </button>
            </div>
            <div class="control-panel-right-controls">
                <!-- CLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº -->
                <div class="cli-agent-indicator" id="cli-agent-indicator"
                    title="CLI Agent is active - Shift+Enter inputs a newline">CLI Agent</div>
            </div>
        </div>
    </div>

    <script src="{{XTERM_JS_URI}}"></script>
    <script src="{{XTERM_UNICODE11_JS_URI}}"></script>
    <script src="{{XTERM_WEBGL_JS_URI}}"></script>

    <!-- ACE Editor Scripts -->
    <script src="{{ACE_JS_URI}}"></script>
    <script src="{{ACE_MODE_JAVASCRIPT_URI}}"></script>
    <script src="{{ACE_MODE_MARKDOWN_URI}}"></script>
    <script src="{{ACE_KEYBINDING_VSCODE_URI}}"></script>
    <script>
        const MAX_BUFFER_LINES = parseInt('{{SCROLLBACK_MAX}}'); // Ë®≠ÂÆö„Åï„Çå„ÅüÊúÄÂ§ßË°åÊï∞
        const vscode = acquireVsCodeApi();

        // „Çø„ÉñÁä∂ÊÖãÁÆ°ÁêÜ
        const tabState = {
            tabs: [],                    // Array of {id, title}
            activeTabId: null,
            terminals: new Map(),        // tabId -> xterm Terminal instance
            terminalStates: new Map(),   // tabId -> per-tab terminalState
            globalEventListeners: [],    // „Ç∞„É≠„Éº„Éê„É´„Å™„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            resizeObserver: null,
        };

        // Êñ∞„Åó„ÅÑ„Çø„ÉñÁî®„ÅÆ„Éá„Éï„Ç©„É´„Éà terminalState „ÇíÁîüÊàê
        function createTerminalState() {
            return {
                term: null,
                timers: {
                    sizeCheckInterval: null,
                    backgroundColorInterval: null,
                    writeBuffer: null
                },
                eventListeners: [],
                isInitialized: false,
                writeBufferData: '',
                writeBufferPending: false,
                currentContainerBackgroundColor: null,
                lastWriteTime: 0,
                recentWriteCount: 0,
                adaptiveDelayMs: 16,
                addons: [],
                xtermListeners: [],
                cliAgentState: { active: false, agent_type: null },
                editor: null, // ACE editor instance per tab
            };
        }

        // ÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ„ÄÅÁèæÂú®„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çø„Éñ„ÅÆ terminalState „ÇíËøî„Åô„Ç≤„ÉÉ„Çø„Éº
        function getActiveTerminalState() {
            if (!tabState.activeTabId) return null;
            return tabState.terminalStates.get(tabState.activeTabId);
        }

        // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çø„Éñ„ÅÆ ACE „Ç®„Éá„Ç£„Çø„ÇíËøî„Åô„Éò„É´„Éë„Éº
        function getActiveEditor() {
            const state = getActiveTerminalState();
            return state ? state.editor : null;
        }

        // ACE „ÉÜ„Éº„ÉûÁôªÈå≤Ê∏à„Åø„Éï„É©„Ç∞
        let aceThemeRegistered = false;



        /**
         * „É≠„Ç∞„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°„Åô„Çã
         */
        function log(...args) {
            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');
            vscode.postMessage({
                type: 'log',
                message: `[terminal.html] ${message}`
            })
        }

        // ========================================
        // Tab UI Functions
        // ========================================

        /**
         * „Çø„Éñ UI Ë¶ÅÁ¥†„Çí‰ΩúÊàê
         */
        function createTabUI(tabInfo) {
            const tabList = document.getElementById('tab-list');
            const tab = document.createElement('div');
            tab.className = 'tab';
            tab.dataset.tabId = tabInfo.id;
            tab.innerHTML = `
                <span class="tab-title">${tabInfo.title}</span>
                <button class="tab-close" title="Close">√ó</button>
            `;
            tabList.appendChild(tab);
            updateTabCloseButtons();
            updateEmptyState();
            return tab;
        }

        /**
         * „Çø„Éñ„ÅÆ close „Éú„Çø„É≥„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞
         * ÂÖ®„Å¶„ÅÆ„Çø„Éñ„ÅåÈñâ„Åò„Çâ„Çå„Çã„Çà„ÅÜ„Å´„Å™„Å£„ÅüÔºà„Çø„Éñ0ÂÄã„ÇÇÂèØÔºâ
         */
        function updateTabCloseButtons() {
            // ÁèæÂú®„ÅØÂÖ®„Å¶„ÅÆ„Çø„Éñ„ÅåÈñâ„Åò„Çâ„Çå„Çã„Åü„ÇÅ„ÄÅÁâπ„Å´ÁÑ°ÂäπÂåñ„ÅØË°å„Çè„Å™„ÅÑ
        }

        /**
         * Empty state „ÅÆË°®Á§∫/ÈùûË°®Á§∫„ÇíÊõ¥Êñ∞
         */
        function updateEmptyState() {
            const emptyState = document.getElementById('empty-state');
            if (emptyState) {
                if (tabState.tabs.length === 0) {
                    emptyState.classList.add('visible');
                } else {
                    emptyState.classList.remove('visible');
                }
            }
        }

        /**
         * „Çø„Éñ„ÅÆ„Çø„Ç§„Éà„É´„ÇíÊõ¥Êñ∞
         */
        function updateTabTitle(tabId, title) {
            // „Çø„Éñ UI Ë¶ÅÁ¥†„ÇíÊé¢„Åó„Å¶Êõ¥Êñ∞
            const tabElement = document.querySelector(`.tab[data-tab-id="${tabId}"]`);
            if (tabElement) {
                const titleElement = tabElement.querySelector('.tab-title');
                if (titleElement) {
                    titleElement.textContent = title;
                }
            }
            // „Çø„ÉñÁä∂ÊÖã„ÇÇÊõ¥Êñ∞
            const tabInfo = tabState.tabs.find(t => t.id === tabId);
            if (tabInfo) {
                tabInfo.title = title;
            }
        }

        /**
         * ÊåáÂÆö„Åó„Åü„Çø„Éñ„Å´Âàá„ÇäÊõø„Åà
         */
        function switchToTab(tabId) {
            log('[TAB] Switching to tab:', tabId);

            // „Çø„Éñ UI „ÅÆ active Áä∂ÊÖã„ÇíÊõ¥Êñ∞
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tabId === tabId);
            });

            // „Çø„Éº„Éü„Éä„É´„Éö„Ç§„É≥„ÅÆË°®Á§∫/ÈùûË°®Á§∫
            document.querySelectorAll('.terminal-pane').forEach(pane => {
                pane.classList.toggle('active', pane.dataset.tabId === tabId);
            });

            // Áä∂ÊÖã„ÇíÊõ¥Êñ∞
            tabState.activeTabId = tabId;

            // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Çø„Éº„Éü„Éä„É´„Å´„Éï„Ç©„Éº„Ç´„Çπ
            const state = tabState.terminalStates.get(tabId);
            if (state && state.term) {
                setTimeout(() => {
                    state.term.focus();
                    setTerminalSize(tabId);
                }, 50);
            }
        }

        /**
         * „Çø„Éñ„ÇíÈñâ„Åò„ÇãÔºàUI „Å®„É™„ÇΩ„Éº„Çπ„ÇíÂâäÈô§Ôºâ
         */
        function closeTabUI(tabId) {
            log('[TAB] Closing tab:', tabId);

            // „Çø„ÉñË¶ÅÁ¥†„ÇíÂâäÈô§
            const tabElement = document.querySelector(`.tab[data-tab-id="${tabId}"]`);
            if (tabElement) {
                tabElement.remove();
            }

            // „Çø„Éº„Éü„Éä„É´„Éö„Ç§„É≥„ÇíÂâäÈô§
            const paneElement = document.querySelector(`.terminal-pane[data-tab-id="${tabId}"]`);
            if (paneElement) {
                paneElement.remove();
            }

            // „Çø„Éº„Éü„Éä„É´Áä∂ÊÖã„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            const state = tabState.terminalStates.get(tabId);
            if (state) {
                cleanupTerminalState(state);
                tabState.terminalStates.delete(tabId);
            }

            // „Çø„Éº„Éü„Éä„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂâäÈô§
            tabState.terminals.delete(tabId);

            // „Çø„Éñ„É™„Çπ„Éà„Åã„ÇâÂâäÈô§
            const tabIndex = tabState.tabs.findIndex(t => t.id === tabId);
            if (tabIndex !== -1) {
                tabState.tabs.splice(tabIndex, 1);
            }

            updateTabCloseButtons();
            updateEmptyState();

            // Èñâ„Åò„Åü„Çø„Éñ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å†„Å£„ÅüÂ†¥Âêà„ÄÅÂà•„ÅÆ„Çø„Éñ„Å´Âàá„ÇäÊõø„Åà
            if (tabState.activeTabId === tabId) {
                const nextTab = tabState.tabs[0];
                if (nextTab) {
                    switchToTab(nextTab.id);
                    vscode.postMessage({ type: 'switchTab', tabId: nextTab.id });
                } else {
                    // ‰ªñ„Å´„Çø„Éñ„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çø„Éñ„Çí„ÇØ„É™„Ç¢
                    tabState.activeTabId = null;
                }
            }
        }

        /**
         * „Çø„Éº„Éü„Éä„É´Áä∂ÊÖã„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
         */
        function cleanupTerminalState(state) {
            // xterm „É™„Çπ„Éä„Éº„Çí dispose
            if (state.xtermListeners && state.xtermListeners.length > 0) {
                state.xtermListeners.forEach(listener => {
                    try {
                        if (listener && listener.dispose) {
                            listener.dispose();
                        }
                    } catch (e) { }
                });
                state.xtermListeners = [];
            }

            // „Ç¢„Éâ„Ç™„É≥„Çí dispose
            if (state.addons && state.addons.length > 0) {
                state.addons.forEach(addon => {
                    try {
                        if (addon && addon.dispose) {
                            addon.dispose();
                        }
                    } catch (e) { }
                });
                state.addons = [];
            }

            // „Çø„Éº„Éü„Éä„É´„ÇíÁ†¥Ê£Ñ
            if (state.term) {
                try {
                    state.term.dispose();
                } catch (e) { }
                state.term = null;
            }

            // ACE „Ç®„Éá„Ç£„Çø„ÇíÁ†¥Ê£Ñ
            if (state.editor) {
                try {
                    state.editor.destroy();
                } catch (e) { }
                state.editor = null;
            }

            // „Çø„Ç§„Éû„Éº„Çí„ÇØ„É™„Ç¢
            Object.keys(state.timers).forEach(timerKey => {
                if (state.timers[timerKey]) {
                    try {
                        clearTimeout(state.timers[timerKey]);
                        clearInterval(state.timers[timerKey]);
                    } catch (e) { }
                    state.timers[timerKey] = null;
                }
            });

            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂâäÈô§
            state.eventListeners.forEach(({ element, event, handler }) => {
                try {
                    element.removeEventListener(event, handler);
                } catch (e) { }
            });
            state.eventListeners = [];
        }

        /**
         * „Çø„Éº„Éü„Éä„É´„Éö„Ç§„É≥ DOM „Çí‰ΩúÊàê
         */
        function createTerminalPane(tabId) {
            const panesContainer = document.getElementById('terminal-panes');
            const pane = document.createElement('div');
            pane.className = 'terminal-pane';
            pane.dataset.tabId = tabId;
            pane.id = `terminal-pane-${tabId}`;

            // „Çø„Éº„Éü„Éä„É´Ë°®Á§∫„Ç®„É™„Ç¢
            const termArea = document.createElement('div');
            termArea.className = 'terminal-area';
            termArea.id = `terminal-area-${tabId}`;
            pane.appendChild(termArea);

            // „Çø„ÉñÂ∞ÇÁî® ACE „Ç®„Éá„Ç£„Çø„Ç≥„É≥„ÉÜ„Éä
            const editorContainer = document.createElement('div');
            editorContainer.className = 'pane-editor-container';
            const editorDiv = document.createElement('div');
            editorDiv.className = 'ace-editor-instance';
            editorDiv.id = `ace-editor-${tabId}`;
            editorContainer.appendChild(editorDiv);
            pane.appendChild(editorContainer);

            panesContainer.appendChild(pane);
            return pane;
        }

        /**
         * „Çø„Éº„Éü„Éä„É´„Çµ„Ç§„Ç∫„ÇíÂãïÁöÑ„Å´Ë®≠ÂÆöÔºà„Çø„ÉñÂØæÂøúÔºâ
         */
        function setTerminalSize(tabId) {
            const state = tabState.terminalStates.get(tabId);
            if (!state || !state.term) {
                return;
            }

            const terminalArea = document.getElementById('terminal-area-' + tabId);
            if (!terminalArea) {
                log('Terminal area not found for tab:', tabId);
                return;
            }

            // „Çø„Éº„Éü„Éä„É´„Ç®„É™„Ç¢„ÅÆÂÆüÈöõ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
            const terminalRect = terminalArea.getBoundingClientRect();
            const availableWidth = terminalRect.width - 20; // „Éë„Éá„Ç£„É≥„Ç∞ËÄÉÊÖÆ
            const availableHeight = terminalRect.height - 5;

            if (availableWidth <= 0 || availableHeight <= 0) {
                return;
            }

            // „Éï„Ç©„É≥„ÉàÊÉÖÂ†±„Åã„ÇâÊñáÂ≠ó„Çµ„Ç§„Ç∫„ÇíÊ≠£Á¢∫„Å´Ë®àÁÆó
            const fontSize = 13;
            const targetLineHeight = 1.2;

            // ‰∏ÄÊôÇÁöÑ„Å™Ê∏¨ÂÆöÁî®„Ç®„É¨„É°„É≥„Éà„Çí‰ΩúÊàê„Åó„Å¶ÊñáÂ≠óÂπÖ„ÇíÊ≠£Á¢∫„Å´Ê∏¨ÂÆö
            const measurer = document.createElement('div');
            measurer.style.position = 'absolute';
            measurer.style.visibility = 'hidden';
            measurer.style.fontFamily = '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace';
            measurer.style.fontSize = fontSize + 'px';
            measurer.style.lineHeight = targetLineHeight;
            measurer.style.whiteSpace = 'pre';
            measurer.textContent = 'M'.repeat(10);

            document.body.appendChild(measurer);
            const rawCharWidth = measurer.getBoundingClientRect().width / 10;
            const rawLineHeight = measurer.getBoundingClientRect().height;
            document.body.removeChild(measurer);

            // „Çµ„Ç§„Ç∫Ë™øÊï¥‰øÇÊï∞
            const widthAdjustment = 0.88;
            const heightAdjustment = 1.34;

            const adjustedCharWidth = rawCharWidth * widthAdjustment;
            const adjustedLineHeight = rawLineHeight * heightAdjustment;

            // ÂàóÊï∞„Å®Ë°åÊï∞„ÇíË®àÁÆó
            const cols = Math.floor(availableWidth / adjustedCharWidth);
            const rows = Math.floor(availableHeight / adjustedLineHeight);

            // ÊúÄÂ∞è„Çµ„Ç§„Ç∫„Çí‰øùË®º
            const finalCols = Math.max(cols, 20);
            const finalRows = Math.max(rows, 5);

            // „Çø„Éº„Éü„Éä„É´„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö
            if (state.term.cols !== finalCols || state.term.rows !== finalRows) {
                state.term.resize(finalCols, finalRows);

                // „Çµ„Ç§„Ç∫Â§âÊõ¥„Çí VSCode „Å´ÈÄöÁü•ÔºàtabId „ÇíÂê´„ÇÅ„ÇãÔºâ
                vscode.postMessage({
                    type: 'resize',
                    tabId: tabId,
                    cols: finalCols,
                    rows: finalRows
                });
            }
        }

        /**
         * ÁîªÈù¢Ê∂àÂéªÁ≥ª„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÊ§úÁü•„Åô„Çã
         * vim, less Á≠â„ÅÆTUI„Ç¢„Éó„É™„ÅÆÂÖ®ÁîªÈù¢ÂÜçÊèèÁîª„Éë„Çø„Éº„É≥„ÇíÂà§ÂÆö
         * Ê≥®: \x1b[H („Ç´„Éº„ÇΩ„É´„Éõ„Éº„É†) „ÅØ„Éó„É≠„É≥„Éó„ÉàË°®Á§∫„Åß„ÇÇ‰Ωø„Çè„Çå„Çã„Åü„ÇÅÈô§Â§ñ
         */
        function hasScreenClearSequence(data) {
            return data.includes('\x1b[2J') ||    // ÁîªÈù¢„ÇØ„É™„Ç¢
                   data.includes('\x1b[?1049');   // ‰ª£Êõø„Éê„ÉÉ„Éï„Ç°Âàá„ÇäÊõø„Åà
        }

        // „Çø„ÉñÂ∞ÇÁî® ACE „Ç®„Éá„Ç£„ÇøÂàùÊúüÂåñÈñ¢Êï∞
        function initializeAceEditorForTab(tabId) {
            try {
                if (typeof ace === 'undefined') {
                    throw new Error('ACE is not defined. ace-builds may not have loaded.');
                }

                const state = tabState.terminalStates.get(tabId);
                if (!state) return;

                log('[ACE] Starting editor initialization for tab:', tabId);

                // VSCode „ÉÄ„Éº„ÇØ„ÉÜ„Éº„Éû„Çí‰∏ÄÂ∫¶„Å†„ÅëÁôªÈå≤
                if (!aceThemeRegistered && ace.define) {
                    ace.define('ace/theme/vscode-dark', ['require', 'exports', 'module'], function(require, exports, module) {
                        exports.isDark = true;
                        exports.cssClass = "ace-vscode-dark";
                        exports.cssText = "";
                    });
                    aceThemeRegistered = true;
                }

                const editorElementId = `ace-editor-${tabId}`;
                const editor = ace.edit(editorElementId);

                editor.setTheme("ace/theme/vscode-dark");
                editor.session.setMode("ace/mode/markdown");
                editor.setKeyboardHandler("ace/keyboard/vscode");

                editor.setOptions({
                    fontSize: 13,
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    showPrintMargin: false,
                    wrap: true,
                    showInvisibles: true,
                    enableBasicAutocompletion: true,
                    enableLiveAutocompletion: true,
                    enableSnippets: true
                });

                // „Çø„ÉñÂõ∫Êúâ„ÅÆÊ∞∏Á∂öÂåñ„Åï„Çå„ÅüÂÜÖÂÆπ„ÇíÂæ©ÂÖÉÔºàÊóßÂΩ¢Âºè„Åã„Çâ„ÅÆ„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥Âê´„ÇÄÔºâ
                const currentState = vscode.getState() || {};
                let savedContents = currentState.editorContents || {};
                let savedContent = savedContents[tabId] || '';
                // ÊóßÂΩ¢Âºè editorContent „ÅåÊÆã„Å£„Å¶„ÅÑ„Çå„Å∞ÊúÄÂàù„ÅÆ„Çø„Éñ„Å´ÈÅ©Áî®
                if (!savedContent && currentState.editorContent) {
                    savedContent = currentState.editorContent;
                    savedContents[tabId] = savedContent;
                    delete currentState.editorContent;
                    currentState.editorContents = savedContents;
                    vscode.setState(currentState);
                }
                editor.setValue(savedContent, -1);

                // ÈÄÅ‰ø°„Ç≥„Éû„É≥„ÉâÔºàCmd+EnterÔºâ
                function sendEditorContent(ed) {
                    const content = ed.getValue();
                    if (!content.trim()) return;

                    const trimmedContent = content.trimEnd();
                    vscode.postMessage({
                        type: 'editorSendContent',
                        data: trimmedContent,
                        tabId: tabId
                    });

                    setTimeout(() => {
                        vscode.postMessage({
                            type: 'terminalInput',
                            data: '\r',
                            tabId: tabId
                        });
                        ed.setValue('', -1);
                    }, 200);
                }

                editor.commands.addCommand({
                    name: 'sendToTerminal',
                    bindKey: { win: 'Ctrl-Enter', mac: 'Cmd-Enter' },
                    exec: sendEditorContent
                });

                // ÂÜÖÂÆπÂ§âÊõ¥ÊôÇ„Å´„Çø„ÉñÂà•„ÅßÊ∞∏Á∂öÂåñ
                editor.on('change', function() {
                    const content = editor.getValue();
                    const currentState = vscode.getState() || {};
                    const contents = currentState.editorContents || {};
                    contents[tabId] = content;
                    vscode.setState({ ...currentState, editorContents: contents });
                });

                // DOM „Ç≠„Éº„Ç§„Éô„É≥„Éà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                const aceContainer = document.getElementById(editorElementId);
                if (aceContainer) {
                    aceContainer.addEventListener('keydown', function(event) {
                        if (event.key === 'Enter' && (event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey) {
                            event.preventDefault();
                            event.stopPropagation();
                            sendEditorContent(editor);
                            return false;
                        }
                    }, true);
                }

                editor.setOption('dragEnabled', false);

                // „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„ÉóË®≠ÂÆö
                const editorWrapper = aceContainer?.closest('.pane-editor-container');
                if (editorWrapper) {
                    editorWrapper.addEventListener('dragenter', (e) => { e.preventDefault(); }, true);
                    editorWrapper.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = 'copy';
                        editorWrapper.style.outline = '2px dashed var(--vscode-focusBorder, #007acc)';
                    }, true);
                    editorWrapper.addEventListener('dragleave', (e) => {
                        if (!editorWrapper.contains(e.relatedTarget)) {
                            editorWrapper.style.outline = '';
                        }
                    }, true);
                    editorWrapper.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        editorWrapper.style.outline = '';
                        vscode.postMessage({ type: 'openDropZone' });
                    }, true);
                }

                state.editor = editor;
                log('[ACE] Editor initialized for tab:', tabId);

            } catch (error) {
                log('[ACE] Error initializing editor for tab:', tabId, error);
            }
        }

        // „É™„ÇΩ„Éº„ÇπÂÆåÂÖ®„É™„Çª„ÉÉ„ÉàÈñ¢Êï∞Ôºà„Éû„É´„ÉÅ„Çø„ÉñÂØæÂøúÔºâ
        function resetTerminalResources() {
            log('[LEAK CHECK] Starting resource reset');

            // ÂÖ®„Çø„Éñ„ÅÆÁä∂ÊÖã„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            tabState.terminalStates.forEach((termState, tabId) => {
                log('[LEAK CHECK] Cleaning up tab:', tabId);
                cleanupTerminalState(termState);
            });

            // „Ç∞„É≠„Éº„Éê„É´ ResizeObserver „ÇíÂÅúÊ≠¢
            if (tabState.resizeObserver) {
                try {
                    tabState.resizeObserver.disconnect();
                } catch (error) {
                    log('Error disconnecting ResizeObserver:', error);
                }
                tabState.resizeObserver = null;
            }

            // „Ç∞„É≠„Éº„Éê„É´„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂâäÈô§
            tabState.globalEventListeners.forEach(({ element, event, handler }) => {
                try {
                    element.removeEventListener(event, handler);
                } catch (error) {
                    log('Error removing global event listener:', error);
                }
            });
            tabState.globalEventListeners = [];

            // „Çø„ÉñÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
            tabState.tabs = [];
            tabState.activeTabId = null;
            tabState.terminals.clear();
            tabState.terminalStates.clear();

            // „Çø„Éñ UI „Çí„ÇØ„É™„Ç¢
            const tabList = document.getElementById('tab-list');
            if (tabList) {
                tabList.innerHTML = '';
            }
            const terminalPanes = document.getElementById('terminal-panes');
            if (terminalPanes) {
                terminalPanes.innerHTML = '';
            }

            log('[LEAK CHECK] Resource reset completed');
        }

        // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÁôªÈå≤„Éò„É´„Éë„ÉºÔºàÁÆ°ÁêÜÂØæË±°„Å´ËøΩÂä†Ôºâ
        // targetState „ÅåÊåáÂÆö„Åï„Çå„ÅüÂ†¥Âêà„ÅØ„Åù„ÅÆ„Çø„Éñ„ÅÆ state „Å´„ÄÅ„Å™„Åë„Çå„Å∞„Ç∞„É≠„Éº„Éê„É´„Å´ÁôªÈå≤
        function addManagedEventListener(element, event, handler, targetState = null) {
            element.addEventListener(event, handler);
            if (targetState && targetState.eventListeners) {
                targetState.eventListeners.push({ element, event, handler });
            } else {
                tabState.globalEventListeners.push({ element, event, handler });
            }
        }

        // Â§ßÈáè„Éö„Éº„Çπ„Éà„ÅÆ„ÉÅ„É£„É≥„ÇØÈÄÅ‰ø°Ê©üËÉΩ
        function sendBytesInChunks(bytes, meta) {
            const CHUNK_SIZE = 32 * 1024; // 32KB „ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫
            const id = Math.random().toString(36).slice(2); // „É©„É≥„ÉÄ„É† ID
            let offset = 0;

            // ACK ÂæÖ„Å°Áî®„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            const onAck = (event) => {
                const message = event.data;
                if (!message || message.type !== 'terminalInputAck' || message.id !== id) {
                    return;
                }

                if (message.done) {
                    // ÈÄÅ‰ø°ÂÆå‰∫Ü
                    window.removeEventListener('message', onAck);
                    log('[PASTE CHUNKS] All chunks sent successfully');
                    return;
                }

                // Ê¨°„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíÈÄÅ‰ø°
                sendNextChunk();
            };

            window.addEventListener('message', onAck);

            // ÈÄÅ‰ø°ÈñãÂßãÈÄöÁü•
            log('[PASTE CHUNKS] Starting chunked paste, total bytes:', bytes.length);
            vscode.postMessage({
                type: 'terminalInputBegin',
                id: id,
                totalBytes: bytes.length,
                ...meta
            });

            function sendNextChunk() {
                if (offset >= bytes.length) {
                    // ÈÄÅ‰ø°ÁµÇ‰∫ÜÈÄöÁü•
                    vscode.postMessage({ type: 'terminalInputEnd', id: id });
                    return;
                }

                const chunkEnd = Math.min(offset + CHUNK_SIZE, bytes.length);
                const slice = bytes.subarray(offset, chunkEnd);

                // base64 „Ç®„É≥„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„ÅßÂÆâÂÖ®„Å´Ëª¢ÈÄÅ
                const b64 = btoa(String.fromCharCode.apply(null, slice));

                log('[PASTE CHUNKS] Sending chunk', offset, 'to', chunkEnd, 'of', bytes.length);
                vscode.postMessage({
                    type: 'terminalInputChunk',
                    id: id,
                    b64: b64,
                    offset: offset,
                    size: slice.length
                });

                offset = chunkEnd;
            }

            // ÊúÄÂàù„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíÈÄÅ‰ø°
            sendNextChunk();
        }

        // ÂÆöÊúüÁöÑ„Å™„Éê„ÉÉ„Éï„Ç°„ÇØ„É™„Ç¢Ê©üËÉΩÔºà„Éû„É´„ÉÅ„Çø„ÉñÂØæÂøúÔºâ
        let bufferCleanupSetup = false;
        function setupPeriodicBufferCleanup() {
            // Êó¢„Å´„Çª„ÉÉ„Éà„Ç¢„ÉÉ„ÉóÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
            if (bufferCleanupSetup) {
                return;
            }
            bufferCleanupSetup = true;

            // Ë®≠ÂÆöÂèØËÉΩ„Å™ÂÄ§
            const BUFFER_CHECK_INTERVAL = 30000; // 30ÁßíÈñìÈöî„Åß„ÉÅ„Çß„ÉÉ„ÇØ
            const CLEANUP_THRESHOLD = Math.floor(MAX_BUFFER_LINES * 0.8); // 80%„ÅßË≠¶Âëä
            const CLEANUP_TARGET = Math.floor(MAX_BUFFER_LINES * 0.6); // 60%„Åæ„ÅßÂâäÊ∏õ

            log('[BUFFER CLEANUP] Setting up periodic buffer cleanup', {
                checkInterval: BUFFER_CHECK_INTERVAL,
                maxLines: MAX_BUFFER_LINES,
                cleanupThreshold: CLEANUP_THRESHOLD,
                cleanupTarget: CLEANUP_TARGET
            });

            const bufferCleanupTimer = setInterval(() => {
                // ÂÖ®„Çø„Éñ„ÅÆ„Éê„ÉÉ„Éï„Ç°„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                tabState.terminalStates.forEach((termState, tabId) => {
                    if (!termState.term) {
                        return;
                    }

                    try {
                        const buffer = termState.term.buffer;
                        if (!buffer || !buffer.active) {
                            return;
                        }

                        const totalLines = buffer.active.length;
                        const scrollbackLines = totalLines - termState.term.rows;

                        // „Çπ„ÇØ„É≠„Éº„É´„Éê„ÉÉ„ÇØË°åÊï∞„ÅåÈñæÂÄ§„ÇíË∂Ö„Åà„ÅüÂ†¥Âêà„ÄÅ„ÇØ„É™„Ç¢„ÇíÂÆüË°å
                        if (scrollbackLines > CLEANUP_THRESHOLD) {
                            log('[BUFFER CLEANUP] Buffer cleanup triggered for tab:', tabId, {
                                currentLines: scrollbackLines,
                                targetLines: CLEANUP_TARGET
                            });

                            // ÁèæÂú®„ÅÆ„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„Çí‰øùÂ≠ò
                            const currentScrollY = termState.term.buffer.active.viewportY;
                            const isAtBottom = currentScrollY >= (totalLines - termState.term.rows);

                            // Â∞ë„ÅóÂæÖ„Å£„Å¶„Åã„Çâ„ÇØ„É™„Ç¢„ÇíÂÆüË°å
                            setTimeout(() => {
                                try {
                                    // VSCode ÂÅ¥„Å´„Éê„ÉÉ„Éï„Ç°„ÇØ„É™„Ç¢Ë¶ÅÊ±Ç„ÇíÈÄÅ‰ø°
                                    vscode.postMessage({
                                        type: 'bufferCleanupRequest',
                                        tabId: tabId,
                                        currentLines: scrollbackLines,
                                        threshold: CLEANUP_THRESHOLD,
                                        preserveScrollPosition: !isAtBottom
                                    });

                                    if (isAtBottom && termState.term) {
                                        termState.term.scrollToBottom();
                                    }

                                } catch (error) {
                                    log('[BUFFER CLEANUP] Error during buffer cleanup:', error);
                                    if (termState.term) {
                                        termState.term.scrollToBottom();
                                    }
                                }
                            }, 100);
                        }
                    } catch (error) {
                        log('[BUFFER CLEANUP] Error checking buffer for tab:', tabId, error);
                    }
                });
            }, BUFFER_CHECK_INTERVAL);

            // „Ç∞„É≠„Éº„Éê„É´„Çø„Ç§„Éû„Éº„Å®„Åó„Å¶‰øùÂ≠ò
            tabState.bufferCleanupTimer = bufferCleanupTimer;
            log('[BUFFER CLEANUP] Periodic buffer cleanup timer set');
        }

        // „Ç∞„É≠„Éº„Éê„É´„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©ÂàùÊúüÂåñÔºà‰∏ÄÂ∫¶„Å†„ÅëÂÆüË°åÔºâ
        let globalHandlersInitialized = false;
        function initializeGlobalHandlers() {
            if (globalHandlersInitialized) {
                log('[GLOBAL] Global handlers already initialized, skipping');
                return;
            }
            globalHandlersInitialized = true;
            log('[GLOBAL] Initializing global handlers');

            // „Ç∞„É≠„Éº„Éê„É´„É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©ÔºàÂÖ®„Çø„Éñ„Å´ÂØæÂøúÔºâ
            const globalMessageHandler = (event) => {
                const message = event.data;
                switch (message.type) {
                    case 'output':
                        // „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ tabId „ÇíÂèñÂæóÔºà„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çø„Éñ„Å∏„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
                        const outputTabId = message.tabId || tabState.activeTabId;
                        if (!outputTabId) {
                            log('[OUTPUT] No tabId available');
                            break;
                        }
                        const outputState = tabState.terminalStates.get(outputTabId);
                        if (!outputState) {
                            log('[OUTPUT] No state found for tabId:', outputTabId);
                            break;
                        }

                        // „Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºà„Çø„ÉñÂõ∫Êúâ„ÅÆ„Éè„É≥„Éâ„É©„Çí‰ΩøÁî®Ôºâ
                        if (outputState.handleStatusMessage) {
                            outputState.handleStatusMessage(message.data);
                        }

                        // „Ç¢„ÉÄ„Éó„ÉÜ„Ç£„Éñ„É¨„É≥„ÉÄ„É™„É≥„Ç∞: ÁîªÈù¢Ê∂àÂéªÊ§úÁü•„Å®Êõ¥Êñ∞È†ªÂ∫¶ËøΩË∑°
                        const payload = message.data;
                        const hasScreenClear = hasScreenClearSequence(payload);

                        // Êõ¥Êñ∞È†ªÂ∫¶„ÇíËøΩË∑°Ôºà50ms‰ª•ÂÜÖ„ÅÆÈÄ£Á∂öÊõ¥Êñ∞„Çí„Ç´„Ç¶„É≥„ÉàÔºâ
                        const now = Date.now();
                        if (now - outputState.lastWriteTime < 50) {
                            outputState.recentWriteCount = Math.min(outputState.recentWriteCount + 1, 10);
                        } else {
                            outputState.recentWriteCount = Math.max(0, outputState.recentWriteCount - 2);
                        }
                        outputState.lastWriteTime = now;

                        // ÂãïÁöÑ„Å´ÈÅÖÂª∂„ÇíË™øÊï¥
                        if (hasScreenClear || outputState.recentWriteCount > 5) {
                            outputState.adaptiveDelayMs = 50;  // 20fpsÔºàTUI „Ç¢„Éó„É™Âêë„ÅëÔºâ
                        } else if (outputState.recentWriteCount > 2) {
                            outputState.adaptiveDelayMs = 33;  // 30fps
                        } else {
                            outputState.adaptiveDelayMs = 16;  // 60fpsÔºàÈÄöÂ∏∏Âá∫ÂäõÔºâ
                        }

                        // „Éê„ÉÉ„ÉÅÂá¶ÁêÜ: „Éá„Éº„Çø„Çí„Éê„ÉÉ„Éï„Ç°„Å´ËøΩÂä†
                        outputState.writeBufferData += payload;

                        // „Åæ„Å†„Çø„Ç§„Éû„Éº„Åå„Çª„ÉÉ„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø
                        if (!outputState.writeBufferPending && outputState.term) {
                            outputState.writeBufferPending = true;
                            outputState.timers.writeBuffer = setTimeout(() => {
                                if (outputState.term && outputState.writeBufferData) {
                                    outputState.term.write(outputState.writeBufferData);
                                    outputState.writeBufferData = '';
                                }
                                outputState.writeBufferPending = false;
                                outputState.timers.writeBuffer = null;
                            }, outputState.adaptiveDelayMs);
                        }
                        break;

                    case 'clear':
                        const clearTabId = message.tabId || tabState.activeTabId;
                        const clearState = tabState.terminalStates.get(clearTabId);
                        if (clearState && clearState.term) {
                            clearState.term.clear();
                        }
                        break;

                    case 'reset':
                        resetTerminalResources();
                        // Êñ∞„Åó„ÅÑ„Çø„Éñ„Çí‰ΩúÊàê„Åó„Å¶ÂàùÊúüÂåñ
                        setTimeout(() => {
                            const newTabId = createNewTab();
                            if (newTabId) {
                                initializeTerminal(newTabId);
                            }
                        }, 10);
                        break;

                    case 'visibility_restored':
                        log('[LEAK CHECK] visibility_restored event received');
                        const activeState = getActiveTerminalState();
                        if (activeState && activeState.term) {
                            setTimeout(() => {
                                log('[LEAK CHECK] Calling setTerminalSize from visibility_restored');
                                setTerminalSize(tabState.activeTabId);
                                activeState.term.focus();
                                vscode.postMessage({
                                    type: 'refreshCliAgentStatus',
                                    tabId: tabState.activeTabId,
                                    timestamp: Date.now()
                                });
                            }, 50);
                        } else if (activeState && activeState.isInitialized) {
                            log('Terminal was disposed unexpectedly, resetting state');
                            resetTerminalResources();
                            window.location.reload();
                        }
                        break;

                    case 'tabCreated':
                        // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Åã„Çâ„ÅÆ„Çø„Éñ‰ΩúÊàêÈÄöÁü•
                        if (message.tab) {
                            const tab = message.tab;
                            tabState.tabs.push(tab);
                            createTabUI(tab);
                            createTerminalPane(tab.id);
                            switchToTab(tab.id);
                            initializeTerminal(tab.id);
                        }
                        break;

                    case 'tabList':
                        // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Åã„Çâ„ÅÆ„Çø„Éñ„É™„Çπ„ÉàÂæ©ÂÖÉ
                        if (message.tabs && message.tabs.length > 0) {
                            log('[GLOBAL] Restoring tabs:', message.tabs.length);
                            message.tabs.forEach(tab => {
                                tabState.tabs.push(tab);
                                createTabUI(tab);
                                createTerminalPane(tab.id);
                            });
                            if (message.activeTabId) {
                                switchToTab(message.activeTabId);
                                initializeTerminal(message.activeTabId);
                            }
                        }
                        break;

                    case 'tabClosed':
                        // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Åã„Çâ„ÅÆ„Çø„ÉñÈñâ„ÅòÈÄöÁü•
                        if (message.tabId) {
                            log('[GLOBAL] Tab closed by backend:', message.tabId);
                            closeTabUI(message.tabId);
                        }
                        break;

                    case 'tabProcessExited':
                        // „Éó„É≠„Çª„ÇπÁµÇ‰∫Ü„Å´„Çà„Çã„Çø„ÉñÈñâ„ÅòÔºàCtrl-DÁ≠âÔºâ
                        if (message.tabId) {
                            log('[GLOBAL] Process exited, closing tab:', message.tabId);
                            closeTabUI(message.tabId);
                        }
                        break;

                    case 'bufferCleanupCompleted':
                        log('[BUFFER CLEANUP] Received cleanup completion notification', {
                            success: message.success,
                            timestamp: message.timestamp,
                            error: message.error
                        });
                        break;

                    case 'sendTextToEditor':
                        if (getActiveEditor() && message.text) {
                            getActiveEditor().insert(message.text);
                            getActiveEditor().focus();
                        }
                        break;

                    case 'extractToTodosResult':
                        if (message.success && getActiveEditor()) {
                            const reference = `See [@${message.filePath}]`;
                            getActiveEditor().setValue(reference, -1);
                            log('[EXTRACT] Editor content replaced with reference:', reference);
                        } else if (!message.success) {
                            log('[EXTRACT] Failed to write TODOS.md:', message.error);
                        }
                        break;
                }
            };
            window.addEventListener('message', globalMessageHandler);
            tabState.globalEventListeners.push({ element: window, event: 'message', handler: globalMessageHandler });

            // „Éú„Çø„É≥„Ç§„Éô„É≥„Éà„ÅÆË®≠ÂÆö
            const btnSendSelection = document.getElementById('btn-send-selection');
            if (btnSendSelection) {
                btnSendSelection.addEventListener('click', () => {
                    vscode.postMessage({ type: 'buttonSendSelection', tabId: tabState.activeTabId });
                    const activeTermState = getActiveTerminalState();
                    if (activeTermState && activeTermState.term) {
                        activeTermState.term.focus();
                    }
                });
            }

            const btnCopySelection = document.getElementById('btn-copy-selection');
            if (btnCopySelection) {
                btnCopySelection.addEventListener('click', () => {
                    vscode.postMessage({ type: 'buttonCopySelection', tabId: tabState.activeTabId });
                    btnCopySelection.classList.add('done');
                    setTimeout(() => btnCopySelection.classList.remove('done'), 2000);
                    const activeTermState = getActiveTerminalState();
                    if (activeTermState && activeTermState.term) {
                        activeTermState.term.focus();
                    }
                });
            }

            const btnScrollToBottom = document.getElementById('btn-scroll-to-bottom');
            if (btnScrollToBottom) {
                btnScrollToBottom.addEventListener('click', () => {
                    const activeTermState = getActiveTerminalState();
                    if (activeTermState && activeTermState.term) {
                        activeTermState.term.scrollToBottom();
                        activeTermState.term.focus();
                    }
                });
            }

            const btnExtractToTodos = document.getElementById('btn-extract-to-todos');
            if (btnExtractToTodos) {
                btnExtractToTodos.addEventListener('click', () => {
                    if (!getActiveEditor()) return;
                    const content = getActiveEditor().getValue();
                    if (!content.trim() || content.split('\n').length <= 1) return;
                    vscode.postMessage({ type: 'extractToTodos', data: content });
                });
            }

            const btnOpenHistory = document.getElementById('btn-open-history');
            if (btnOpenHistory) {
                btnOpenHistory.addEventListener('click', () => {
                    vscode.postMessage({ type: 'openPromptHistory' });
                });
            }

            const btnPasteImage = document.getElementById('btn-paste-image');
            if (btnPasteImage) {
                btnPasteImage.addEventListener('click', () => {
                    vscode.postMessage({ type: 'pasteImage' });
                });
            }

            const btnTrimLines = document.getElementById('btn-trim-lines');
            if (btnTrimLines) {
                btnTrimLines.addEventListener('click', () => {
                    if (getActiveEditor()) {
                        const content = getActiveEditor().getValue();
                        const trimmedContent = content
                            .split('\n')
                            .map(line => line.trim())
                            .join('\n');
                        getActiveEditor().setValue(trimmedContent, -1);
                        log('[Editor] Lines trimmed');
                    }
                });
            }

            // „Çø„Éñ„Éê„Éº„Ç§„Éô„É≥„Éà„ÅÆË®≠ÂÆö
            const btnAddTab = document.getElementById('btn-add-tab');
            if (btnAddTab) {
                btnAddTab.addEventListener('click', () => {
                    log('[TAB] Add tab button clicked');
                    vscode.postMessage({ type: 'createTab' });
                });
            }

            // Empty state „ÇØ„É™„ÉÉ„ÇØ„ÅßÊñ∞„Åó„ÅÑ„Çø„Éñ„Çí‰ΩúÊàê
            const emptyState = document.getElementById('empty-state');
            if (emptyState) {
                emptyState.addEventListener('click', () => {
                    log('[TAB] Empty state clicked');
                    vscode.postMessage({ type: 'createTab' });
                });
            }

            // „Çø„Éñ„É™„Çπ„Éà„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÔºà„Ç§„Éô„É≥„ÉàÂßîË≠≤Ôºâ
            const tabList = document.getElementById('tab-list');
            if (tabList) {
                tabList.addEventListener('click', (event) => {
                    const tabElement = event.target.closest('.tab');
                    if (!tabElement) return;

                    const tabId = tabElement.dataset.tabId;
                    if (!tabId) return;

                    // Èñâ„Åò„Çã„Éú„Çø„É≥„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÂ†¥Âêà
                    if (event.target.closest('.tab-close')) {
                        log('[TAB] Close button clicked for tab:', tabId);
                        vscode.postMessage({ type: 'closeTab', tabId: tabId });
                        return;
                    }

                    // „Çø„ÉñÊú¨‰Ωì„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÂ†¥Âêà
                    if (tabId !== tabState.activeTabId) {
                        log('[TAB] Tab clicked:', tabId);
                        switchToTab(tabId);
                        vscode.postMessage({ type: 'switchTab', tabId: tabId });
                    }
                });
            }

            log('[GLOBAL] Global handlers initialized');
        }

        // Êñ∞„Åó„ÅÑ„Çø„Éñ„Çí‰ΩúÊàê„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
        let nextTabNumber = 1;
        function createNewTab() {
            const tabId = 'tab-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            const tab = {
                id: tabId,
                title: 'Terminal ' + nextTabNumber++
            };
            tabState.tabs.push(tab);
            createTabUI(tab);
            createTerminalPane(tab.id);
            switchToTab(tab.id);
            return tabId;
        }

        // „Çø„Éº„Éü„Éä„É´ÂàùÊúüÂåñÈñ¢Êï∞Ôºà„Çø„ÉñÂØæÂøúÔºâ
        function initializeTerminal(tabId) {
            // „Çø„ÉñÂõ∫Êúâ„ÅÆÁä∂ÊÖã„ÇíÂèñÂæó„Åæ„Åü„ÅØ‰ΩúÊàê
            let state = tabState.terminalStates.get(tabId);
            if (!state) {
                state = createTerminalState();
                tabState.terminalStates.set(tabId, state);
            }

            try {
                // ÈáçË§áÂàùÊúüÂåñ„ÇíÂé≥ÂØÜ„Å´„ÉÅ„Çß„ÉÉ„ÇØ
                if (state.isInitialized) {
                    log('[INIT] Terminal for tab', tabId, 'is already initialized, skipping');

                    // Êó¢„Å´ÂàùÊúüÂåñÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Çµ„Ç§„Ç∫Ë™øÊï¥„Å®„Éï„Ç©„Éº„Ç´„Çπ„ÅÆ„ÅøÂÆüË°å
                    if (state.term) {
                        setTimeout(() => {
                            setTerminalSize(tabId);
                            state.term.focus();
                        }, 50);
                    }
                    return;
                }

                // CSSÂ§âÊï∞„Çí„Éá„Éê„ÉÉ„Ç∞
                log(`[INIT] CSS Variables: vscode-sideBar-background:${document.documentElement.style.getPropertyValue('--vscode-sideBar-background')}, vscode-terminal-foreground:${document.documentElement.style.getPropertyValue('--vscode-terminal-foreground')}, vscode-terminal-background:${document.documentElement.style.getPropertyValue('--vscode-terminal-background')}`);

                // ‰∫åÈáçÂàùÊúüÂåñ„ÇíÈò≤„Åê„Åü„ÇÅ„ÄÅÊúÄÂàù„Å´„Éï„É©„Ç∞„ÇíÁ´ã„Å¶„Çã
                state.isInitialized = true;

                log('[INIT] Starting terminal initialization for tab:', tabId);

                if (typeof Terminal === 'undefined') {
                    throw new Error('Terminal is not defined. xterm.js may not have loaded.');
                }

                state.term = new Terminal({
                    theme: {
                        // ‚Üì „Åä„Åù„Çâ„Åè„ÄÅ„Çø„Éº„Éü„Éä„É´ÂÜÖ„Åß‰∏äÊõ∏„Åç„Åï„Çå„Çã
                        // background: 'var(--vscode-sideBar-background)',
                        background: document.documentElement.style.getPropertyValue('--vscode-sideBar-background') || '#111111',
                        foreground: document.documentElement.style.getPropertyValue('--vscode-terminal-foreground') || '#ffffff',
                        cursor: document.documentElement.style.getPropertyValue('--vscode-terminal-cursor-foreground') || '#ffffff',
                        selection: document.documentElement.style.getPropertyValue('--vscode-terminal-selection-background') || '#ffffff'
                    },
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    fontSize: 13,
                    letterSpacing: 0,
                    lineHeight: 1.2,
                    cursorBlink: false,
                    smoothScrollDuration: 0,  // „Çπ„É†„Éº„Ç∫„Çπ„ÇØ„É≠„Éº„É´„ÇíÁÑ°ÂäπÂåñÔºà„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂêë‰∏äÔºâ
                    convertEol: true,
                    allowProposedApi: true,
                    allowTransparency: false,
                    minimumContrastRatio: 1,
                    // „Éö„Éº„Çπ„Éà„Çí„Ç¢„Éó„É™„Å´„Äå„Åæ„Å®„Åæ„Çä„Äç„Å®„Åó„Å¶‰ºù„Åà„Çã
                    bracketedPasteMode: true,
                    // „Çπ„ÇØ„É≠„Éº„É´„Éê„ÉÉ„ÇØ‰∏äÈôê„ÇíË®≠ÂÆöÔºàÂ§ß„Åç„Å™Â±•Ê≠¥„Åß„ÅÆ write/render Ë≤†Ëç∑„ÇíËªΩÊ∏õÔºâ
                    scrollback: MAX_BUFFER_LINES
                });

                const terminalElement = document.getElementById('terminal-area-' + tabId);
                state.term.open(terminalElement);

                // Map „Å´„ÇÇÁôªÈå≤
                tabState.terminals.set(tabId, state.term);

                // 2Áßí„Åî„Å®„Å´„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åó„ÄÅÊúÄ‰∏äÈÉ®„Å™„ÇâÊúÄ‰∏ãÈÉ®„Å´„Çπ„ÇØ„É≠„Éº„É´
                const scrollCheckInterval = setInterval(() => {
                    if (!state.term || !state.term.buffer || !state.term.buffer.active) {
                        return;
                    }
                    const buffer = state.term.buffer.active;
                    // „Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„ÅåÂé≥ÂØÜ„Å´0(ÊúÄ‰∏äÈÉ®)„ÅÆÊôÇ„ÅÆ„Åø
                    if (buffer.viewportY === 0) {
                        state.term.scrollToBottom();
                    }
                }, 2000);

                // „Çø„Ç§„Éû„Éº„ÇíÁÆ°ÁêÜÂØæË±°„Å´ËøΩÂä†
                state.timers.scrollCheck = scrollCheckInterval;
                log('[LEAK CHECK] Added scroll position check interval (2000ms)');

                // Unicode 11 „Ç¢„Éâ„Ç™„É≥„Çí„É≠„Éº„Éâ
                if (typeof Unicode11Addon !== 'undefined') {
                    try {
                        const unicode11 = new Unicode11Addon.Unicode11Addon();
                        state.term.loadAddon(unicode11);
                        unicode11.activate(state.term);
                        log('[LEAK CHECK] Unicode11 addon loaded');

                        state.addons.push(unicode11);
                    } catch (error) {
                        log('Failed to load Unicode 11 addon:', error);
                    }
                }

                // WebGL „Ç¢„Éâ„Ç™„É≥„Çí„É≠„Éº„Éâ
                if (typeof WebglAddon !== 'undefined') {
                    try {
                        const webgl = new WebglAddon.WebglAddon();

                        // WebGL context loss „ÅÆ„Éè„É≥„Éâ„É™„É≥„Ç∞
                        webgl.onContextLoss(() => {
                            log('[RENDERER] WebGL context lost!');
                            webgl.dispose();
                        });

                        state.term.loadAddon(webgl);
                        log('[RENDERER] WebGL addon loaded successfully');

                        state.addons.push(webgl);
                    } catch (error) {
                        log('[RENDERER] Failed to load WebGL addon:', error);
                        throw error;
                    }
                } else {
                    throw new Error('WebglAddon is not defined');
                }

                // „Çø„Éº„Éü„Éä„É´Ë¶ÅÁ¥†„ÅÆ„Çµ„Ç§„Ç∫„ÅåÁ¢∫ÂÆö„Åô„Çã„Åæ„ÅßÂæÖÊ©ü
                function waitForSize() {
                    return new Promise((resolve) => {
                        const checkSize = () => {
                            const rect = terminalElement.getBoundingClientRect();
                            if (rect.width > 0 && rect.height > 0) {

                                resolve();
                            } else {
                                setTimeout(checkSize, 10);
                            }
                        };
                        checkSize();
                    });
                }

                // „Çµ„Ç§„Ç∫Á¢∫ÂÆöÂæå„Å´ÂàùÊúüË®≠ÂÆö
                waitForSize().then(() => {
                    // ÂàùÊúü„Çµ„Ç§„Ç∫Ë®≠ÂÆö
                    setTerminalSize(tabId);

                });

                // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÊôÇ„ÅÆÂá¶ÁêÜÔºà„Ç∞„É≠„Éº„Éê„É´ - ÂÖ®„Çø„Éñ„Å´ÈÅ©Áî®Ôºâ
                if (!tabState.resizeObserver) {
                    const windowResizeHandler = () => {
                        // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Çø„Éñ„ÅÆ„Åø„É™„Çµ„Ç§„Ç∫
                        if (tabState.activeTabId) {
                            setTimeout(() => setTerminalSize(tabState.activeTabId), 50);
                        }
                    };
                    window.addEventListener('resize', windowResizeHandler);
                    tabState.globalEventListeners.push({ element: window, event: 'resize', handler: windowResizeHandler });

                    // ResizeObserver „Åß„Ç≥„É≥„ÉÜ„Éä„Çµ„Ç§„Ç∫Â§âÊõ¥„ÇíÁõ£Ë¶ñÔºà„Ç∞„É≠„Éº„Éê„É´Ôºâ
                    let lastResizeTime = 0;

                    tabState.resizeObserver = new ResizeObserver((entries) => {
                        const now = Date.now();

                        // „Éá„Éê„Ç¶„É≥„ÇπÂá¶ÁêÜÔºöÈÄ£Á∂ö„Åô„Çã resize „ÇíÂà∂Èôê
                        if (now - lastResizeTime < 100) {
                            return;
                        }

                        if (entries.length > 0) {
                            lastResizeTime = now;

                            // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Çø„Éñ„ÅÆ„Åø„É™„Çµ„Ç§„Ç∫
                            if (tabState.activeTabId) {
                                setTimeout(() => setTerminalSize(tabState.activeTabId), 30);
                            }
                        }
                    });

                    // terminal-panes „Ç≥„É≥„ÉÜ„Éä„ÇíÁõ£Ë¶ñ
                    const panesContainer = document.getElementById('terminal-panes');
                    if (panesContainer) {
                        tabState.resizeObserver.observe(panesContainer);
                    }
                }

                // ÂÆöÊúüÁöÑ„Å™„Çµ„Ç§„Ç∫„ÉÅ„Çß„ÉÉ„ÇØÔºàVSCode „ÅÆÂà∂Á¥ÑÂØæÂøúÔºâ
                setTimeout(() => {
                    setTerminalSize(tabId);
                }, 2000);

                // CLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº„ÅÆË°®Á§∫Êõ¥Êñ∞
                function updateCliAgentIndicator() {
                    const indicator = document.getElementById('cli-agent-indicator');
                    if (indicator) {
                        if (state.cliAgentState.active) {
                            indicator.classList.add('active');
                            // „Ç®„Éº„Ç∏„Çß„É≥„ÉàÁ®ÆÂà•„Å´Âøú„Åò„Åü„É©„Éô„É´Ë°®Á§∫
                            if (state.cliAgentState.agent_type === 'claude') {
                                indicator.textContent = 'Claude';
                                indicator.title = 'Claude is active - Shift+Enter inputs a newline';
                            } else if (state.cliAgentState.agent_type === 'gemini') {
                                indicator.textContent = 'Gemini';
                                indicator.title = 'Gemini is active - Shift+Enter inputs a newline';
                            } else if (state.cliAgentState.agent_type === 'codex') {
                                indicator.textContent = 'Codex';
                                indicator.title = 'Codex is active - Shift+Enter sends Ctrl+J';
                            } else {
                                indicator.textContent = 'CLI Agent';
                                indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                            }
                        } else {
                            indicator.classList.remove('active');
                            indicator.textContent = 'CLI Agent';
                            indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                        }
                    }
                }

                // „Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂá¶ÁêÜÔºà„Åì„ÅÆ„Çø„ÉñÁî®Ôºâ
                function handleStatusMessage(data) {
                    try {
                        // CSI „Ç∑„Éº„Ç±„É≥„Çπ ]777; „ÅßÂßã„Åæ„Çã„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂá¶ÁêÜÔºàÂÆüÈöõ„ÅÆESCÊñáÂ≠ó„ÇíÊ§úÁ¥¢Ôºâ
                        if (data.includes('\x1b]777;')) {
                            // Ë§áÊï∞„ÅÆ„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„Å´ÂØæÂøú„Åô„Çã„Åü„ÇÅ matchAll „Çí‰ΩøÁî®
                            const matches = data.matchAll(/\x1b\]777;(.+?)\x07/g);
                            const matchesArray = [...matches];

                            for (const match of matchesArray) {
                                try {
                                    const messageJson = match[1];
                                    const message = JSON.parse(messageJson);

                                    if (message.type === 'cli_agent_status') {
                                        state.cliAgentState = message.data;
                                        // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çø„Éñ„ÅÆÂ†¥Âêà„ÅÆ„Åø„Ç§„É≥„Ç∏„Ç±„Éº„Çø„ÉºÊõ¥Êñ∞
                                        if (tabState.activeTabId === tabId) {
                                            updateCliAgentIndicator();
                                        }
                                    }

                                    if (message.type === 'foreground_process') {
                                        // „Éï„Ç©„Ç¢„Ç∞„É©„Ç¶„É≥„Éâ„Éó„É≠„Çª„ÇπÂêç„Åß„Çø„Éñ„Çø„Ç§„Éà„É´„ÇíÊõ¥Êñ∞
                                        const processName = message.data?.name;
                                        if (processName) {
                                            updateTabTitle(tabId, processName);
                                        }
                                    }

                                    if (message.type === 'log') {
                                        // Python „Åã„Çâ„ÅÆ„É≠„Ç∞„É°„ÉÉ„Çª„Éº„Ç∏„Çí VSCode ÂÅ¥„Å´Ëª¢ÈÄÅ
                                        vscode.postMessage({
                                            type: 'log',
                                            message: `[pty-shell.py] ${message.data}`
                                        });
                                    }
                                } catch (parseError) {
                                    // ÂÄãÂà•„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Éë„Éº„Çπ„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
                                    log('Individual message parse error:', parseError);
                                }
                            }
                        }
                    } catch (error) {
                        // JSON „Éë„Éº„Çπ„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
                        log('Status message parse error:', error);
                    }
                }

                // handleStatusMessage „Çí state „Å´‰øùÂ≠òÔºàoutput Âá¶ÁêÜ„Åß‰ΩøÁî®Ôºâ
                state.handleStatusMessage = handleStatusMessage;

                // Shift + Enter „Çí Alt + Enter „Å´Â§âÊèõ„Åô„Çã„Ç≠„Éº„Éè„É≥„Éâ„É©„Éº
                try {
                    if (typeof state.term.attachCustomKeyEventHandler === 'function') {
                        state.term.attachCustomKeyEventHandler(function (event) {
                            // ESC „Ç≠„Éº„ÅÆÂá¶ÁêÜÔºàvim „Å™„Å©ÂØæÂøúÔºâ
                            if (event.type === 'keydown' && event.key === 'Escape') {
                                // „Éñ„É©„Ç¶„Ç∂„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂãï‰Ωú„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                                event.preventDefault();
                                event.stopPropagation();

                                // Ê≠£„Åó„ÅÑ„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÈÄÅ‰ø°ÔºàtabId „ÇíÂê´„ÇÅ„ÇãÔºâ
                                vscode.postMessage({
                                    type: 'terminalInput',
                                    tabId: tabId,
                                    data: '\x1b'  // ESCÊñáÂ≠óÔºàASCII 27Ôºâ„ÇíÁ¢∫ÂÆü„Å´ÈÄÅ‰ø°
                                });

                                // false „ÇíËøî„Åó„Å¶„Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜ„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                                return false;
                            }

                            // Shift + Enter „ÅÆÂ†¥ÂêàÔºàCLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅåÂãï‰Ωú‰∏≠„ÅÆ„Å®„Åç„ÅÆ„ÅøÔºâ
                            if (event.type === 'keydown' &&
                                event.key === 'Enter' &&
                                event.shiftKey &&
                                !event.ctrlKey &&
                                !event.altKey &&
                                !event.metaKey) {

                                // CLI „Ç®„Éº„Ç∏„Çß„É≥„ÉàÔºàClaude/GeminiÔºâ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„ÅÆÂ†¥Âêà„ÅÆ„Åø Alt+Enter „Å´Â§âÊèõ
                                if (state.cliAgentState.active) {
                                    const agentType = state.cliAgentState.agent_type || 'CLI Agent';
                                    // „Éñ„É©„Ç¶„Ç∂„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂãï‰Ωú„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                                    event.preventDefault();
                                    event.stopPropagation();

                                    if (agentType === 'codex') {
                                        // Codex „É¢„Éº„Éâ: Ctrl+J „Çí„Ç®„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ (LF)
                                        const ctrlJ = '\n';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            tabId: tabId,
                                            data: ctrlJ
                                        });
                                    } else {
                                        // Êó¢Â≠ò„Ç®„Éº„Ç∏„Çß„É≥„Éà(Claude/Gemini): Alt+Enter „ÇíÈÄÅ‰ø° (ESC + CR)
                                        const altEnterSequence = '\x1b\r';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            tabId: tabId,
                                            data: altEnterSequence
                                        });
                                    }

                                    // false „ÇíËøî„Åó„Å¶„Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜ„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢
                                    return false;
                                } else {
                                    // CLI „Ç®„Éº„Ç∏„Çß„É≥„Éà„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Åß„Å™„ÅÑÂ†¥Âêà„ÅØÈÄöÂ∏∏„ÅÆ Enter „Å®„Åó„Å¶Âá¶ÁêÜ
                                    return true;
                                }
                            }

                            // „Åù„ÅÆ‰ªñ„ÅÆ„Ç≠„Éº„ÅØ„Éá„Éï„Ç©„É´„ÉàÂá¶ÁêÜ„ÇíÁ∂ôÁ∂ö
                            return true;
                        });
                    } else {
                        log('attachCustomKeyEventHandler is not available');
                    }
                } catch (error) {
                    log('Failed to attach custom key handler:', error);
                }

                // onData „ÅÆ„É™„Çπ„Éä„Éº„Çí‰øùÂ≠ò„Åó„Å¶Âæå„Åß dispose „Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã
                const dataListener = state.term.onData((data) => {
                    vscode.postMessage({
                        type: 'terminalInput',
                        tabId: tabId,
                        data: data
                    });
                });

                // dataListener „ÇíÁÆ°ÁêÜÂØæË±°„Å´ËøΩÂä†
                state.xtermListeners.push(dataListener);
                log('[LEAK CHECK] Added onData listener for tab:', tabId);

                // „Éö„Éº„Çπ„Éà„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÉºÔºàDOM „Ç§„Éô„É≥„Éà„Çí‰ΩøÁî®Ôºâ
                const pasteHandler = (event) => {
                    // „Éá„Éï„Ç©„É´„Éà„ÅÆ„Éö„Éº„Çπ„ÉàÂá¶ÁêÜ„ÇíÈòªÊ≠¢
                    event.preventDefault();

                    // „ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Åã„Çâ„Éá„Éº„Çø„ÇíÂèñÂæó
                    const clipboardData = event.clipboardData || window.clipboardData;
                    if (clipboardData && clipboardData.getData) {
                        const pastedText = clipboardData.getData('text');
                        if (pastedText) {
                            log('[PASTE] Intercepted paste event, length:', pastedText.length);
                            // Â§ßÈáè„Éö„Éº„Çπ„ÉàÊôÇ„ÅØ„ÉÅ„É£„É≥„ÇØÈÄÅ‰ø°„Åß„Éï„É≠„ÉºÂà∂Âæ°
                            sendBytesInChunks(new TextEncoder().encode(pastedText), { kind: 'paste' });
                        }
                    }
                };

                // „Çø„Éº„Éü„Éä„É´Ë¶ÅÁ¥†„Å´„Éö„Éº„Çπ„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†Ôºà„Çø„ÉñÂõ∫ÊúâÔºâ
                addManagedEventListener(terminalElement, 'paste', pasteHandler, state);
                log('[LEAK CHECK] Added DOM paste listener for tab:', tabId);

                // „É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©„Å® button „Éè„É≥„Éâ„É©„ÅØ initializeGlobalHandlers „ÅßÁôªÈå≤Ê∏à„Åø

                // ÂÆöÊúüÁöÑ„Å™„Éê„ÉÉ„Éï„Ç°„ÇØ„É™„Ç¢Ê©üËÉΩ„ÇíË®≠ÂÆö
                setupPeriodicBufferCleanup();

                // ÂàùÊúüÂåñÂÆå‰∫Ü„Éï„É©„Ç∞„ÅØÊó¢„Å´Ë®≠ÂÆöÊ∏à„Åø (state.isInitialized = true)

                // ÂÖ•Âäõ„Éï„Ç©„Éº„Ç´„Çπ„ÇíÊòéÁ§∫ÁöÑ„Å´‰∏é„Åà„Çã
                if (state.term) {
                    state.term.focus();
                }

                // VSCode ÂÅ¥„Å´Ê∫ñÂÇôÂÆå‰∫Ü„ÇíÈÄöÁü•Ôºà„Åì„Çå„Çí„Éà„É™„Ç¨„Å´„Ç∑„Çß„É´„ÇíËµ∑ÂãïÔºâ
                vscode.postMessage({ type: 'tabReady', tabId: tabId });

                // „Çø„ÉñÂ∞ÇÁî® ACE „Ç®„Éá„Ç£„Çø„ÇíÂàùÊúüÂåñ
                setTimeout(() => {
                    initializeAceEditorForTab(tabId);
                }, 100);

            } catch (error) {
                log('Error initializing terminal:', error);
                vscode.postMessage({ type: 'error', error: error.message });
                const pane = document.getElementById(`terminal-pane-${tabId}`);
                if (pane) {
                    pane.innerHTML = '<p style="color: red;">Error loading terminal: ' + error.message + '</p>';
                }
            }
        }

        // „Ç∞„É≠„Éº„Éê„É´„Éè„É≥„Éâ„É©„ÇíÂàùÊúüÂåñ
        initializeGlobalHandlers();

        // ÊúÄÂàù„ÅÆ„Çø„Éñ„Çí‰ΩúÊàê„Åó„Å¶„Çø„Éº„Éü„Éä„É´ÂàùÊúüÂåñ„ÇíÂÆüË°å
        const firstTabId = createNewTab();
        initializeTerminal(firstTabId);

        // ACE „Ç®„Éá„Ç£„Çø„ÅØ„Çø„Éñ‰ΩúÊàêÊôÇ„Å´ÂÄãÂà•ÂàùÊúüÂåñ„Åï„Çå„Çã (initializeAceEditorForTab)

    </script>
</body>

</html>