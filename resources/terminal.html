<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src {{CSP_SOURCE}} 'unsafe-inline'; script-src {{CSP_SOURCE}} 'unsafe-inline';">
    <title>Secondary Terminal</title>
    <link rel="stylesheet" href="{{XTERM_CSS_URI}}" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            height: 100%;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }
        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-editor-foreground);
            font-family: "RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "SF Mono", "Menlo", "Courier New", monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-container {
            flex: 1;
            width: 100%;
            min-height: 0; /* é‡è¦ï¼šflexboxã§å­è¦ç´ ãŒç¸®ã‚€ã®ã‚’è¨±å¯ */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* è¿½åŠ ï¼šã¯ã¿å‡ºã—é˜²æ­¢ */
        }

        #terminal {
            flex: 1;
            width: 100%;
            padding: 0 0 0 5px;
            min-height: 0; /* é‡è¦ï¼šflexboxã§ç¸®ã‚€ã®ã‚’è¨±å¯ */
            overflow: hidden; /* ã¯ã¿å‡ºã—é˜²æ­¢ */
        }
        .terminal.xterm {
            padding: 0;
        }

        /* xterm.js ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’é€æ˜ã« */
        .xterm .xterm-viewport {
            background-color: transparent !important;
        }

        .xterm .xterm-screen {
            background-color: transparent !important;
        }

        .xterm .xterm-helper-textarea {
            background-color: transparent !important;
        }

        /* CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¡¨ç¤º */
        .cli-agent-indicator {
            color: #888;
            font-size: 12px;
            transition: opacity 0.3s ease;
            opacity: 0;
        }

        .cli-agent-indicator.active {
            opacity: 1;
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« */
        .control-panel {
            flex-shrink: 0; /* é‡è¦ï¼šç¸®ã¾ãªã„ã‚ˆã†ã«å›ºå®š */
            background-color: var(--vscode-panel-background, #252526);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            padding: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: start;
            box-sizing: border-box;
        }
        .control-panel-left-controls{
            display: flex;
            align-items: center;
            justify-content: start;
            flex-grow: 1;
        }
        .control-panel-right-controls{
        }

        .control-button {
            background-color: var(--vscode-button-background, #0e639c);
            color: var(--vscode-button-foreground, #ffffff);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: background-color 0.2s;
        }

        .control-button {
            background-color: var(--vscode-button-secondaryBackground, #3c3c3c);
            color: var(--vscode-button-secondaryForeground, #cccccc);
        }

        .control-button:hover {
            background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
        }
    </style>
</head>
<body>
    <div class="terminal-container">

        <div id="terminal"></div>
        <!-- ä¸‹éƒ¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
        <div class="control-panel">
            <div class="control-panel-left-controls">
            <button class="control-button" id="btn-send-selection" title="Send editor selection to terminal (Cmd+L)">
                @Selection
            </button>
        </div>
            <div class="control-panel-right-controls">
                <!-- CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ -->
                <div class="cli-agent-indicator" id="cli-agent-indicator"
                  title="CLI Agent is active - Shift+Enter inputs a newline">CLI Agent</div>
            </div>
        </div>
    </div>

    <script src="{{XTERM_JS_URI}}"></script>
    <script src="{{XTERM_UNICODE11_JS_URI}}"></script>
    <script src="{{XTERM_CANVAS_JS_URI}}"></script>
    <script>
        const vscode = acquireVsCodeApi();

        try {
            console.log('Initializing terminal...');

            if (typeof Terminal === 'undefined') {
                throw new Error('Terminal is not defined. xterm.js may not have loaded.');
            }

            // ãƒ•ã‚©ãƒ³ãƒˆçµ±ä¸€ã®ãŸã‚ã®ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼å®šæ•°
            const TERMINAL_FONT_FAMILY = '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "SF Mono", "Menlo", "Courier New", monospace';
            
            const term = new Terminal({
            theme: {
                background: 'transparent',
                foreground: 'var(--vscode-terminal-foreground)',
                cursor: 'var(--vscode-terminal-cursor-foreground)',
                selection: 'var(--vscode-terminal-selection-background)'
            },
            fontFamily: TERMINAL_FONT_FAMILY,
            fontSize: 13,
            letterSpacing: 0,
            lineHeight: 1.2,
            cursorBlink: true,
            convertEol: true,
            allowProposedApi: true,
            allowTransparency: false,
            minimumContrastRatio: 1
        });

        const terminalElement = document.getElementById('terminal');
        term.open(terminalElement);

        // Unicode 11 ã‚¢ãƒ‰ã‚ªãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
        if (typeof Unicode11Addon !== 'undefined') {
            try {
                const unicode11 = new Unicode11Addon.Unicode11Addon();
                term.loadAddon(unicode11);
                unicode11.activate(term);
                console.log('Unicode 11 addon loaded and activated');
            } catch (error) {
                console.error('Failed to load Unicode 11 addon:', error);
            }
        }

        // Canvas ã‚¢ãƒ‰ã‚ªãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
        if (typeof CanvasAddon !== 'undefined') {
            try {
                const canvas = new CanvasAddon.CanvasAddon();
                term.loadAddon(canvas);
                console.log('Canvas addon loaded');
            } catch (error) {
                console.error('Failed to load Canvas addon:', error);
            }
        }

        // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«è¦ç´ ã®ã‚µã‚¤ã‚ºãŒç¢ºå®šã™ã‚‹ã¾ã§å¾…æ©Ÿ
        function waitForSize() {
            return new Promise((resolve) => {
                const checkSize = () => {
                    const rect = terminalElement.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        console.log('Terminal element size confirmed:', rect.width, 'x', rect.height);
                        resolve();
                    } else {
                        setTimeout(checkSize, 10);
                    }
                };
                checkSize();
            });
        }

        // ã‚µã‚¤ã‚ºç¢ºå®šå¾Œã«åˆæœŸè¨­å®š
        waitForSize().then(() => {
            // åˆæœŸã‚µã‚¤ã‚ºè¨­å®š
            setTerminalSize();
            console.log('Terminal initialized with DOM renderer');

            console.log('Terminal initialized with addons');
        });

        // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚µã‚¤ã‚ºã‚’å‹•çš„ã«è¨­å®šï¼ˆå…ƒã®æ‰‹å‹•è¨ˆç®—æ–¹å¼ï¼‰
        function setTerminalSize() {
            const container = document.querySelector('.terminal-container');
            const terminal = document.getElementById('terminal');

            if (!container || !terminal) {
                console.warn('Terminal container not found');
                return;
            }

            console.log('Container size:', container.clientWidth, 'x', container.clientHeight);
            console.log('Terminal size:', terminal.clientWidth, 'x', terminal.clientHeight);

            // ã‚³ãƒ³ãƒ†ãƒŠã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’å–å¾—
            const terminalRect = terminal.getBoundingClientRect();
            // ã‚ˆã‚Šæ­£ç¢ºãªãƒ‘ãƒ‡ã‚£ãƒ³ã‚°è¨ˆç®—ï¼ˆCSSã‹ã‚‰å®Ÿéš›ã®å€¤ã‚’å–å¾—ï¼‰
            const computedStyle = window.getComputedStyle(terminal);
            const paddingLeft = parseInt(computedStyle.paddingLeft) || 5;
            const paddingRight = parseInt(computedStyle.paddingRight) || 0;
            const paddingTop = parseInt(computedStyle.paddingTop) || 0;
            const paddingBottom = parseInt(computedStyle.paddingBottom) || 0;
            
            const availableWidth = terminalRect.width - paddingLeft - paddingRight;
            const availableHeight = terminalRect.height - paddingTop - paddingBottom;

            console.log('Available terminal size:', availableWidth, 'x', availableHeight);

            // ãƒ•ã‚©ãƒ³ãƒˆæƒ…å ±ã‹ã‚‰æ–‡å­—ã‚µã‚¤ã‚ºã‚’è¨ˆç®—ï¼ˆç’°å¢ƒå®‰å®šåŒ–å¯¾å¿œï¼‰
            const fontSize = 13;
            const targetLineHeight = 1.2; // Terminalè¨­å®šã¨åŒã˜è¡Œé–“

            // ä½¿ç”¨å¯èƒ½ãªãƒ•ã‚©ãƒ³ãƒˆã‚’æ¤œå‡º
            function detectAvailableFont() {
                const fontList = [
                    '"RobotoMono Nerd Font Mono"',
                    '"RobotoMono Nerd Font"', 
                    '"Roboto Mono"',
                    'Consolas',
                    '"SF Mono"', // macOS
                    '"Menlo"',   // macOS fallback
                    '"Courier New"',
                    'monospace'
                ];

                const testString = 'MMMMMMMMMMiiiiiiiiil1l1l1l1l1'; // ç­‰å¹…ãƒã‚§ãƒƒã‚¯ç”¨
                const testCanvas = document.createElement('canvas');
                const ctx = testCanvas.getContext('2d');
                
                for (const font of fontList) {
                    ctx.font = `${fontSize}px ${font}`;
                    const metrics = ctx.measureText(testString);
                    
                    // æ–‡å­—å¹…ã®ä¸€è²«æ€§ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆç­‰å¹…ãƒ•ã‚©ãƒ³ãƒˆã®ç¢ºèªï¼‰
                    const avgWidth = metrics.width / testString.length;
                    if (avgWidth > 0 && avgWidth < 20) { // åˆç†çš„ãªç¯„å›²
                        console.log(`Selected font: ${font}, avgWidth: ${avgWidth}`);
                        return { font, avgWidth };
                    }
                }
                
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                return { font: 'monospace', avgWidth: 8.0 };
            }

            const { font: detectedFont, avgWidth: baseCharWidth } = detectAvailableFont();

            // ãƒ‡ãƒã‚¤ã‚¹ãƒ”ã‚¯ã‚»ãƒ«æ¯”ã‚’è€ƒæ…®
            const devicePixelRatio = window.devicePixelRatio || 1;
            console.log('Device pixel ratio:', devicePixelRatio);

            // Canvas ãƒ™ãƒ¼ã‚¹ã®æ¸¬å®šå€¤
            let canvasCharWidth = baseCharWidth;
            let canvasLineHeight = fontSize * targetLineHeight;

            // RobotoMono Nerd Font Mono å›ºå®šå€¤ãƒ™ãƒ¼ã‚¹ï¼ˆ13pxæ™‚ã®å®Ÿæ¸¬å€¤ï¼‰
            // æ§˜ã€…ãªç’°å¢ƒã§ã®å®Ÿæ¸¬å¹³å‡å€¤ã‚’ä½¿ç”¨
            const ROBOTO_MONO_13PX_CHAR_WIDTH = 7.8; // å®Ÿæ¸¬å€¤
            const ROBOTO_MONO_13PX_LINE_HEIGHT = 15.6; // å®Ÿæ¸¬å€¤

            // Canvas æ¸¬å®šå€¤ãŒåˆç†çš„ç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
            const isCanvasReasonable = (
                canvasCharWidth >= 6.0 && canvasCharWidth <= 10.0 &&
                canvasLineHeight >= 12.0 && canvasLineHeight <= 20.0
            );

            let adjustedCharWidth, adjustedLineHeight;
            
            if (isCanvasReasonable) {
                // Canvas æ¸¬å®šå€¤ãŒåˆç†çš„ãªå ´åˆã¯ä½¿ç”¨ï¼ˆå¾®èª¿æ•´ã‚ã‚Šï¼‰
                adjustedCharWidth = canvasCharWidth * 0.98; // å¾®èª¿æ•´
                adjustedLineHeight = canvasLineHeight * 1.32;
                console.log('Using Canvas-based measurement');
            } else {
                // Canvas æ¸¬å®šå€¤ã«å•é¡ŒãŒã‚ã‚‹å ´åˆã¯å›ºå®šå€¤ã‚’ä½¿ç”¨
                adjustedCharWidth = ROBOTO_MONO_13PX_CHAR_WIDTH;
                adjustedLineHeight = ROBOTO_MONO_13PX_LINE_HEIGHT;
                console.log('Canvas measurement unreliable, using fixed values');
            }

            // ãƒ‡ãƒã‚¤ã‚¹ãƒ”ã‚¯ã‚»ãƒ«æ¯”ã«ã‚ˆã‚‹å¾®èª¿æ•´
            if (devicePixelRatio > 1.5) {
                adjustedCharWidth *= 0.99; // é«˜è§£åƒåº¦ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã§ã¯å°‘ã—è©°ã‚ã‚‹
            }

            // åˆ—æ•°ã¨è¡Œæ•°ã‚’è¨ˆç®—
            const cols = Math.floor(availableWidth / adjustedCharWidth);
            const rows = Math.floor(availableHeight / adjustedLineHeight);

            // è©³ç´°ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’åé›†
            const debugInfo = {
                // ç’°å¢ƒæƒ…å ±
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                devicePixelRatio: devicePixelRatio,
                screenWidth: window.screen.width,
                screenHeight: window.screen.height,
                
                // ãƒ•ã‚©ãƒ³ãƒˆæ¸¬å®šæƒ…å ±
                detectedFont: detectedFont,
                baseCharWidth: baseCharWidth,
                canvasCharWidth: canvasCharWidth,
                canvasLineHeight: canvasLineHeight,
                isCanvasReasonable: isCanvasReasonable,
                
                // æœ€çµ‚è¨ˆç®—å€¤
                adjustedCharWidth: adjustedCharWidth,
                adjustedLineHeight: adjustedLineHeight,
                
                // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæƒ…å ±
                terminalRect: {
                    width: terminalRect.width,
                    height: terminalRect.height
                },
                padding: { paddingLeft, paddingRight, paddingTop, paddingBottom },
                availableWidth: availableWidth,
                availableHeight: availableHeight,
                
                // æœ€çµ‚çµæœ
                calculatedCols: cols,
                calculatedRows: rows,
                finalCols: Math.max(cols, 20),
                finalRows: Math.max(rows, 5)
            };
            
            console.log('=== TERMINAL SIZE DEBUG INFO ===');
            console.log(JSON.stringify(debugInfo, null, 2));
            console.log('================================');

            // æ—§å½¢å¼ã®ãƒ­ã‚°ã‚‚ç¶­æŒï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
            console.log('Font detection - selected:', detectedFont, 'baseCharWidth:', baseCharWidth);
            console.log('Adjusted metrics - charWidth:', adjustedCharWidth, 'lineHeight:', adjustedLineHeight);
            console.log('Padding - left:', paddingLeft, 'right:', paddingRight, 'top:', paddingTop, 'bottom:', paddingBottom);
            console.log('Calculated terminal size:', cols, 'x', rows);

            // æœ€å°ã‚µã‚¤ã‚ºã‚’ä¿è¨¼
            const finalCols = Math.max(cols, 20);
            const finalRows = Math.max(rows, 5);

            // å¹…ã®ä½¿ç”¨åŠ¹ç‡ã‚’ãƒã‚§ãƒƒã‚¯
            const actualUsedWidth = finalCols * adjustedCharWidth;
            const widthEfficiency = (actualUsedWidth / availableWidth * 100).toFixed(1);
            console.log(`Width efficiency: ${widthEfficiency}% (${actualUsedWidth.toFixed(1)}px used of ${availableWidth.toFixed(1)}px available)`);
            
            // ã‚‚ã—åŠ¹ç‡ãŒ90%æœªæº€ãªã‚‰è­¦å‘Š
            if (widthEfficiency < 90) {
                console.warn(`âš ï¸ Low width efficiency: ${widthEfficiency}% - consider adjusting charWidth calculation`);
                
                // ã‚ˆã‚ŠåŠ¹ç‡çš„ãªæ–‡å­—å¹…ã‚’ææ¡ˆ
                const suggestedCharWidth = availableWidth / finalCols;
                console.log(`ğŸ’¡ Suggested charWidth for better efficiency: ${suggestedCharWidth.toFixed(2)}px (current: ${adjustedCharWidth.toFixed(2)}px)`);
            }

            // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚µã‚¤ã‚ºã‚’è¨­å®š
            if (term.cols !== finalCols || term.rows !== finalRows) {
                term.resize(finalCols, finalRows);

                // ã‚µã‚¤ã‚ºå¤‰æ›´ã‚’ VSCode ã«é€šçŸ¥
                vscode.postMessage({
                    type: 'resize',
                    cols: finalCols,
                    rows: finalRows
                });

                console.log('Terminal resized to:', finalCols, 'x', finalRows);
            }
        }

        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ™‚ã®å‡¦ç†
        window.addEventListener('resize', () => {
            setTimeout(setTerminalSize, 50);
        });

        // ResizeObserver ã§ã‚³ãƒ³ãƒ†ãƒŠã‚µã‚¤ã‚ºå¤‰æ›´ã‚’ç›£è¦–
        const resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
                console.log('Container resized:', entry.contentRect.width, 'x', entry.contentRect.height);
                setTimeout(setTerminalSize, 50);
            }
        });

        // terminal-container ã‚’ç›£è¦–
        const container = document.querySelector('.terminal-container');
        if (container) {
            resizeObserver.observe(container);
        }

        // å®šæœŸçš„ãªã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆVSCode ã®åˆ¶ç´„å¯¾å¿œï¼‰
        setInterval(setTerminalSize, 2000);

        let cliAgentState = {active: false, agent_type: null}; // CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®çŠ¶æ…‹

        // CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®è¡¨ç¤ºæ›´æ–°
        function updateCliAgentIndicator() {
            const indicator = document.getElementById('cli-agent-indicator');
            if (indicator) {
                if (cliAgentState.active) {
                    indicator.classList.add('active');
                    // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç¨®åˆ¥ã«å¿œã˜ãŸãƒ©ãƒ™ãƒ«è¡¨ç¤º
                    if (cliAgentState.agent_type === 'claude') {
                        indicator.textContent = 'Claude';
                        indicator.title = 'Claude is active - Shift+Enter inputs a newline';
                    } else if (cliAgentState.agent_type === 'gemini') {
                        indicator.textContent = 'Gemini';
                        indicator.title = 'Gemini is active - Shift+Enter inputs a newline';
                    } else {
                        indicator.textContent = 'CLI Agent';
                        indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                    }
                } else {
                    indicator.classList.remove('active');
                    indicator.textContent = 'CLI Agent';
                    indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                }
            }
        }

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
        function handleStatusMessage(data) {
            try {
                // CSI ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ]777; ã§å§‹ã¾ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†ï¼ˆå®Ÿéš›ã®ESCæ–‡å­—ã‚’æ¤œç´¢ï¼‰
                if (data.includes('\x1b]777;')) {
                    const match = data.match(/\x1b\]777;(.+?)\x07/);
                    if (match) {
                        const messageJson = match[1];
                        const message = JSON.parse(messageJson);

                        if (message.type === 'cli_agent_status') {
                            cliAgentState = message.data;
                            console.log('CLI Agent status changed:', cliAgentState);
                            updateCliAgentIndicator(); // ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼è¡¨ç¤ºã‚’æ›´æ–°
                        }
                    }
                }
            } catch (error) {
                // JSON ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                console.debug('Status message parse error:', error);
            }
        }

        // Shift + Enter ã‚’ Alt + Enter ã«å¤‰æ›ã™ã‚‹ã‚­ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        try {
            if (typeof term.attachCustomKeyEventHandler === 'function') {
                console.log('Setting up custom key handler for Shift+Enter');

                term.attachCustomKeyEventHandler(function(event) {
                    // Shift + Enter ã®å ´åˆï¼ˆCLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå‹•ä½œä¸­ã®ã¨ãã®ã¿ï¼‰
                    if (event.type === 'keydown' &&
                        event.key === 'Enter' &&
                        event.shiftKey &&
                        !event.ctrlKey &&
                        !event.altKey &&
                        !event.metaKey) {

                        // CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆClaude/Geminiï¼‰ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã®å ´åˆã®ã¿ Alt+Enter ã«å¤‰æ›
                        if (cliAgentState.active) {
                            const agentType = cliAgentState.agent_type || 'CLI Agent';
                            console.log(`Shift+Enter detected (${agentType} active), sending Alt+Enter sequence`);

                            // ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’å®Œå…¨ã«åœæ­¢
                            event.preventDefault();
                            event.stopPropagation();

                            // Alt + Enter ã®æ­£ã—ã„ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’é€ä¿¡
                            // ESC [ 1 3 ; 3 ~ (Alt+Enter ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚·ãƒ¼ã‚±ãƒ³ã‚¹)
                            var altEnterSequence = '\x1b\r';

                            vscode.postMessage({
                                type: 'terminalInput',
                                data: altEnterSequence
                            });

                            // false ã‚’è¿”ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†ã‚’å®Œå…¨ã«åœæ­¢
                            return false;
                        } else {
                            // CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ãªã„å ´åˆã¯é€šå¸¸ã® Enter ã¨ã—ã¦å‡¦ç†
                            console.log('Shift+Enter detected (CLI Agent not active), processing as normal Enter');
                            return true;
                        }
                    }

                    // ãã®ä»–ã®ã‚­ãƒ¼ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†ã‚’ç¶™ç¶š
                    return true;
                });

                console.log('Custom key handler attached successfully');
            } else {
                console.warn('attachCustomKeyEventHandler is not available');
            }
        } catch (error) {
            console.error('Failed to attach custom key handler:', error);
        }

        term.onData((data) => {
            vscode.postMessage({
                type: 'terminalInput',
                data: data
            });
        });

        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.type) {
                case 'output':
                    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒã‚§ãƒƒã‚¯
                    handleStatusMessage(message.data);
                    // é€šå¸¸ã®å‡ºåŠ›ã¨ã—ã¦æ›¸ãè¾¼ã¿
                    term.write(message.data);
                    break;
                case 'clear':
                    term.clear();
                    break;
            }
        });


        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®š
        document.getElementById('btn-send-selection').addEventListener('click', () => {
            vscode.postMessage({ type: 'buttonSendSelection' });
            // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯å¾Œã«ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç§»å‹•
            term.focus();
        });

        vscode.postMessage({ type: 'terminalReady' });

        console.log('Terminal initialized successfully');

        } catch (error) {
            console.error('Error initializing terminal:', error);
            vscode.postMessage({ type: 'error', error: error.message });
            document.getElementById('terminal').innerHTML = '<p style="color: red;">Error loading terminal: ' + error.message + '</p>';
        }
    </script>
</body>
</html>
