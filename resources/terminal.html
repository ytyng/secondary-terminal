<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; style-src {{CSP_SOURCE}} 'unsafe-inline'; script-src {{CSP_SOURCE}} 'unsafe-inline';">
    <title>Secondary Terminal</title>
    <link rel="stylesheet" href="{{XTERM_CSS_URI}}" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }

        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background-color: var(--vscode-sideBar-background);
            color: var(--vscode-editor-foreground);
            font-family: "RobotoMono Nerd Font Mono", "Roboto Mono", Consolas, "Courier New", monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-container {
            flex: 1;
            width: 100%;
            min-height: 0;
            /* é‡è¦ï¼šflexboxã§å­è¦ç´ ãŒç¸®ã‚€ã®ã‚’è¨±å¯ */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* è¿½åŠ ï¼šã¯ã¿å‡ºã—é˜²æ­¢ */
        }

        #terminal {
            flex: 1;
            width: 100%;
            padding: 0 0 0 5px;
            min-height: 0;
            /* é‡è¦ï¼šflexboxã§ç¸®ã‚€ã®ã‚’è¨±å¯ */
            overflow: hidden;
            /* ã¯ã¿å‡ºã—é˜²æ­¢ */
        }

        .terminal.xterm {
            padding: 0;

            /* xterm.js ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’é€æ˜ã« */
            .xterm-viewport {
                background-color: transparent !important;
            }

            .xterm-screen {
                background-color: transparent !important;
            }

            .xterm-helper-textarea {
                background-color: transparent !important;
            }
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« */
        .control-panel {
            flex-shrink: 0;
            /* é‡è¦ï¼šç¸®ã¾ãªã„ã‚ˆã†ã«å›ºå®š */
            background-color: var(--vscode-panel-background, #252526);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            padding: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: start;
            box-sizing: border-box;
        }

        .control-panel-left-controls {
            display: flex;
            align-items: center;
            justify-content: start;
            flex-grow: 1;
            gap: 0.5em;
        }

        .control-panel-right-controls {
            display: flex;
            align-items: center;
            justify-content: end;
            padding: 0.5em;
            gap: 0.5em;
        }

        .control-button {
            background-color: var(--vscode-button-secondaryBackground, #3c3c3c);
            color: var(--vscode-button-secondaryForeground, #cccccc);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: background-color 0.2s;

            &:hover {
                background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
            }
        }

        .copy-button {
            background-color: var(--vscode-button-secondaryBackground, #3c3c3c);
            color: var(--vscode-button-secondaryForeground, #cccccc);
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: background-color 0.2s;
            position: relative;

            &:hover {
                background-color: var(--vscode-button-secondaryHoverBackground, #4c4c4c);
            }

            &.done {
                color: transparent;
            }

            &.done::after {
                content: 'âœ“';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: var(--vscode-button-secondaryForeground, #cccccc);
            }
        }

        .reset-button {
            background: transparent;
            color: var(--vscode-button-secondaryForeground, #cccccc);
            border: none;
            font-family: inherit;
            font-size: 12px;
            opacity: 0.5;

            &:hover {
                opacity: 1;
            }
        }

        /* CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¡¨ç¤º */
        .cli-agent-indicator {
            color: #888;
            font-family: inherit;
            font-size: 12px;
            transition: opacity 0.3s ease;
            opacity: 0;

            &.active {
                opacity: 1;
            }
        }

        /* ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬ HUD */
        .performance-hud {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.85);
            color: #00ff00;
            font-family: "RobotoMono Nerd Font Mono", "Roboto Mono", Consolas, "Courier New", monospace;
            font-size: 11px;
            padding: 10px 12px;
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            z-index: 10000;
            min-width: 220px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            display: none;

            &.visible {
                display: block;
            }
        }

        .performance-hud-title {
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
            color: #00ffff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .performance-hud-close {
            background: none;
            border: none;
            color: #ff6666;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            margin: 0;
            line-height: 1;
            transition: color 0.2s;

            &:hover {
                color: #ff3333;
            }
        }

        .performance-hud-item {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            line-height: 1.4;

            .label {
                color: #aaaaaa;
            }

            .value {
                color: #00ff00;
                font-weight: bold;
            }
        }

        .performance-hud-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.5);
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            z-index: 9999;
            transition: background-color 0.2s;

            &:hover {
                background-color: rgba(0, 255, 0, 0.3);
            }
        }

        /* ACE ã‚¨ãƒ‡ã‚£ã‚¿ã‚³ãƒ³ãƒ†ãƒŠ */
        .editor-container {
            flex-shrink: 0;
            background-color: var(--vscode-editor-background);
            border-top: 1px solid var(--vscode-panel-border, #3c3c3c);
            border-bottom: 1px solid var(--vscode-panel-border, #3c3c3c);
            height: 200px;
            overflow: hidden;
        }

        #ace-editor {
            width: 100%;
            height: 100%;
        }

        /* ã‚«ã‚¹ã‚¿ãƒ  ACE ãƒ†ãƒ¼ãƒ - VSCode ãƒ€ãƒ¼ã‚¯é¢¨ */
        .ace-vscode-dark {
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);

            .ace_gutter {
                background-color: var(--vscode-editorGutter-background);
                color: var(--vscode-editorLineNumber-foreground);
                border-right: 1px solid var(--vscode-panel-border, #3c3c3c);
            }

            .ace_print-margin {
                width: 1px;
                background: var(--vscode-editorRuler-foreground);
            }

            .ace_cursor {
                color: var(--vscode-editorCursor-foreground);
            }

            .ace_marker-layer {
                .ace_selection {
                    background: var(--vscode-editor-selectionBackground);
                }

                .ace_step {
                    background: var(--vscode-debugTokenExpression-number);
                }

                .ace_bracket {
                    margin: -1px 0 0 -1px;
                    border: 1px solid var(--vscode-editorBracketMatch-border);
                    background: var(--vscode-editorBracketMatch-background);
                }

                .ace_active-line {
                    background: var(--vscode-editor-lineHighlightBackground);
                }

                .ace_selected-word {
                    border: 1px solid var(--vscode-editor-selectionHighlightBorder);
                    background: var(--vscode-editor-selectionHighlightBackground);
                }
            }

            &.ace_multiselect .ace_selection.ace_start {
                box-shadow: 0 0 3px 0px var(--vscode-editor-background);
                border-radius: 2px;
            }

            .ace_gutter-active-line {
                background-color: var(--vscode-editor-lineHighlightBackground);
            }

            .ace_invisible {
                color: var(--vscode-editorWhitespace-foreground, #404040);
            }

            .ace_keyword,
            .ace_meta,
            .ace_storage,
            .ace_storage.ace_type,
            .ace_support.ace_type {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_keyword.ace_operator {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_constant.ace_character,
            .ace_constant.ace_language,
            .ace_constant.ace_numeric,
            .ace_keyword.ace_other.ace_unit,
            .ace_support.ace_constant,
            .ace_variable.ace_parameter {
                color: var(--vscode-debugTokenExpression-number);
            }

            .ace_constant.ace_other {
                color: var(--vscode-debugTokenExpression-number);
            }

            .ace_invalid {
                color: var(--vscode-editorError-foreground);
                background-color: var(--vscode-editorError-background);

                &.ace_deprecated {
                    color: var(--vscode-editorWarning-foreground);
                    background-color: var(--vscode-editorWarning-background);
                }
            }

            .ace_fold {
                background-color: var(--vscode-debugTokenExpression-name);
                border-color: var(--vscode-debugTokenExpression-name);
            }

            .ace_entity.ace_name.ace_function,
            .ace_support.ace_function,
            .ace_variable {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_support.ace_class,
            .ace_support.ace_type {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_heading,
            .ace_markup.ace_heading {
                color: var(--vscode-debugTokenExpression-name);
                font-weight: bold;
            }

            .ace_list,
            .ace_markup.ace_list {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_list.ace_markup {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_punctuation.ace_definition.ace_list_begin {
                color: var(--vscode-debugTokenExpression-value);
            }

            .ace_entity.ace_name.ace_tag,
            .ace_entity.ace_other.ace_attribute-name,
            .ace_meta.ace_tag,
            .ace_string.ace_regexp,
            .ace_variable {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_comment {
                color: var(--vscode-debugConsole-infoForeground);
                font-style: italic;
            }

            .ace_string {
                color: var(--vscode-debugTokenExpression-string);
            }

            .ace_entity.ace_other.ace_attribute-name {
                color: var(--vscode-debugTokenExpression-name);
            }

            .ace_indent-guide {
                background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChAGGzJY5NwAAAABJRU5ErkJggg==") right repeat-y;
            }
        }
    </style>
</head>

<body>
    <!-- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ HUD ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ -->
    <button class="performance-hud-toggle" id="perf-hud-toggle" title="Toggle Performance HUD">ğŸ“Š</button>

    <!-- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ HUD -->
    <div class="performance-hud" id="perf-hud">
        <div class="performance-hud-title">
            <span>ğŸ“Š Performance Metrics</span>
            <button class="performance-hud-close" id="perf-hud-close" title="Close Performance HUD">Ã—</button>
        </div>
        <div class="performance-hud-item">
            <span class="label">Buffer:</span>
            <span class="value" id="hud-buffer-size">0 KB</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Scrollback:</span>
            <span class="value" id="hud-scrollback">0 lines</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Buffer Chars:</span>
            <span class="value" id="hud-buffer-chars">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">DOM Nodes:</span>
            <span class="value" id="hud-dom-nodes">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Child Procs:</span>
            <span class="value" id="hud-child-procs">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Write Avg:</span>
            <span class="value" id="hud-write-avg">0 ms</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Write Max:</span>
            <span class="value" id="hud-write-max">0 ms</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Output:</span>
            <span class="value" id="hud-output-count">0 msgs</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Total Chars (ç´¯ç©):</span>
            <span class="value" id="hud-total-chars">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Resize:</span>
            <span class="value" id="hud-resize-count">0</span>
        </div>
        <div class="performance-hud-item">
            <span class="label">Session:</span>
            <span class="value" id="hud-session-time">0s</span>
        </div>
    </div>

    <div class="terminal-container" id="terminal-container">

        <div id="terminal"></div>

        <!-- ACE ã‚¨ãƒ‡ã‚£ã‚¿ãƒšã‚¤ãƒ³ -->
        <div class="editor-container">
            <div id="ace-editor"></div>
        </div>

        <!-- ä¸‹éƒ¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
        <div class="control-panel">
            <div class="control-panel-left-controls">
                <button class="control-button" id="btn-send-selection"
                    title="Send editor selection to terminal (Cmd+L)">
                    @Selection
                </button>
                <button class="copy-button" id="btn-copy-selection" title="Copy editor selection context to clipboard">
                    Copy
                </button>
                <button class="control-button" id="btn-scroll-to-bottom" title="Scroll to bottom of terminal">
                    â†“
                </button>
            </div>
            <div class="control-panel-right-controls">
                <!-- CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ -->
                <div class="cli-agent-indicator" id="cli-agent-indicator"
                    title="CLI Agent is active - Shift+Enter inputs a newline">CLI Agent</div>
                <button id="reset-button" class="reset-button">Reset</button>
            </div>
        </div>
    </div>

    <script src="{{XTERM_JS_URI}}"></script>
    <script src="{{XTERM_UNICODE11_JS_URI}}"></script>
    <script src="{{XTERM_CANVAS_JS_URI}}"></script>

    <!-- ACE Editor Scripts -->
    <script src="{{ACE_JS_URI}}"></script>
    <script src="{{ACE_MODE_JAVASCRIPT_URI}}"></script>
    <script src="{{ACE_MODE_MARKDOWN_URI}}"></script>
    <script src="{{ACE_KEYBINDING_VSCODE_URI}}"></script>
    <script>
        const MAX_BUFFER_LINES = parseInt('{{SCROLLBACK_MAX}}'); // è¨­å®šã•ã‚ŒãŸæœ€å¤§è¡Œæ•°
        const vscode = acquireVsCodeApi();

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç®¡ç†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        const terminalState = {
            term: null,
            resizeObserver: null,
            timers: {
                sizeCheckInterval: null,
                backgroundColorInterval: null,
                writeBuffer: null
            },
            eventListeners: [],
            isInitialized: false,
            writeBufferData: '',
            writeBufferPending: false
        };

        // ACE ã‚¨ãƒ‡ã‚£ã‚¿ç”¨ã®çŠ¶æ…‹ç®¡ç†
        const editorState = {
            editor: null,
            isInitialized: false
        };

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬ç”¨ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        const performanceMetrics = {
            // ãƒ¡ãƒ¢ãƒªé–¢é€£
            writeBufferSize: 0,
            scrollbackLines: 0,
            terminalBufferSize: 0,
            bufferCharCount: 0,      // xterm.js ãƒãƒƒãƒ•ã‚¡ã®ç·æ–‡å­—æ•°
            domNodeCount: 0,         // DOM ãƒãƒ¼ãƒ‰æ•°

            // ãƒ—ãƒ­ã‚»ã‚¹é–¢é€£
            childProcessCount: 0,    // å­ãƒ—ãƒ­ã‚»ã‚¹æ•°

            // å‡¦ç†æ™‚é–“é–¢é€£
            lastWriteTime: 0,
            avgWriteTime: 0,
            maxWriteTime: 0,
            writeTimeSum: 0,
            writeTimeCount: 0,

            // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
            outputCount: 0,
            totalOutputChars: 0,
            resizeObserverCount: 0,

            // ã‚¿ã‚¤ãƒŸãƒ³ã‚°
            sessionStartTime: Date.now(),
            lastUpdateTime: Date.now()
        };

        // HUD æ›´æ–°é–¢æ•°
        function updatePerformanceHUD() {
            try {
                // ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’å–å¾—
                if (terminalState.term && terminalState.term.buffer) {
                    const buffer = terminalState.term.buffer.active;
                    if (buffer) {
                        performanceMetrics.scrollbackLines = buffer.length - (terminalState.term.rows || 24);
                        performanceMetrics.terminalBufferSize = buffer.length;

                        // xterm.js ãƒãƒƒãƒ•ã‚¡ã®ç·æ–‡å­—æ•°ã‚’è¨ˆç®—
                        performanceMetrics.bufferCharCount = buffer.length * (terminalState.term.cols || 80);
                    }
                }

                // DOM ãƒãƒ¼ãƒ‰æ•°ã‚’å–å¾—
                const terminalElement = document.querySelector('#terminal');
                if (terminalElement) {
                    performanceMetrics.domNodeCount = terminalElement.querySelectorAll('*').length;
                }

                // å„è¦ç´ ã‚’æ›´æ–°
                document.getElementById('hud-buffer-size').textContent =
                    (performanceMetrics.writeBufferSize / 1024).toFixed(2) + ' KB';

                document.getElementById('hud-scrollback').textContent =
                    performanceMetrics.scrollbackLines + ' lines';

                document.getElementById('hud-buffer-chars').textContent =
                    (performanceMetrics.bufferCharCount / 1000).toFixed(1) + 'K';

                document.getElementById('hud-dom-nodes').textContent =
                    performanceMetrics.domNodeCount.toString();

                document.getElementById('hud-child-procs').textContent =
                    performanceMetrics.childProcessCount.toString();

                document.getElementById('hud-write-avg').textContent =
                    performanceMetrics.avgWriteTime.toFixed(2) + ' ms';

                document.getElementById('hud-write-max').textContent =
                    performanceMetrics.maxWriteTime.toFixed(2) + ' ms';

                document.getElementById('hud-output-count').textContent =
                    performanceMetrics.outputCount + ' msgs';

                document.getElementById('hud-total-chars').textContent =
                    (performanceMetrics.totalOutputChars / 1024).toFixed(1) + ' KB';

                document.getElementById('hud-resize-count').textContent =
                    performanceMetrics.resizeObserverCount.toString();

                // ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“ã‚’è¨ˆç®—
                const sessionDuration = (Date.now() - performanceMetrics.sessionStartTime) / 1000;
                const minutes = Math.floor(sessionDuration / 60);
                const seconds = Math.floor(sessionDuration % 60);
                document.getElementById('hud-session-time').textContent =
                    minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;

                performanceMetrics.lastUpdateTime = Date.now();
            } catch (error) {
                console.error('[PERF HUD] Error updating HUD:', error);
            }
        }

        // HUD è¡¨ç¤ºãƒˆã‚°ãƒ«æ©Ÿèƒ½
        function setupPerformanceHUD() {
            const hudElement = document.getElementById('perf-hud');
            const toggleButton = document.getElementById('perf-hud-toggle');
            const closeButton = document.getElementById('perf-hud-close');

            // ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            toggleButton.addEventListener('click', () => {
                hudElement.classList.toggle('visible');

                // è¡¨ç¤ºçŠ¶æ…‹ã‚’ localStorage ã«ä¿å­˜
                const isVisible = hudElement.classList.contains('visible');
                localStorage.setItem('performanceHUDVisible', isVisible ? 'true' : 'false');
            });

            // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            closeButton.addEventListener('click', () => {
                hudElement.classList.remove('visible');

                // è¡¨ç¤ºçŠ¶æ…‹ã‚’ localStorage ã«ä¿å­˜
                localStorage.setItem('performanceHUDVisible', 'false');
            });

            // åˆæœŸçŠ¶æ…‹ã‚’ localStorage ã‹ã‚‰å¾©å…ƒ
            const savedState = localStorage.getItem('performanceHUDVisible');
            if (savedState === 'true') {
                hudElement.classList.add('visible');
            }

            // 500ms ã”ã¨ã« HUD ã‚’æ›´æ–°
            setInterval(updatePerformanceHUD, 500);
        }

        // ACE ã‚¨ãƒ‡ã‚£ã‚¿åˆæœŸåŒ–é–¢æ•°
        function initializeAceEditor() {
            try {
                if (editorState.isInitialized) {
                    console.warn('[ACE] Editor is already initialized');
                    return;
                }

                if (typeof ace === 'undefined') {
                    throw new Error('ACE is not defined. ace-builds may not have loaded.');
                }

                console.log('[ACE] Starting editor initialization');

                // VSCode ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒã‚’ ACE ã«ç™»éŒ²
                if (ace.define) {
                    ace.define('ace/theme/vscode-dark', ['require', 'exports', 'module'], function(require, exports, module) {
                        exports.isDark = true;
                        exports.cssClass = "ace-vscode-dark";
                        exports.cssText = ""; // CSS ã¯ HTML ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§å®šç¾©æ¸ˆã¿
                    });
                }

                // ã‚¨ãƒ‡ã‚£ã‚¿ã‚’åˆæœŸåŒ–
                editorState.editor = ace.edit("ace-editor");

                // è¨­å®šã‚’é©ç”¨
                editorState.editor.setTheme("ace/theme/vscode-dark");
                editorState.editor.session.setMode("ace/mode/markdown");
                // VSCode ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆï¼ˆç«¶åˆã™ã‚‹å¯èƒ½æ€§ï¼‰
                // editorState.editor.setKeyboardHandler("ace/keyboard/vscode");

                // ã‚¨ãƒ‡ã‚£ã‚¿ã‚ªãƒ—ã‚·ãƒ§ãƒ³
                editorState.editor.setOptions({
                    fontSize: 13,
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    showPrintMargin: false,
                    wrap: true,
                    showInvisibles: true,
                    enableBasicAutocompletion: true,
                    enableLiveAutocompletion: true,
                    enableSnippets: true
                });

                // åˆæœŸå€¤ã‚’è¨­å®šï¼ˆæ°¸ç¶šåŒ–ã•ã‚ŒãŸå€¤ãŒã‚ã‚Œã°å¾©å…ƒï¼‰
                const savedContent = vscode.getState()?.editorContent || '';
                editorState.editor.setValue(savedContent, -1); // -1 ã§ã‚«ãƒ¼ã‚½ãƒ«ã‚’å…ˆé ­ã«

                // Command+Enter ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ã‚’è¿½åŠ 
                editorState.editor.commands.addCommand({
                    name: 'sendToTerminal',
                    bindKey: { win: 'Ctrl-Enter', mac: 'Cmd-Enter' },
                    exec: function(editor) {
                        console.log('[ACE] Command+Enter pressed');
                        const content = editor.getValue();
                        console.log('[ACE] Editor content:', content);

                        if (content.trim()) {
                            console.log('[ACE] Processing content for terminal...');

                            // 1. æœ«å°¾ã®ãƒ›ãƒ¯ã‚¤ãƒˆã‚¹ãƒšãƒ¼ã‚¹ï¼ˆæ”¹è¡Œå«ã‚€ï¼‰ã‚’é™¤å»
                            const trimmedContent = content.trimEnd();
                            console.log('[ACE] Trimmed content:', trimmedContent);

                            // 2. ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã«é€ä¿¡
                            console.log('[ACE] Sending content to terminal');
                            vscode.postMessage({
                                type: 'editorSendContent',
                                data: trimmedContent
                            });
                            console.log('[ACE] Content sent to terminal');

                            // 3. 200ms å¾…æ©Ÿå¾Œã« Enter ã‚’é€ä¿¡
                            setTimeout(() => {
                                console.log('[ACE] Sending Enter after 200ms');
                                vscode.postMessage({
                                    type: 'terminalInput',
                                    data: '\r'
                                });
                                console.log('[ACE] Enter sent to terminal');

                                // 4. ã‚¨ãƒ‡ã‚£ã‚¿ã®å†…å®¹ã‚’ã‚¯ãƒªã‚¢
                                editor.setValue('', -1);
                                console.log('[ACE] Editor content cleared');
                            }, 200);
                        } else {
                            console.log('[ACE] Editor content is empty, not sending');
                        }
                    }
                });

                // ã‚¨ãƒ‡ã‚£ã‚¿ã®å†…å®¹ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚ã®å‡¦ç†
                editorState.editor.on('change', function() {
                    const content = editorState.editor.getValue();
                    // å†…å®¹ã‚’æ°¸ç¶šåŒ–
                    vscode.setState({
                        ...vscode.getState(),
                        editorContent: content
                    });
                });

                // DOM ãƒ¬ãƒ™ãƒ«ã§ã®ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ã‚’è¿½åŠ ï¼ˆACE ã®ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚ˆã‚Šå„ªå…ˆåº¦é«˜ï¼‰
                const aceContainer = document.getElementById('ace-editor');
                if (aceContainer) {
                    aceContainer.addEventListener('keydown', function(event) {
                        // Command+Enter (Mac) ã¾ãŸã¯ Ctrl+Enter (Windows) ã‚’ã‚­ãƒ£ãƒƒãƒ
                        if (event.key === 'Enter' && (event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey) {
                            console.log('[ACE DOM] Command+Enter detected');
                            event.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã‚’é˜»æ­¢
                            event.stopPropagation(); // ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’åœæ­¢

                            const content = editorState.editor.getValue();
                            console.log('[ACE DOM] Editor content:', content);

                            if (content.trim()) {
                                console.log('[ACE DOM] Processing content for terminal...');

                                // 1. æœ«å°¾ã®ãƒ›ãƒ¯ã‚¤ãƒˆã‚¹ãƒšãƒ¼ã‚¹ï¼ˆæ”¹è¡Œå«ã‚€ï¼‰ã‚’é™¤å»
                                const trimmedContent = content.trimEnd();
                                console.log('[ACE DOM] Trimmed content:', trimmedContent);

                                // 2. ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã«é€ä¿¡
                                console.log('[ACE DOM] Sending content to terminal');
                                vscode.postMessage({
                                    type: 'editorSendContent',
                                    data: trimmedContent
                                });
                                console.log('[ACE DOM] Content sent to terminal');

                                // 3. 200ms å¾…æ©Ÿå¾Œã« Enter ã‚’é€ä¿¡
                                setTimeout(() => {
                                    console.log('[ACE DOM] Sending Enter after 200ms');
                                    vscode.postMessage({
                                        type: 'terminalInput',
                                        data: '\r'
                                    });
                                    console.log('[ACE DOM] Enter sent to terminal');

                                    // 4. ã‚¨ãƒ‡ã‚£ã‚¿ã®å†…å®¹ã‚’ã‚¯ãƒªã‚¢
                                    editorState.editor.setValue('', -1);
                                    console.log('[ACE DOM] Editor content cleared');
                                }, 200);
                            } else {
                                console.log('[ACE DOM] Editor content is empty, not sending');
                            }

                            return false; // ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†çµ‚äº†
                        }
                    }, true); // useCapture = true ã§æ—©æœŸã«ã‚­ãƒ£ãƒ—ãƒãƒ£
                    console.log('[ACE] DOM keydown listener added');
                }

                editorState.isInitialized = true;
                console.log('[ACE] Editor initialization completed');

            } catch (error) {
                console.error('[ACE] Error initializing editor:', error);
            }
        }

        // ãƒªã‚½ãƒ¼ã‚¹å®Œå…¨ãƒªã‚»ãƒƒãƒˆé–¢æ•°
        function resetTerminalResources() {
            console.log('[LEAK CHECK] Starting resource reset');

            // xterm ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’å…ˆã« dispose
            if (terminalState.xtermListeners && terminalState.xtermListeners.length > 0) {
                console.log('[LEAK CHECK] Disposing ' + terminalState.xtermListeners.length + ' xterm listeners');
                terminalState.xtermListeners.forEach(listener => {
                    try {
                        if (listener && listener.dispose) {
                            listener.dispose();
                        }
                    } catch (error) {
                        console.error('[LEAK CHECK] Error disposing xterm listener:', error);
                    }
                });
                terminalState.xtermListeners = [];
            }

            // ã‚¢ãƒ‰ã‚ªãƒ³ã‚’ dispose
            if (terminalState.addons && terminalState.addons.length > 0) {
                console.log('[LEAK CHECK] Disposing ' + terminalState.addons.length + ' addons');
                terminalState.addons.forEach(addon => {
                    try {
                        if (addon && addon.dispose) {
                            addon.dispose();
                        }
                    } catch (error) {
                        console.error('[LEAK CHECK] Error disposing addon:', error);
                    }
                });
                terminalState.addons = [];
            }

            // æ—¢å­˜ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚’ç ´æ£„
            if (terminalState.term) {
                try {
                    console.log('[LEAK CHECK] Disposing terminal instance');
                    terminalState.term.dispose();
                } catch (error) {
                    console.error('Error disposing terminal:', error);
                }
                terminalState.term = null;
            }

            // ResizeObserver ã‚’åœæ­¢
            if (terminalState.resizeObserver) {
                try {
                    terminalState.resizeObserver.disconnect();
                } catch (error) {
                    console.error('Error disconnecting ResizeObserver:', error);
                }
                terminalState.resizeObserver = null;
            }

            // ã™ã¹ã¦ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
            Object.keys(terminalState.timers).forEach(timerKey => {
                if (terminalState.timers[timerKey]) {
                    try {
                        clearTimeout(terminalState.timers[timerKey]);
                        clearInterval(terminalState.timers[timerKey]);
                    } catch (error) {
                        console.error(`Error clearing timer ${timerKey}:`, error);
                    }
                    terminalState.timers[timerKey] = null;
                }
            });

            // ãƒãƒƒãƒ•ã‚¡ã‚‚ã‚¯ãƒªã‚¢
            terminalState.writeBufferData = '';
            terminalState.writeBufferPending = false;

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã™ã¹ã¦å‰Šé™¤
            terminalState.eventListeners.forEach(({ element, event, handler }) => {
                try {
                    element.removeEventListener(event, handler);
                } catch (error) {
                    console.error('Error removing event listener:', error);
                }
            });
            terminalState.eventListeners = [];

            // åˆæœŸåŒ–ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            terminalState.isInitialized = false;
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ç™»éŒ²ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆç®¡ç†å¯¾è±¡ã«è¿½åŠ ï¼‰
        function addManagedEventListener(element, event, handler) {
            element.addEventListener(event, handler);
            terminalState.eventListeners.push({ element, event, handler });
        }

        // å¤§é‡ãƒšãƒ¼ã‚¹ãƒˆã®ãƒãƒ£ãƒ³ã‚¯é€ä¿¡æ©Ÿèƒ½
        function sendBytesInChunks(bytes, meta) {
            const CHUNK_SIZE = 32 * 1024; // 32KB ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º
            const id = Math.random().toString(36).slice(2); // ãƒ©ãƒ³ãƒ€ãƒ  ID
            let offset = 0;

            // ACK å¾…ã¡ç”¨ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            const onAck = (event) => {
                const message = event.data;
                if (!message || message.type !== 'terminalInputAck' || message.id !== id) {
                    return;
                }

                if (message.done) {
                    // é€ä¿¡å®Œäº†
                    window.removeEventListener('message', onAck);
                    console.log('[PASTE CHUNKS] All chunks sent successfully');
                    return;
                }

                // æ¬¡ã®ãƒãƒ£ãƒ³ã‚¯ã‚’é€ä¿¡
                sendNextChunk();
            };

            window.addEventListener('message', onAck);

            // é€ä¿¡é–‹å§‹é€šçŸ¥
            console.log('[PASTE CHUNKS] Starting chunked paste, total bytes:', bytes.length);
            vscode.postMessage({
                type: 'terminalInputBegin',
                id: id,
                totalBytes: bytes.length,
                ...meta
            });

            function sendNextChunk() {
                if (offset >= bytes.length) {
                    // é€ä¿¡çµ‚äº†é€šçŸ¥
                    vscode.postMessage({ type: 'terminalInputEnd', id: id });
                    return;
                }

                const chunkEnd = Math.min(offset + CHUNK_SIZE, bytes.length);
                const slice = bytes.subarray(offset, chunkEnd);

                // base64 ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§å®‰å…¨ã«è»¢é€
                const b64 = btoa(String.fromCharCode.apply(null, slice));

                console.log('[PASTE CHUNKS] Sending chunk', offset, 'to', chunkEnd, 'of', bytes.length);
                vscode.postMessage({
                    type: 'terminalInputChunk',
                    id: id,
                    b64: b64,
                    offset: offset,
                    size: slice.length
                });

                offset = chunkEnd;
            }

            // æœ€åˆã®ãƒãƒ£ãƒ³ã‚¯ã‚’é€ä¿¡
            sendNextChunk();
        }

        // å®šæœŸçš„ãªãƒãƒƒãƒ•ã‚¡ã‚¯ãƒªã‚¢æ©Ÿèƒ½
        function setupPeriodicBufferCleanup() {
            // è¨­å®šå¯èƒ½ãªå€¤
            const BUFFER_CHECK_INTERVAL = 30000; // 30ç§’é–“éš”ã§ãƒã‚§ãƒƒã‚¯
            const CLEANUP_THRESHOLD = Math.floor(MAX_BUFFER_LINES * 0.8); // 80%ã§è­¦å‘Š
            const CLEANUP_TARGET = Math.floor(MAX_BUFFER_LINES * 0.6); // 60%ã¾ã§å‰Šæ¸›

            console.log('[BUFFER CLEANUP] Setting up periodic buffer cleanup', {
                checkInterval: BUFFER_CHECK_INTERVAL,
                maxLines: MAX_BUFFER_LINES,
                cleanupThreshold: CLEANUP_THRESHOLD,
                cleanupTarget: CLEANUP_TARGET
            });

            const bufferCleanupTimer = setInterval(() => {
                if (!terminalState.term) {
                    return;
                }

                try {
                    const buffer = terminalState.term.buffer;
                    if (!buffer || !buffer.active) {
                        return;
                    }

                    const totalLines = buffer.active.length;
                    const scrollbackLines = totalLines - terminalState.term.rows;

                    console.log('[BUFFER CLEANUP] Buffer check', {
                        totalLines,
                        scrollbackLines,
                        threshold: CLEANUP_THRESHOLD,
                        terminalRows: terminalState.term.rows
                    });

                    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡Œæ•°ãŒé–¾å€¤ã‚’è¶…ãˆãŸå ´åˆã€ã‚¯ãƒªã‚¢ã‚’å®Ÿè¡Œ
                    if (scrollbackLines > CLEANUP_THRESHOLD) {
                        console.log('[BUFFER CLEANUP] Buffer cleanup triggered', {
                            currentLines: scrollbackLines,
                            targetLines: CLEANUP_TARGET
                        });

                        // ç¾åœ¨ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’ä¿å­˜
                        const currentScrollY = terminalState.term.buffer.active.viewportY;
                        const isAtBottom = currentScrollY >= (totalLines - terminalState.term.rows);

                        console.log('[BUFFER CLEANUP] Current scroll position', {
                            currentScrollY,
                            totalLines,
                            terminalRows: terminalState.term.rows,
                            isAtBottom
                        });

                        // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚¯ãƒªã‚¢ã‚’å®Ÿè¡Œ
                        setTimeout(() => {
                            try {
                                // VSCode å´ã«ãƒãƒƒãƒ•ã‚¡ã‚¯ãƒªã‚¢è¦æ±‚ã‚’é€ä¿¡
                                vscode.postMessage({
                                    type: 'bufferCleanupRequest',
                                    currentLines: scrollbackLines,
                                    threshold: CLEANUP_THRESHOLD,
                                    preserveScrollPosition: !isAtBottom // æœ€ä¸‹éƒ¨ã«ã„ãªã„å ´åˆã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’ä¿æŒ
                                });

                                // æœ€ä¸‹éƒ¨ã«ã„ãªã„å ´åˆã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’å¤‰æ›´ã—ãªã„
                                // æœ€ä¸‹éƒ¨ã«ã„ã‚‹å ´åˆã€ã¾ãŸã¯å•é¡ŒãŒã‚ã‚‹å ´åˆã®ã¿ scrollToBottom() ã‚’å®Ÿè¡Œ
                                if (isAtBottom) {
                                    console.log('[BUFFER CLEANUP] User was at bottom, scrolling to bottom');
                                    terminalState.term.scrollToBottom();
                                } else {
                                    console.log('[BUFFER CLEANUP] User was not at bottom, preserving scroll position');
                                }

                                console.log('[BUFFER CLEANUP] Buffer cleanup completed');

                            } catch (error) {
                                console.error('[BUFFER CLEANUP] Error during buffer cleanup:', error);
                                // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã®ã¿å¼·åˆ¶çš„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                                terminalState.term.scrollToBottom();
                            }
                        }, 100);
                    }
                } catch (error) {
                    console.error('[BUFFER CLEANUP] Error checking buffer:', error);
                }
            }, BUFFER_CHECK_INTERVAL);

            // ã‚¿ã‚¤ãƒãƒ¼ã‚’ç®¡ç†å¯¾è±¡ã«è¿½åŠ 
            terminalState.timers.bufferCleanup = bufferCleanupTimer;
            console.log('[BUFFER CLEANUP] Periodic buffer cleanup timer set');
        }

        // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«åˆæœŸåŒ–é–¢æ•°
        function initializeTerminal() {
            try {
                // é‡è¤‡åˆæœŸåŒ–ã‚’å³å¯†ã«ãƒã‚§ãƒƒã‚¯
                if (terminalState.isInitialized) {
                    console.warn('[INIT] Terminal is already initialized, skipping duplicate initialization');

                    // æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯ã€ã‚µã‚¤ã‚ºèª¿æ•´ã¨ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã®ã¿å®Ÿè¡Œ
                    if (terminalState.term) {
                        setTimeout(() => {
                            setTerminalSize();
                            terminalState.term.focus();
                        }, 50);
                    }
                    return;
                }

                // äºŒé‡åˆæœŸåŒ–ã‚’é˜²ããŸã‚ã€æœ€åˆã«ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                terminalState.isInitialized = true;

                console.log('[INIT] Starting terminal initialization');


                if (typeof Terminal === 'undefined') {
                    throw new Error('Terminal is not defined. xterm.js may not have loaded.');
                }

                terminalState.term = new Terminal({
                    theme: {
                        background: 'transparent',
                        foreground: 'var(--vscode-terminal-foreground)',
                        cursor: 'var(--vscode-terminal-cursor-foreground)',
                        selection: 'var(--vscode-terminal-selection-background)'
                    },
                    fontFamily: '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace',
                    fontSize: 13,
                    letterSpacing: 0,
                    lineHeight: 1.2,
                    cursorBlink: false,
                    smoothScrollDuration: 0,  // ã‚¹ãƒ ãƒ¼ã‚ºã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç„¡åŠ¹åŒ–ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šï¼‰
                    convertEol: true,
                    allowProposedApi: true,
                    allowTransparency: false,
                    minimumContrastRatio: 1,
                    // ãƒšãƒ¼ã‚¹ãƒˆã‚’ã‚¢ãƒ—ãƒªã«ã€Œã¾ã¨ã¾ã‚Šã€ã¨ã—ã¦ä¼ãˆã‚‹
                    bracketedPasteMode: true,
                    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸Šé™ã‚’è¨­å®šï¼ˆå¤§ããªå±¥æ­´ã§ã® write/render è² è·ã‚’è»½æ¸›ï¼‰
                    scrollback: MAX_BUFFER_LINES
                });

                const terminalElement = document.getElementById('terminal');
                terminalState.term.open(terminalElement);

                // Unicode 11 ã‚¢ãƒ‰ã‚ªãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
                if (typeof Unicode11Addon !== 'undefined') {
                    try {
                        const unicode11 = new Unicode11Addon.Unicode11Addon();
                        terminalState.term.loadAddon(unicode11);
                        unicode11.activate(terminalState.term);
                        console.log('[LEAK CHECK] Unicode11 addon loaded');

                        // ã‚¢ãƒ‰ã‚ªãƒ³ã‚’ç®¡ç†å¯¾è±¡ã«è¿½åŠ 
                        if (!terminalState.addons) {
                            terminalState.addons = [];
                        }
                        terminalState.addons.push(unicode11);
                    } catch (error) {
                        console.error('Failed to load Unicode 11 addon:', error);
                    }
                }

                // Canvas ã‚¢ãƒ‰ã‚ªãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
                if (typeof CanvasAddon !== 'undefined') {
                    try {
                        const canvas = new CanvasAddon.CanvasAddon();
                        terminalState.term.loadAddon(canvas);
                        console.log('[LEAK CHECK] Canvas addon loaded');

                        // ã‚¢ãƒ‰ã‚ªãƒ³ã‚’ç®¡ç†å¯¾è±¡ã«è¿½åŠ 
                        if (!terminalState.addons) {
                            terminalState.addons = [];
                        }
                        terminalState.addons.push(canvas);
                    } catch (error) {
                        console.error('Failed to load Canvas addon:', error);
                    }
                }

                // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«è¦ç´ ã®ã‚µã‚¤ã‚ºãŒç¢ºå®šã™ã‚‹ã¾ã§å¾…æ©Ÿ
                function waitForSize() {
                    return new Promise((resolve) => {
                        const checkSize = () => {
                            const rect = terminalElement.getBoundingClientRect();
                            if (rect.width > 0 && rect.height > 0) {

                                resolve();
                            } else {
                                setTimeout(checkSize, 10);
                            }
                        };
                        checkSize();
                    });
                }

                // ã‚µã‚¤ã‚ºç¢ºå®šå¾Œã«åˆæœŸè¨­å®š
                waitForSize().then(() => {
                    // åˆæœŸã‚µã‚¤ã‚ºè¨­å®š
                    setTerminalSize();

                });

                // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚µã‚¤ã‚ºã‚’å‹•çš„ã«è¨­å®šï¼ˆå…ƒã®æ‰‹å‹•è¨ˆç®—æ–¹å¼ï¼‰
                function setTerminalSize() {
                    const container = document.querySelector('.terminal-container');
                    const terminal = document.getElementById('terminal');

                    if (!container || !terminal) {
                        console.warn('Terminal container not found');
                        return;
                    }

                    // ã‚³ãƒ³ãƒ†ãƒŠã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’å–å¾—
                    const terminalRect = terminal.getBoundingClientRect();
                    const availableWidth = terminalRect.width - 20; // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°è€ƒæ…®
                    // const availableHeight = Math.max(terminalRect.height - 20, 200); // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°è€ƒæ…®
                    const availableHeight = terminalRect.height - 5;

                    // ãƒ•ã‚©ãƒ³ãƒˆæƒ…å ±ã‹ã‚‰æ–‡å­—ã‚µã‚¤ã‚ºã‚’æ­£ç¢ºã«è¨ˆç®—
                    const fontSize = 13;
                    const targetLineHeight = 1.2; // Terminalè¨­å®šã¨åŒã˜è¡Œé–“

                    // ä¸€æ™‚çš„ãªæ¸¬å®šç”¨ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã¦æ–‡å­—å¹…ã‚’æ­£ç¢ºã«æ¸¬å®š
                    const measurer = document.createElement('div');
                    measurer.style.position = 'absolute';
                    measurer.style.visibility = 'hidden';
                    measurer.style.fontFamily = '"RobotoMono Nerd Font Mono", "RobotoMono Nerd Font", "Roboto Mono", Consolas, "Courier New", monospace';
                    measurer.style.fontSize = fontSize + 'px';
                    measurer.style.lineHeight = targetLineHeight; // æ•°å€¤ã§æŒ‡å®š
                    measurer.style.whiteSpace = 'pre';
                    measurer.textContent = 'M'.repeat(10); // ç­‰å¹…ãƒ•ã‚©ãƒ³ãƒˆã®Mæ–‡å­—ã§æ¸¬å®š

                    document.body.appendChild(measurer);
                    const rawCharWidth = measurer.getBoundingClientRect().width / 10;
                    const rawLineHeight = measurer.getBoundingClientRect().height;
                    document.body.removeChild(measurer);

                    // ã‚µã‚¤ã‚ºèª¿æ•´ä¿‚æ•°ï¼ˆå¾®èª¿æ•´ç”¨ï¼‰
                    // å¤§ããã™ã‚‹ã»ã©è¡¨ç¤ºã‚µã‚¤ã‚ºã¯å°ã•ããªã‚‹ã€‚ã¯ã¿å‡ºã—ãŸã‚‰å¤§ããã™ã‚‹ã€‚
                    const widthAdjustment = 0.88; // æ¨ªå¹…ã‚’å°‘ã—è©°ã‚ã‚‹ï¼ˆå³ä½™ç™½ã‚’æ¸›ã‚‰ã™ï¼‰
                    //const widthAdjustment = 1.0; // æ¨ªå¹…ã‚’å°‘ã—è©°ã‚ã‚‹ï¼ˆå³ä½™ç™½ã‚’æ¸›ã‚‰ã™ï¼‰
                    const heightAdjustment = 1.34; // ç¸¦å¹…ã‚’å°‘ã—è©°ã‚ã‚‹ï¼ˆã¯ã¿å‡ºã—é˜²æ­¢ï¼‰

                    const adjustedCharWidth = rawCharWidth * widthAdjustment;
                    const adjustedLineHeight = rawLineHeight * heightAdjustment;

                    // åˆ—æ•°ã¨è¡Œæ•°ã‚’è¨ˆç®—
                    const cols = Math.floor(availableWidth / adjustedCharWidth);
                    const rows = Math.floor(availableHeight / adjustedLineHeight);

                    // æœ€å°ã‚µã‚¤ã‚ºã‚’ä¿è¨¼
                    const finalCols = Math.max(cols, 20);
                    const finalRows = Math.max(rows, 5);

                    // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚µã‚¤ã‚ºã‚’è¨­å®š
                    if (terminalState.term && (terminalState.term.cols !== finalCols || terminalState.term.rows !== finalRows)) {
                        terminalState.term.resize(finalCols, finalRows);

                        // ã‚µã‚¤ã‚ºå¤‰æ›´ã‚’ VSCode ã«é€šçŸ¥
                        vscode.postMessage({
                            type: 'resize',
                            cols: finalCols,
                            rows: finalRows
                        });


                    }
                }

                // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ™‚ã®å‡¦ç†
                const windowResizeHandler = () => {
                    setTimeout(setTerminalSize, 50);
                };
                addManagedEventListener(window, 'resize', windowResizeHandler);

                // ResizeObserver ã§ã‚³ãƒ³ãƒ†ãƒŠã‚µã‚¤ã‚ºå¤‰æ›´ã‚’ç›£è¦–
                let lastResizeTime = 0;
                let resizeCount = 0;

                // æ—¢å­˜ã® ResizeObserver ãŒã‚ã‚Œã°è­¦å‘Š
                if (terminalState.resizeObserver) {
                    console.warn('[LEAK CHECK] ResizeObserver already exists! This might be a duplicate.');
                }

                terminalState.resizeObserver = new ResizeObserver((entries) => {
                    const now = Date.now();
                    resizeCount++;

                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬ã‚’æ›´æ–°
                    performanceMetrics.resizeObserverCount++;

                    // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ï¼šé€£ç¶šã™ã‚‹ resize ã‚’åˆ¶é™
                    if (now - lastResizeTime < 100) {

                        return;
                    }

                    for (const entry of entries) {

                        lastResizeTime = now;

                        // é…å»¶ã‚’çŸ­ç¸®ã—ã¦ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–æ€§ã‚’å‘ä¸Š
                        setTimeout(setTerminalSize, 30);
                    }
                });

                // terminal-container ã‚’ç›£è¦–
                const container = document.querySelector('.terminal-container');
                if (container) {
                    terminalState.resizeObserver.observe(container);
                }

                // å®šæœŸçš„ãªã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆVSCode ã®åˆ¶ç´„å¯¾å¿œï¼‰
                let lastSizeCheck = Date.now();
                // ãƒªãƒ¼ã‚¯æ¤œè¨¼ã®ãŸã‚ä¸€æ—¦ç„¡åŠ¹åŒ–
                // terminalState.timers.sizeCheckInterval = setInterval(() => {
                //     const now = Date.now();
                //     lastSizeCheck = now;
                //     setTerminalSize();
                // }, 2000);
                setTimeout(() => {
                    setTerminalSize();
                }, 2000);

                let cliAgentState = { active: false, agent_type: null }; // CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®çŠ¶æ…‹

                // CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®è¡¨ç¤ºæ›´æ–°
                function updateCliAgentIndicator() {
                    const indicator = document.getElementById('cli-agent-indicator');
                    if (indicator) {
                        if (cliAgentState.active) {
                            indicator.classList.add('active');
                            // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç¨®åˆ¥ã«å¿œã˜ãŸãƒ©ãƒ™ãƒ«è¡¨ç¤º
                            if (cliAgentState.agent_type === 'claude') {
                                indicator.textContent = 'Claude';
                                indicator.title = 'Claude is active - Shift+Enter inputs a newline';
                            } else if (cliAgentState.agent_type === 'gemini') {
                                indicator.textContent = 'Gemini';
                                indicator.title = 'Gemini is active - Shift+Enter inputs a newline';
                            } else if (cliAgentState.agent_type === 'codex') {
                                indicator.textContent = 'Codex';
                                indicator.title = 'Codex is active - Shift+Enter sends Ctrl+J';
                            } else {
                                indicator.textContent = 'CLI Agent';
                                indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                            }
                        } else {
                            indicator.classList.remove('active');
                            indicator.textContent = 'CLI Agent';
                            indicator.title = 'CLI Agent is active - Shift+Enter inputs a newline';
                        }
                    }
                }

                // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
                function handleStatusMessage(data) {
                    try {
                        // CSI ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ ]777; ã§å§‹ã¾ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†ï¼ˆå®Ÿéš›ã®ESCæ–‡å­—ã‚’æ¤œç´¢ï¼‰
                        if (data.includes('\x1b]777;')) {
                            const match = data.match(/\x1b\]777;(.+?)\x07/);
                            if (match) {
                                const messageJson = match[1];
                                const message = JSON.parse(messageJson);

                                if (message.type === 'cli_agent_status') {
                                    cliAgentState = message.data;

                                    updateCliAgentIndicator(); // ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼è¡¨ç¤ºã‚’æ›´æ–°
                                }

                                if (message.type === 'child_process_count') {
                                    performanceMetrics.childProcessCount = message.data.count || 0;
                                }
                            }
                        }
                    } catch (error) {
                        // JSON ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                        console.debug('Status message parse error:', error);
                    }
                }

                // Shift + Enter ã‚’ Alt + Enter ã«å¤‰æ›ã™ã‚‹ã‚­ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
                try {
                    if (typeof terminalState.term.attachCustomKeyEventHandler === 'function') {


                        terminalState.term.attachCustomKeyEventHandler(function (event) {
                            // ESC ã‚­ãƒ¼ã®å‡¦ç†ï¼ˆvim ãªã©å¯¾å¿œï¼‰
                            if (event.type === 'keydown' && event.key === 'Escape') {
                                // ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’å®Œå…¨ã«åœæ­¢
                                event.preventDefault();
                                event.stopPropagation();

                                // æ­£ã—ã„ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’é€ä¿¡
                                vscode.postMessage({
                                    type: 'terminalInput',
                                    data: '\x1b'  // ESCæ–‡å­—ï¼ˆASCII 27ï¼‰ã‚’ç¢ºå®Ÿã«é€ä¿¡
                                });

                                // false ã‚’è¿”ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†ã‚’å®Œå…¨ã«åœæ­¢
                                return false;
                            }

                            // Shift + Enter ã®å ´åˆï¼ˆCLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå‹•ä½œä¸­ã®ã¨ãã®ã¿ï¼‰
                            if (event.type === 'keydown' &&
                                event.key === 'Enter' &&
                                event.shiftKey &&
                                !event.ctrlKey &&
                                !event.altKey &&
                                !event.metaKey) {

                                // CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆClaude/Geminiï¼‰ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã®å ´åˆã®ã¿ Alt+Enter ã«å¤‰æ›
                                if (cliAgentState.active) {
                                    const agentType = cliAgentState.agent_type || 'CLI Agent';
                                    // ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’å®Œå…¨ã«åœæ­¢
                                    event.preventDefault();
                                    event.stopPropagation();

                                    if (agentType === 'codex') {
                                        // Codex ãƒ¢ãƒ¼ãƒ‰: Ctrl+J ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ (LF)
                                        const ctrlJ = '\n';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            data: ctrlJ
                                        });
                                    } else {
                                        // æ—¢å­˜ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ(Claude/Gemini): Alt+Enter ã‚’é€ä¿¡ (ESC + CR)
                                        const altEnterSequence = '\x1b\r';
                                        vscode.postMessage({
                                            type: 'terminalInput',
                                            data: altEnterSequence
                                        });
                                    }

                                    // false ã‚’è¿”ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†ã‚’å®Œå…¨ã«åœæ­¢
                                    return false;
                                } else {
                                    // CLI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ãªã„å ´åˆã¯é€šå¸¸ã® Enter ã¨ã—ã¦å‡¦ç†

                                    return true;
                                }
                            }

                            // ãã®ä»–ã®ã‚­ãƒ¼ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†ã‚’ç¶™ç¶š
                            return true;
                        });


                    } else {
                        console.warn('attachCustomKeyEventHandler is not available');
                    }
                } catch (error) {
                    console.error('Failed to attach custom key handler:', error);
                }

                // onData ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ä¿å­˜ã—ã¦å¾Œã§ dispose ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
                const dataListener = terminalState.term.onData((data) => {
                    vscode.postMessage({
                        type: 'terminalInput',
                        data: data
                    });
                });

                // dataListener ã‚’ç®¡ç†å¯¾è±¡ã«è¿½åŠ ï¼ˆdispose æ™‚ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹ãŸã‚ï¼‰
                if (!terminalState.xtermListeners) {
                    terminalState.xtermListeners = [];
                }
                terminalState.xtermListeners.push(dataListener);
                console.log('[LEAK CHECK] Added onData listener, total listeners: ' + terminalState.xtermListeners.length);

                // ãƒšãƒ¼ã‚¹ãƒˆã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆDOM ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½¿ç”¨ï¼‰
                const pasteHandler = (event) => {
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒšãƒ¼ã‚¹ãƒˆå‡¦ç†ã‚’é˜»æ­¢
                    event.preventDefault();

                    // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                    const clipboardData = event.clipboardData || window.clipboardData;
                    if (clipboardData && clipboardData.getData) {
                        const pastedText = clipboardData.getData('text');
                        if (pastedText) {
                            console.log('[PASTE] Intercepted paste event, length:', pastedText.length);
                            // å¤§é‡ãƒšãƒ¼ã‚¹ãƒˆæ™‚ã¯ãƒãƒ£ãƒ³ã‚¯é€ä¿¡ã§ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡
                            sendBytesInChunks(new TextEncoder().encode(pastedText), { kind: 'paste' });
                        }
                    }
                };

                // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«è¦ç´ ã«ãƒšãƒ¼ã‚¹ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                addManagedEventListener(terminalElement, 'paste', pasteHandler);
                console.log('[LEAK CHECK] Added DOM paste listener');

                let outputCount = 0;
                let totalOutputChars = 0;

                const messageHandler = (event) => {
                    const message = event.data;
                    switch (message.type) {
                        case 'output':
                            const outputStart = performance.now();
                            outputCount++;
                            totalOutputChars += message.data.length;

                            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬ã‚’æ›´æ–°
                            performanceMetrics.outputCount++;
                            performanceMetrics.totalOutputChars += message.data.length;

                            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒã‚§ãƒƒã‚¯
                            handleStatusMessage(message.data);

                            // ãƒãƒƒãƒå‡¦ç†: ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒ•ã‚¡ã«è¿½åŠ 
                            terminalState.writeBufferData += message.data;

                            // ã¾ã ã‚¿ã‚¤ãƒãƒ¼ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿
                            if (!terminalState.writeBufferPending && terminalState.term) {
                                terminalState.writeBufferPending = true;

                                // 16ms å¾Œ (ç´„60fps) ã«ä¸€æ‹¬æ›¸ãè¾¼ã¿
                                terminalState.timers.writeBuffer = setTimeout(() => {
                                    if (terminalState.term && terminalState.writeBufferData) {
                                        // write å‡¦ç†ã®æ™‚é–“ã‚’è¨ˆæ¸¬
                                        const writeStart = performance.now();
                                        terminalState.term.write(terminalState.writeBufferData);
                                        const writeEnd = performance.now();
                                        const writeTime = writeEnd - writeStart;

                                        // è¨ˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                                        performanceMetrics.lastWriteTime = writeTime;
                                        performanceMetrics.writeTimeSum += writeTime;
                                        performanceMetrics.writeTimeCount++;
                                        performanceMetrics.avgWriteTime = performanceMetrics.writeTimeSum / performanceMetrics.writeTimeCount;
                                        performanceMetrics.maxWriteTime = Math.max(performanceMetrics.maxWriteTime, writeTime);
                                        performanceMetrics.writeBufferSize = terminalState.writeBufferData.length;

                                        terminalState.writeBufferData = '';
                                    }
                                    terminalState.writeBufferPending = false;
                                    terminalState.timers.writeBuffer = null;
                                }, 16);
                            }

                            const outputEnd = performance.now();
                            const outputTime = outputEnd - outputStart;

                            // é‡ã„å‡¦ç†ï¼ˆ2msä»¥ä¸Šï¼‰ã®ã¿ãƒ­ã‚°å‡ºåŠ›
                            if (outputTime > 2) {

                            }

                            // 100å›ã”ã¨ã«çµ±è¨ˆã‚’å‡ºåŠ›
                            if (outputCount % 100 === 0) {

                            }
                            break;
                        case 'clear':
                            if (terminalState.term) {
                                terminalState.term.clear();
                            }

                            break;
                        case 'reset':
                            // VSCode å´ã®ãƒªã‚»ãƒƒãƒˆå®Œäº†ã«åˆã‚ã›ã¦ã€ãƒ•ãƒ­ãƒ³ãƒˆå´ã‚‚å®Œå…¨å†åˆæœŸåŒ–
                            // ã“ã‚Œã«ã‚ˆã‚Šã‚­ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ã€ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã€ResizeObserverã€ã‚¿ã‚¤ãƒãƒ¼ã‚’å¥å…¨ãªçŠ¶æ…‹ã«æˆ»ã™
                            resetTerminalResources();
                            setTimeout(() => {
                                initializeTerminal();
                            }, 10);
                            break;
                        case 'visibility_restored':
                            // WebView ã®å¯è¦–çŠ¶æ…‹ãŒå¾©å…ƒã•ã‚ŒãŸæ™‚ã®å‡¦ç†
                            console.log('[LEAK CHECK] visibility_restored event received');
                            if (terminalState.term) {
                                // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ã€ã‚µã‚¤ã‚ºã‚’å†èª¿æ•´
                                setTimeout(() => {
                                    console.log('[LEAK CHECK] Calling setTerminalSize from visibility_restored');
                                    setTerminalSize();
                                    // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å¾©å…ƒ
                                    terminalState.term.focus();

                                    // CLI AgentçŠ¶æ…‹ã‚’å¼·åˆ¶çš„ã«å†ãƒã‚§ãƒƒã‚¯è¦æ±‚
                                    vscode.postMessage({
                                        type: 'refreshCliAgentStatus',
                                        timestamp: Date.now()
                                    });
                                }, 50);
                            } else if (terminalState.isInitialized) {
                                // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ãŒç ´æ£„ã•ã‚Œã¦ã„ã‚‹ãŒåˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯ã€çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                                console.warn('Terminal was disposed unexpectedly, resetting state');
                                resetTerminalResources();
                                // ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦å®Œå…¨ã«å¾©å…ƒ
                                window.location.reload();
                            }
                            break;
                        case 'bufferCleanupCompleted':
                            console.log('[BUFFER CLEANUP] Received cleanup completion notification', {
                                success: message.success,
                                timestamp: message.timestamp,
                                error: message.error
                            });
                            if (!message.success) {
                                console.error('[BUFFER CLEANUP] Backend cleanup failed:', message.error);
                            }
                            break;
                        case 'sendTextToEditor':
                            // ãƒ†ã‚­ã‚¹ãƒˆã‚’ ACE ã‚¨ãƒ‡ã‚£ã‚¿ã«å…¥åŠ›
                            if (editorState.editor && message.text) {
                                editorState.editor.insert(message.text);
                                editorState.editor.focus();
                            }
                            break;
                    }
                };
                addManagedEventListener(window, 'message', messageHandler);

                // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®š
                const sendSelectionHandler = () => {
                    vscode.postMessage({ type: 'buttonSendSelection' });
                    // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯å¾Œã«ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç§»å‹•
                    if (terminalState.term) {
                        terminalState.term.focus();
                    }
                };
                addManagedEventListener(document.getElementById('btn-send-selection'), 'click', sendSelectionHandler);

                // ã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
                const copySelectionHandler = () => {
                    const button = document.getElementById('btn-copy-selection');

                    vscode.postMessage({ type: 'buttonCopySelection' });

                    // ãƒœã‚¿ãƒ³ã« .done ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ ã—ã¦ãƒã‚§ãƒƒã‚¯ãƒãƒ¼ã‚¯è¡¨ç¤º
                    button.classList.add('done');
                    setTimeout(() => {
                        button.classList.remove('done');
                    }, 2000);

                    // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯å¾Œã«ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç§»å‹•
                    if (terminalState.term) {
                        terminalState.term.focus();
                    }
                };
                addManagedEventListener(document.getElementById('btn-copy-selection'), 'click', copySelectionHandler);

                // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
                const resetButtonHandler = () => {

                    // VSCode å´ã§ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤ºã—ã¦ã‚‚ã‚‰ã†
                    vscode.postMessage({ type: 'buttonResetRequest' });
                };
                addManagedEventListener(document.getElementById('reset-button'), 'click', resetButtonHandler);

                // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
                const scrollToBottomHandler = () => {
                    // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚’ä¸€ç•ªä¸‹ã¾ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                    if (terminalState.term) {
                        terminalState.term.scrollToBottom();
                        terminalState.term.focus();
                    }
                };
                addManagedEventListener(document.getElementById('btn-scroll-to-bottom'), 'click', scrollToBottomHandler);

                // å®šæœŸçš„ãªãƒãƒƒãƒ•ã‚¡ã‚¯ãƒªã‚¢æ©Ÿèƒ½ã‚’è¨­å®š
                setupPeriodicBufferCleanup();

                // åˆæœŸåŒ–å®Œäº†ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                terminalState.isInitialized = true;

                // å…¥åŠ›ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’æ˜ç¤ºçš„ã«ä¸ãˆã‚‹
                if (terminalState.term) {
                    terminalState.term.focus();
                }

                // VSCode å´ã«æº–å‚™å®Œäº†ã‚’é€šçŸ¥ï¼ˆã“ã‚Œã‚’ãƒˆãƒªã‚¬ã«ã‚·ã‚§ãƒ«ã‚’èµ·å‹•ï¼‰
                vscode.postMessage({ type: 'terminalReady' });

            } catch (error) {
                console.error('Error initializing terminal:', error);
                vscode.postMessage({ type: 'error', error: error.message });
                document.getElementById('terminal').innerHTML = '<p style="color: red;">Error loading terminal: ' + error.message + '</p>';
            }
        }

        // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
        initializeTerminal();

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ HUD ã‚’åˆæœŸåŒ–
        setupPerformanceHUD();

        // ACE ã‚¨ãƒ‡ã‚£ã‚¿åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
        setTimeout(() => {
            console.log('[ACE] Attempting to initialize editor...');
            initializeAceEditor();
            // åˆæœŸåŒ–å¾Œã®ç¢ºèª
            if (editorState.editor) {
                console.log('[ACE] Editor successfully initialized, testing keybindings...');
                const commands = editorState.editor.commands.byName;
                if (commands.sendToTerminal) {
                    console.log('[ACE] sendToTerminal command is registered');
                } else {
                    console.error('[ACE] sendToTerminal command NOT found!');
                }
            } else {
                console.error('[ACE] Editor initialization failed!');
            }
        }, 100);

        // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã®èƒŒæ™¯è‰²ã‚’ã‚³ãƒ³ãƒ†ãƒŠã®èƒŒæ™¯è‰²ã«é©ç”¨ã•ã›ã‚‹
        (function () {
            const terminalContainer = document.getElementById('terminal-container');
            let backgroundColorCheckCount = 0;
            let lastBackgroundCheck = Date.now();
            let isBackgroundStable = false; // èƒŒæ™¯è‰²ãŒå®‰å®šã—ãŸã‹ã®ãƒ•ãƒ©ã‚°

            function applyBackgroundColor() {
                const now = Date.now();
                backgroundColorCheckCount++;

                lastBackgroundCheck = now;

                const textLayer = document.querySelector('#terminal canvas.xterm-text-layer');
                if (!textLayer) {

                    return;
                }

                const ctx = textLayer.getContext('2d');
                if (!ctx || !textLayer.width || !textLayer.height) {

                    return;
                }

                const performanceStart = performance.now();

                // Canvas ã®ã‚µã‚¤ã‚ºã‚’å–å¾—
                const width = textLayer.width;
                const height = textLayer.height;

                // å››éš…ã®åº§æ¨™ã‚’å®šç¾©
                const corners = [
                    { x: 0, y: 0 },              // å·¦ä¸Š
                    { x: width - 1, y: 0 },      // å³ä¸Š
                    { x: 0, y: height - 1 },     // å·¦ä¸‹
                    { x: width - 1, y: height - 1 } // å³ä¸‹
                ];

                try {
                    // å„éš…ã®è‰²ã‚’å–å¾—
                    const colors = corners.map(corner => {
                        const imageData = ctx.getImageData(corner.x, corner.y, 1, 1);
                        const data = imageData.data;
                        return {
                            r: data[0],
                            g: data[1],
                            b: data[2],
                            a: data[3]
                        };
                    });

                    // ã™ã¹ã¦ã®è‰²ãŒåŒã˜ã‹ãƒã‚§ãƒƒã‚¯
                    const firstColor = colors[0];
                    const allSameColor = colors.every(color =>
                        color.r === firstColor.r &&
                        color.g === firstColor.g &&
                        color.b === firstColor.b &&
                        color.a === firstColor.a
                    );

                    // ã™ã¹ã¦åŒã˜è‰²ã®å ´åˆã®ã¿èƒŒæ™¯è‰²ã‚’å¤‰æ›´
                    if (allSameColor) {
                        const rgba = `rgba(${firstColor.r}, ${firstColor.g}, ${firstColor.b}, ${firstColor.a / 255})`;

                        // èƒŒæ™¯è‰²ãŒå¤‰ã‚ã£ãŸå ´åˆã®ã¿æ›´æ–°
                        const currentBg = terminalContainer.style.backgroundColor;
                        if (currentBg !== rgba) {
                            terminalContainer.style.backgroundColor = rgba;

                        }
                    }

                    const performanceEnd = performance.now();

                } catch (error) {
                    console.error('[PERF] Error reading canvas pixel data:', error);
                }
            }

            // åˆå›å®Ÿè¡Œã‚’å°‘ã—é…å»¶ã•ã›ã‚‹ (Canvas ãŒå®Œå…¨ã«æç”»ã•ã‚Œã‚‹ã®ã‚’å¾…ã¤)
            setTimeout(applyBackgroundColor, 500);

            // ãƒªãƒ¼ã‚¯æ¤œè¨¼ã®ãŸã‚ä¸€æ—¦ç„¡åŠ¹åŒ–
            terminalState.timers.backgroundColorInterval = setInterval(() => {
                const textLayer = document.querySelector('#terminal canvas.xterm-text-layer');
                if (textLayer && textLayer.getContext) {
                    applyBackgroundColor();
                }
            }, 4000);
            // setTimeout(applyBackgroundColor, 4000);
        })();


    </script>
</body>

</html>